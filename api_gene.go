/*
NCBI Datasets API

### NCBI Datasets is a resource that lets you easily gather data from NCBI. The Datasets version 2 API is still in alpha, and we're updating it often to add new functionality, iron out bugs and enhance usability. For some larger downloads, you may want to download a [dehydrated zip archive](https://www.ncbi.nlm.nih.gov/datasets/docs/v2/how-tos/genomes/large-download/), and retrieve the individual data files at a later time. 

API version: v2alpha
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package ncbi-openapi-v2_goland

import (
	"bytes"
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
	"os"
	"reflect"
)


// GeneApiService GeneApi service
type GeneApiService service

type GeneApiDownloadGenePackageRequest struct {
	ctx context.Context
	ApiService *GeneApiService
	geneIds []int32
	includeAnnotationType *[]V2Fasta
	fastaFilter *[]string
	auxReport *[]V2GeneDatasetRequestGeneDatasetReportType
	tableFields *[]string
	tableReportType *V2GeneDatasetRequestGeneDatasetReportType
	filename *string
}

// Select additional types of annotation to include in the data package.  If unset, no annotation is provided.
func (r GeneApiDownloadGenePackageRequest) IncludeAnnotationType(includeAnnotationType []V2Fasta) GeneApiDownloadGenePackageRequest {
	r.includeAnnotationType = &includeAnnotationType
	return r
}

// Limit the FASTA sequences in the datasets package to these transcript and protein accessions
func (r GeneApiDownloadGenePackageRequest) FastaFilter(fastaFilter []string) GeneApiDownloadGenePackageRequest {
	r.fastaFilter = &fastaFilter
	return r
}

// list additional reports to include with download. Data report is included by default.
func (r GeneApiDownloadGenePackageRequest) AuxReport(auxReport []V2GeneDatasetRequestGeneDatasetReportType) GeneApiDownloadGenePackageRequest {
	r.auxReport = &auxReport
	return r
}

// Specify which fields to include in the tabular report
func (r GeneApiDownloadGenePackageRequest) TableFields(tableFields []string) GeneApiDownloadGenePackageRequest {
	r.tableFields = &tableFields
	return r
}

// Specify the report from which the table fields will be taken
func (r GeneApiDownloadGenePackageRequest) TableReportType(tableReportType V2GeneDatasetRequestGeneDatasetReportType) GeneApiDownloadGenePackageRequest {
	r.tableReportType = &tableReportType
	return r
}

// Output file name.
func (r GeneApiDownloadGenePackageRequest) Filename(filename string) GeneApiDownloadGenePackageRequest {
	r.filename = &filename
	return r
}

func (r GeneApiDownloadGenePackageRequest) Execute() (**os.File, *http.Response, error) {
	return r.ApiService.DownloadGenePackageExecute(r)
}

/*
DownloadGenePackage Get a gene dataset by gene ID

Get a gene dataset including gene, transcript and protein fasta sequence, annotation and metadata by gene ID.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param geneIds NCBI gene ids
 @return GeneApiDownloadGenePackageRequest
*/
func (a *GeneApiService) DownloadGenePackage(ctx context.Context, geneIds []int32) GeneApiDownloadGenePackageRequest {
	return GeneApiDownloadGenePackageRequest{
		ApiService: a,
		ctx: ctx,
		geneIds: geneIds,
	}
}

// Execute executes the request
//  @return *os.File
func (a *GeneApiService) DownloadGenePackageExecute(r GeneApiDownloadGenePackageRequest) (**os.File, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  **os.File
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GeneApiService.DownloadGenePackage")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/gene/id/{gene_ids}/download"
	localVarPath = strings.Replace(localVarPath, "{"+"gene_ids"+"}", url.PathEscape(parameterToString(r.geneIds, "csv")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.includeAnnotationType != nil {
		t := *r.includeAnnotationType
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("include_annotation_type", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("include_annotation_type", parameterToString(t, "multi"))
		}
	}
	if r.fastaFilter != nil {
		t := *r.fastaFilter
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("fasta_filter", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("fasta_filter", parameterToString(t, "multi"))
		}
	}
	if r.auxReport != nil {
		t := *r.auxReport
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("aux_report", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("aux_report", parameterToString(t, "multi"))
		}
	}
	if r.tableFields != nil {
		t := *r.tableFields
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("table_fields", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("table_fields", parameterToString(t, "multi"))
		}
	}
	if r.tableReportType != nil {
		localVarQueryParams.Add("table_report_type", parameterToString(*r.tableReportType, ""))
	}
	if r.filename != nil {
		localVarQueryParams.Add("filename", parameterToString(*r.filename, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/zip"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuthHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v RpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type GeneApiDownloadGenePackagePostRequest struct {
	ctx context.Context
	ApiService *GeneApiService
	v2GeneDatasetRequest *V2GeneDatasetRequest
	filename *string
}

func (r GeneApiDownloadGenePackagePostRequest) V2GeneDatasetRequest(v2GeneDatasetRequest V2GeneDatasetRequest) GeneApiDownloadGenePackagePostRequest {
	r.v2GeneDatasetRequest = &v2GeneDatasetRequest
	return r
}

// Output file name.
func (r GeneApiDownloadGenePackagePostRequest) Filename(filename string) GeneApiDownloadGenePackagePostRequest {
	r.filename = &filename
	return r
}

func (r GeneApiDownloadGenePackagePostRequest) Execute() (**os.File, *http.Response, error) {
	return r.ApiService.DownloadGenePackagePostExecute(r)
}

/*
DownloadGenePackagePost Get a gene dataset by POST

Get a gene dataset including gene, transcript and protein fasta sequence, annotation and metadata by POST.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return GeneApiDownloadGenePackagePostRequest
*/
func (a *GeneApiService) DownloadGenePackagePost(ctx context.Context) GeneApiDownloadGenePackagePostRequest {
	return GeneApiDownloadGenePackagePostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return *os.File
func (a *GeneApiService) DownloadGenePackagePostExecute(r GeneApiDownloadGenePackagePostRequest) (**os.File, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  **os.File
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GeneApiService.DownloadGenePackagePost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/gene/download"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.v2GeneDatasetRequest == nil {
		return localVarReturnValue, nil, reportError("v2GeneDatasetRequest is required and must be specified")
	}

	if r.filename != nil {
		localVarQueryParams.Add("filename", parameterToString(*r.filename, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/zip"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.v2GeneDatasetRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuthHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v RpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type GeneApiGeneChromosomeSummaryRequest struct {
	ctx context.Context
	ApiService *GeneApiService
	taxon string
	annotationName string
}

func (r GeneApiGeneChromosomeSummaryRequest) Execute() (*V2GeneChromosomeSummaryReply, *http.Response, error) {
	return r.ApiService.GeneChromosomeSummaryExecute(r)
}

/*
GeneChromosomeSummary Get summary of chromosomes for a particular taxon's annotation

Get summary of chromosomes for a particular taxon's annotation.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param taxon
 @param annotationName
 @return GeneApiGeneChromosomeSummaryRequest
*/
func (a *GeneApiService) GeneChromosomeSummary(ctx context.Context, taxon string, annotationName string) GeneApiGeneChromosomeSummaryRequest {
	return GeneApiGeneChromosomeSummaryRequest{
		ApiService: a,
		ctx: ctx,
		taxon: taxon,
		annotationName: annotationName,
	}
}

// Execute executes the request
//  @return V2GeneChromosomeSummaryReply
func (a *GeneApiService) GeneChromosomeSummaryExecute(r GeneApiGeneChromosomeSummaryRequest) (*V2GeneChromosomeSummaryReply, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V2GeneChromosomeSummaryReply
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GeneApiService.GeneChromosomeSummary")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/gene/taxon/{taxon}/annotation/{annotation_name}/chromosome_summary"
	localVarPath = strings.Replace(localVarPath, "{"+"taxon"+"}", url.PathEscape(parameterToString(r.taxon, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"annotation_name"+"}", url.PathEscape(parameterToString(r.annotationName, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuthHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v RpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type GeneApiGeneCountsForTaxonRequest struct {
	ctx context.Context
	ApiService *GeneApiService
	taxon string
}

func (r GeneApiGeneCountsForTaxonRequest) Execute() (*V2GeneCountsByTaxonReply, *http.Response, error) {
	return r.ApiService.GeneCountsForTaxonExecute(r)
}

/*
GeneCountsForTaxon Get gene counts by taxonomic identifier

Get gene counts for a specified NCBI Taxonomy ID or name (common or scientific) in JSON format.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param taxon Taxon for provided gene symbol
 @return GeneApiGeneCountsForTaxonRequest
*/
func (a *GeneApiService) GeneCountsForTaxon(ctx context.Context, taxon string) GeneApiGeneCountsForTaxonRequest {
	return GeneApiGeneCountsForTaxonRequest{
		ApiService: a,
		ctx: ctx,
		taxon: taxon,
	}
}

// Execute executes the request
//  @return V2GeneCountsByTaxonReply
func (a *GeneApiService) GeneCountsForTaxonExecute(r GeneApiGeneCountsForTaxonRequest) (*V2GeneCountsByTaxonReply, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V2GeneCountsByTaxonReply
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GeneApiService.GeneCountsForTaxon")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/gene/taxon/{taxon}/counts"
	localVarPath = strings.Replace(localVarPath, "{"+"taxon"+"}", url.PathEscape(parameterToString(r.taxon, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuthHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v RpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type GeneApiGeneCountsForTaxonByPostRequest struct {
	ctx context.Context
	ApiService *GeneApiService
	v2GeneCountsByTaxonRequest *V2GeneCountsByTaxonRequest
}

func (r GeneApiGeneCountsForTaxonByPostRequest) V2GeneCountsByTaxonRequest(v2GeneCountsByTaxonRequest V2GeneCountsByTaxonRequest) GeneApiGeneCountsForTaxonByPostRequest {
	r.v2GeneCountsByTaxonRequest = &v2GeneCountsByTaxonRequest
	return r
}

func (r GeneApiGeneCountsForTaxonByPostRequest) Execute() (*V2GeneCountsByTaxonReply, *http.Response, error) {
	return r.ApiService.GeneCountsForTaxonByPostExecute(r)
}

/*
GeneCountsForTaxonByPost Get gene counts by taxonomic identifier

Get gene counts for a specified NCBI Taxonomy ID or name (common or scientific) in JSON format.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return GeneApiGeneCountsForTaxonByPostRequest
*/
func (a *GeneApiService) GeneCountsForTaxonByPost(ctx context.Context) GeneApiGeneCountsForTaxonByPostRequest {
	return GeneApiGeneCountsForTaxonByPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V2GeneCountsByTaxonReply
func (a *GeneApiService) GeneCountsForTaxonByPostExecute(r GeneApiGeneCountsForTaxonByPostRequest) (*V2GeneCountsByTaxonReply, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V2GeneCountsByTaxonReply
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GeneApiService.GeneCountsForTaxonByPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/gene/taxon/counts"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.v2GeneCountsByTaxonRequest == nil {
		return localVarReturnValue, nil, reportError("v2GeneCountsByTaxonRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.v2GeneCountsByTaxonRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuthHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v RpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type GeneApiGeneDownloadSummaryByIdRequest struct {
	ctx context.Context
	ApiService *GeneApiService
	geneIds []int32
	includeAnnotationType *[]V2Fasta
	returnedContent *V2GeneDatasetRequestContentType
	fastaFilter *[]string
	auxReport *[]V2GeneDatasetRequestGeneDatasetReportType
	tableFields *[]string
	tableReportType *V2GeneDatasetRequestGeneDatasetReportType
}

// Select additional types of annotation to include in the data package.  If unset, no annotation is provided.
func (r GeneApiGeneDownloadSummaryByIdRequest) IncludeAnnotationType(includeAnnotationType []V2Fasta) GeneApiGeneDownloadSummaryByIdRequest {
	r.includeAnnotationType = &includeAnnotationType
	return r
}

// Return either gene-ids, or entire gene metadata
func (r GeneApiGeneDownloadSummaryByIdRequest) ReturnedContent(returnedContent V2GeneDatasetRequestContentType) GeneApiGeneDownloadSummaryByIdRequest {
	r.returnedContent = &returnedContent
	return r
}

// Limit the FASTA sequences in the datasets package to these transcript and protein accessions
func (r GeneApiGeneDownloadSummaryByIdRequest) FastaFilter(fastaFilter []string) GeneApiGeneDownloadSummaryByIdRequest {
	r.fastaFilter = &fastaFilter
	return r
}

// list additional reports to include with download. Data report is included by default.
func (r GeneApiGeneDownloadSummaryByIdRequest) AuxReport(auxReport []V2GeneDatasetRequestGeneDatasetReportType) GeneApiGeneDownloadSummaryByIdRequest {
	r.auxReport = &auxReport
	return r
}

// Specify which fields to include in the tabular report
func (r GeneApiGeneDownloadSummaryByIdRequest) TableFields(tableFields []string) GeneApiGeneDownloadSummaryByIdRequest {
	r.tableFields = &tableFields
	return r
}

// Specify the report from which the table fields will be taken
func (r GeneApiGeneDownloadSummaryByIdRequest) TableReportType(tableReportType V2GeneDatasetRequestGeneDatasetReportType) GeneApiGeneDownloadSummaryByIdRequest {
	r.tableReportType = &tableReportType
	return r
}

func (r GeneApiGeneDownloadSummaryByIdRequest) Execute() (*V2DownloadSummary, *http.Response, error) {
	return r.ApiService.GeneDownloadSummaryByIdExecute(r)
}

/*
GeneDownloadSummaryById Get gene download summary by GeneID

Get a download summary by GeneID in a JSON output format.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param geneIds NCBI gene ids
 @return GeneApiGeneDownloadSummaryByIdRequest
*/
func (a *GeneApiService) GeneDownloadSummaryById(ctx context.Context, geneIds []int32) GeneApiGeneDownloadSummaryByIdRequest {
	return GeneApiGeneDownloadSummaryByIdRequest{
		ApiService: a,
		ctx: ctx,
		geneIds: geneIds,
	}
}

// Execute executes the request
//  @return V2DownloadSummary
func (a *GeneApiService) GeneDownloadSummaryByIdExecute(r GeneApiGeneDownloadSummaryByIdRequest) (*V2DownloadSummary, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V2DownloadSummary
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GeneApiService.GeneDownloadSummaryById")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/gene/id/{gene_ids}/download_summary"
	localVarPath = strings.Replace(localVarPath, "{"+"gene_ids"+"}", url.PathEscape(parameterToString(r.geneIds, "csv")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.includeAnnotationType != nil {
		t := *r.includeAnnotationType
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("include_annotation_type", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("include_annotation_type", parameterToString(t, "multi"))
		}
	}
	if r.returnedContent != nil {
		localVarQueryParams.Add("returned_content", parameterToString(*r.returnedContent, ""))
	}
	if r.fastaFilter != nil {
		t := *r.fastaFilter
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("fasta_filter", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("fasta_filter", parameterToString(t, "multi"))
		}
	}
	if r.auxReport != nil {
		t := *r.auxReport
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("aux_report", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("aux_report", parameterToString(t, "multi"))
		}
	}
	if r.tableFields != nil {
		t := *r.tableFields
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("table_fields", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("table_fields", parameterToString(t, "multi"))
		}
	}
	if r.tableReportType != nil {
		localVarQueryParams.Add("table_report_type", parameterToString(*r.tableReportType, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuthHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v RpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type GeneApiGeneDownloadSummaryByPostRequest struct {
	ctx context.Context
	ApiService *GeneApiService
	v2GeneDatasetRequest *V2GeneDatasetRequest
}

func (r GeneApiGeneDownloadSummaryByPostRequest) V2GeneDatasetRequest(v2GeneDatasetRequest V2GeneDatasetRequest) GeneApiGeneDownloadSummaryByPostRequest {
	r.v2GeneDatasetRequest = &v2GeneDatasetRequest
	return r
}

func (r GeneApiGeneDownloadSummaryByPostRequest) Execute() (*V2DownloadSummary, *http.Response, error) {
	return r.ApiService.GeneDownloadSummaryByPostExecute(r)
}

/*
GeneDownloadSummaryByPost Get gene download summary

Get gene download summary in a JSON output format.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return GeneApiGeneDownloadSummaryByPostRequest
*/
func (a *GeneApiService) GeneDownloadSummaryByPost(ctx context.Context) GeneApiGeneDownloadSummaryByPostRequest {
	return GeneApiGeneDownloadSummaryByPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V2DownloadSummary
func (a *GeneApiService) GeneDownloadSummaryByPostExecute(r GeneApiGeneDownloadSummaryByPostRequest) (*V2DownloadSummary, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V2DownloadSummary
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GeneApiService.GeneDownloadSummaryByPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/gene/download_summary"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.v2GeneDatasetRequest == nil {
		return localVarReturnValue, nil, reportError("v2GeneDatasetRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.v2GeneDatasetRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuthHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v RpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type GeneApiGeneLinksByIdRequest struct {
	ctx context.Context
	ApiService *GeneApiService
	geneIds []int32
}

func (r GeneApiGeneLinksByIdRequest) Execute() (*V2GeneLinksReply, *http.Response, error) {
	return r.ApiService.GeneLinksByIdExecute(r)
}

/*
GeneLinksById Get gene links by gene ID

Get links to available gene resources by gene ID.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param geneIds NCBI gene ids, limited to 1000 ids
 @return GeneApiGeneLinksByIdRequest
*/
func (a *GeneApiService) GeneLinksById(ctx context.Context, geneIds []int32) GeneApiGeneLinksByIdRequest {
	return GeneApiGeneLinksByIdRequest{
		ApiService: a,
		ctx: ctx,
		geneIds: geneIds,
	}
}

// Execute executes the request
//  @return V2GeneLinksReply
func (a *GeneApiService) GeneLinksByIdExecute(r GeneApiGeneLinksByIdRequest) (*V2GeneLinksReply, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V2GeneLinksReply
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GeneApiService.GeneLinksById")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/gene/id/{gene_ids}/links"
	localVarPath = strings.Replace(localVarPath, "{"+"gene_ids"+"}", url.PathEscape(parameterToString(r.geneIds, "csv")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuthHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v RpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type GeneApiGeneLinksByIdByPostRequest struct {
	ctx context.Context
	ApiService *GeneApiService
	v2GeneLinksRequest *V2GeneLinksRequest
}

func (r GeneApiGeneLinksByIdByPostRequest) V2GeneLinksRequest(v2GeneLinksRequest V2GeneLinksRequest) GeneApiGeneLinksByIdByPostRequest {
	r.v2GeneLinksRequest = &v2GeneLinksRequest
	return r
}

func (r GeneApiGeneLinksByIdByPostRequest) Execute() (*V2GeneLinksReply, *http.Response, error) {
	return r.ApiService.GeneLinksByIdByPostExecute(r)
}

/*
GeneLinksByIdByPost Get gene links by gene ID

Get links to available gene resources by gene ID.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return GeneApiGeneLinksByIdByPostRequest
*/
func (a *GeneApiService) GeneLinksByIdByPost(ctx context.Context) GeneApiGeneLinksByIdByPostRequest {
	return GeneApiGeneLinksByIdByPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V2GeneLinksReply
func (a *GeneApiService) GeneLinksByIdByPostExecute(r GeneApiGeneLinksByIdByPostRequest) (*V2GeneLinksReply, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V2GeneLinksReply
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GeneApiService.GeneLinksByIdByPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/gene/links"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.v2GeneLinksRequest == nil {
		return localVarReturnValue, nil, reportError("v2GeneLinksRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.v2GeneLinksRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuthHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v RpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type GeneApiGeneMetadataByAccessionRequest struct {
	ctx context.Context
	ApiService *GeneApiService
	accessions []string
	returnedContent *V2GeneDatasetReportsRequestContentType
	tableFields *[]string
	includeTabularHeader *V2IncludeTabularHeader
	pageSize *int32
	pageToken *string
}

// Return either gene-ids, or entire gene metadata
func (r GeneApiGeneMetadataByAccessionRequest) ReturnedContent(returnedContent V2GeneDatasetReportsRequestContentType) GeneApiGeneMetadataByAccessionRequest {
	r.returnedContent = &returnedContent
	return r
}

// Specify which fields to include in the tabular report
func (r GeneApiGeneMetadataByAccessionRequest) TableFields(tableFields []string) GeneApiGeneMetadataByAccessionRequest {
	r.tableFields = &tableFields
	return r
}

// Whether this request for tabular data should include the header row
func (r GeneApiGeneMetadataByAccessionRequest) IncludeTabularHeader(includeTabularHeader V2IncludeTabularHeader) GeneApiGeneMetadataByAccessionRequest {
	r.includeTabularHeader = &includeTabularHeader
	return r
}

// The maximum number of gene reports to return. Default is 20 and maximum is 1000. If the number of results exceeds the page size, &#x60;page_token&#x60; can be used to retrieve the remaining results.
func (r GeneApiGeneMetadataByAccessionRequest) PageSize(pageSize int32) GeneApiGeneMetadataByAccessionRequest {
	r.pageSize = &pageSize
	return r
}

// A page token is returned from an &#x60;AssemblyDatasetReportsRequest&#x60; call with more than &#x60;page_size&#x60; results. Use this token, along with the previous &#x60;AssemblyDatasetReportsRequest&#x60; parameters, to retrieve the next page of results. When &#x60;page_token&#x60; is empty, all results have been retrieved.
func (r GeneApiGeneMetadataByAccessionRequest) PageToken(pageToken string) GeneApiGeneMetadataByAccessionRequest {
	r.pageToken = &pageToken
	return r
}

func (r GeneApiGeneMetadataByAccessionRequest) Execute() (*V2reportsGeneDataReportPage, *http.Response, error) {
	return r.ApiService.GeneMetadataByAccessionExecute(r)
}

/*
GeneMetadataByAccession Get gene metadata by RefSeq Accession

Get a gene summary by RefSeq Accession. By default, in paged JSON format, but also available as tabular (accept: text/tab-separated-values) or json-lines (accept: application/x-ndjson)

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accessions RNA or Protein accessions.
 @return GeneApiGeneMetadataByAccessionRequest
*/
func (a *GeneApiService) GeneMetadataByAccession(ctx context.Context, accessions []string) GeneApiGeneMetadataByAccessionRequest {
	return GeneApiGeneMetadataByAccessionRequest{
		ApiService: a,
		ctx: ctx,
		accessions: accessions,
	}
}

// Execute executes the request
//  @return V2reportsGeneDataReportPage
func (a *GeneApiService) GeneMetadataByAccessionExecute(r GeneApiGeneMetadataByAccessionRequest) (*V2reportsGeneDataReportPage, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V2reportsGeneDataReportPage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GeneApiService.GeneMetadataByAccession")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/gene/accession/{accessions}"
	localVarPath = strings.Replace(localVarPath, "{"+"accessions"+"}", url.PathEscape(parameterToString(r.accessions, "csv")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.returnedContent != nil {
		localVarQueryParams.Add("returned_content", parameterToString(*r.returnedContent, ""))
	}
	if r.tableFields != nil {
		t := *r.tableFields
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("table_fields", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("table_fields", parameterToString(t, "multi"))
		}
	}
	if r.includeTabularHeader != nil {
		localVarQueryParams.Add("include_tabular_header", parameterToString(*r.includeTabularHeader, ""))
	}
	if r.pageSize != nil {
		localVarQueryParams.Add("page_size", parameterToString(*r.pageSize, ""))
	}
	if r.pageToken != nil {
		localVarQueryParams.Add("page_token", parameterToString(*r.pageToken, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "application/x-ndjson", "text/tab-separated-values"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuthHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v RpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type GeneApiGeneMetadataByPostRequest struct {
	ctx context.Context
	ApiService *GeneApiService
	v2GeneDatasetReportsRequest *V2GeneDatasetReportsRequest
}

func (r GeneApiGeneMetadataByPostRequest) V2GeneDatasetReportsRequest(v2GeneDatasetReportsRequest V2GeneDatasetReportsRequest) GeneApiGeneMetadataByPostRequest {
	r.v2GeneDatasetReportsRequest = &v2GeneDatasetReportsRequest
	return r
}

func (r GeneApiGeneMetadataByPostRequest) Execute() (*V2reportsGeneDataReportPage, *http.Response, error) {
	return r.ApiService.GeneMetadataByPostExecute(r)
}

/*
GeneMetadataByPost Get gene metadata as JSON

Get a gene summary. By default, in paged JSON format, but also available as tabular (accept: text/tab-separated-values) or json-lines (accept: application/x-ndjson)

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return GeneApiGeneMetadataByPostRequest
*/
func (a *GeneApiService) GeneMetadataByPost(ctx context.Context) GeneApiGeneMetadataByPostRequest {
	return GeneApiGeneMetadataByPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V2reportsGeneDataReportPage
func (a *GeneApiService) GeneMetadataByPostExecute(r GeneApiGeneMetadataByPostRequest) (*V2reportsGeneDataReportPage, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V2reportsGeneDataReportPage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GeneApiService.GeneMetadataByPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/gene"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.v2GeneDatasetReportsRequest == nil {
		return localVarReturnValue, nil, reportError("v2GeneDatasetReportsRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "application/x-ndjson", "text/tab-separated-values"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.v2GeneDatasetReportsRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuthHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v RpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type GeneApiGeneMetadataByTaxAndSymbolRequest struct {
	ctx context.Context
	ApiService *GeneApiService
	symbols []string
	taxon string
	returnedContent *V2GeneDatasetReportsRequestContentType
	tableFields *[]string
	includeTabularHeader *V2IncludeTabularHeader
	pageSize *int32
	pageToken *string
}

// Return either gene-ids, or entire gene metadata
func (r GeneApiGeneMetadataByTaxAndSymbolRequest) ReturnedContent(returnedContent V2GeneDatasetReportsRequestContentType) GeneApiGeneMetadataByTaxAndSymbolRequest {
	r.returnedContent = &returnedContent
	return r
}

// Specify which fields to include in the tabular report
func (r GeneApiGeneMetadataByTaxAndSymbolRequest) TableFields(tableFields []string) GeneApiGeneMetadataByTaxAndSymbolRequest {
	r.tableFields = &tableFields
	return r
}

// Whether this request for tabular data should include the header row
func (r GeneApiGeneMetadataByTaxAndSymbolRequest) IncludeTabularHeader(includeTabularHeader V2IncludeTabularHeader) GeneApiGeneMetadataByTaxAndSymbolRequest {
	r.includeTabularHeader = &includeTabularHeader
	return r
}

// The maximum number of gene reports to return. Default is 20 and maximum is 1000. If the number of results exceeds the page size, &#x60;page_token&#x60; can be used to retrieve the remaining results.
func (r GeneApiGeneMetadataByTaxAndSymbolRequest) PageSize(pageSize int32) GeneApiGeneMetadataByTaxAndSymbolRequest {
	r.pageSize = &pageSize
	return r
}

// A page token is returned from an &#x60;AssemblyDatasetReportsRequest&#x60; call with more than &#x60;page_size&#x60; results. Use this token, along with the previous &#x60;AssemblyDatasetReportsRequest&#x60; parameters, to retrieve the next page of results. When &#x60;page_token&#x60; is empty, all results have been retrieved.
func (r GeneApiGeneMetadataByTaxAndSymbolRequest) PageToken(pageToken string) GeneApiGeneMetadataByTaxAndSymbolRequest {
	r.pageToken = &pageToken
	return r
}

func (r GeneApiGeneMetadataByTaxAndSymbolRequest) Execute() (*V2reportsGeneDataReportPage, *http.Response, error) {
	return r.ApiService.GeneMetadataByTaxAndSymbolExecute(r)
}

/*
GeneMetadataByTaxAndSymbol Get gene metadata by gene symbol

Get a gene summary by by gene symbol. By default, in paged JSON format, but also available as tabular (accept: text/tab-separated-values) or json-lines (accept: application/x-ndjson)

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param symbols Gene symbol
 @param taxon Taxon for provided gene symbol
 @return GeneApiGeneMetadataByTaxAndSymbolRequest
*/
func (a *GeneApiService) GeneMetadataByTaxAndSymbol(ctx context.Context, symbols []string, taxon string) GeneApiGeneMetadataByTaxAndSymbolRequest {
	return GeneApiGeneMetadataByTaxAndSymbolRequest{
		ApiService: a,
		ctx: ctx,
		symbols: symbols,
		taxon: taxon,
	}
}

// Execute executes the request
//  @return V2reportsGeneDataReportPage
func (a *GeneApiService) GeneMetadataByTaxAndSymbolExecute(r GeneApiGeneMetadataByTaxAndSymbolRequest) (*V2reportsGeneDataReportPage, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V2reportsGeneDataReportPage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GeneApiService.GeneMetadataByTaxAndSymbol")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/gene/symbol/{symbols}/taxon/{taxon}"
	localVarPath = strings.Replace(localVarPath, "{"+"symbols"+"}", url.PathEscape(parameterToString(r.symbols, "csv")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"taxon"+"}", url.PathEscape(parameterToString(r.taxon, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.returnedContent != nil {
		localVarQueryParams.Add("returned_content", parameterToString(*r.returnedContent, ""))
	}
	if r.tableFields != nil {
		t := *r.tableFields
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("table_fields", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("table_fields", parameterToString(t, "multi"))
		}
	}
	if r.includeTabularHeader != nil {
		localVarQueryParams.Add("include_tabular_header", parameterToString(*r.includeTabularHeader, ""))
	}
	if r.pageSize != nil {
		localVarQueryParams.Add("page_size", parameterToString(*r.pageSize, ""))
	}
	if r.pageToken != nil {
		localVarQueryParams.Add("page_token", parameterToString(*r.pageToken, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "application/x-ndjson", "text/tab-separated-values"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuthHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v RpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type GeneApiGeneOrthologsByIdRequest struct {
	ctx context.Context
	ApiService *GeneApiService
	geneId int32
	returnedContent *V2OrthologRequestContentType
	taxonFilter *[]string
	pageSize *int32
	pageToken *string
}

// Return either gene-ids, or entire gene metadata
func (r GeneApiGeneOrthologsByIdRequest) ReturnedContent(returnedContent V2OrthologRequestContentType) GeneApiGeneOrthologsByIdRequest {
	r.returnedContent = &returnedContent
	return r
}

// Filter genes by taxa
func (r GeneApiGeneOrthologsByIdRequest) TaxonFilter(taxonFilter []string) GeneApiGeneOrthologsByIdRequest {
	r.taxonFilter = &taxonFilter
	return r
}

// The maximum number of gene reports to return. Default is 20 and maximum is 1000. If the number of results exceeds the page size, &#x60;page_token&#x60; can be used to retrieve the remaining results.
func (r GeneApiGeneOrthologsByIdRequest) PageSize(pageSize int32) GeneApiGeneOrthologsByIdRequest {
	r.pageSize = &pageSize
	return r
}

// A page token is returned from an &#x60;OrthologRequest&#x60; call with more than &#x60;page_size&#x60; results. Use this token, along with the previous &#x60;OrthologRequest&#x60; parameters, to retrieve the next page of results. When &#x60;page_token&#x60; is empty, all results have been retrieved.
func (r GeneApiGeneOrthologsByIdRequest) PageToken(pageToken string) GeneApiGeneOrthologsByIdRequest {
	r.pageToken = &pageToken
	return r
}

func (r GeneApiGeneOrthologsByIdRequest) Execute() (*V2reportsGeneDataReportPage, *http.Response, error) {
	return r.ApiService.GeneOrthologsByIdExecute(r)
}

/*
GeneOrthologsById Get gene orthologs by gene ID

Get a gene summary for an ortholog set by gene ID in a JSON output format.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param geneId
 @return GeneApiGeneOrthologsByIdRequest
*/
func (a *GeneApiService) GeneOrthologsById(ctx context.Context, geneId int32) GeneApiGeneOrthologsByIdRequest {
	return GeneApiGeneOrthologsByIdRequest{
		ApiService: a,
		ctx: ctx,
		geneId: geneId,
	}
}

// Execute executes the request
//  @return V2reportsGeneDataReportPage
func (a *GeneApiService) GeneOrthologsByIdExecute(r GeneApiGeneOrthologsByIdRequest) (*V2reportsGeneDataReportPage, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V2reportsGeneDataReportPage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GeneApiService.GeneOrthologsById")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/gene/id/{gene_id}/orthologs"
	localVarPath = strings.Replace(localVarPath, "{"+"gene_id"+"}", url.PathEscape(parameterToString(r.geneId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.returnedContent != nil {
		localVarQueryParams.Add("returned_content", parameterToString(*r.returnedContent, ""))
	}
	if r.taxonFilter != nil {
		t := *r.taxonFilter
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("taxon_filter", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("taxon_filter", parameterToString(t, "multi"))
		}
	}
	if r.pageSize != nil {
		localVarQueryParams.Add("page_size", parameterToString(*r.pageSize, ""))
	}
	if r.pageToken != nil {
		localVarQueryParams.Add("page_token", parameterToString(*r.pageToken, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuthHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v RpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type GeneApiGeneOrthologsByPostRequest struct {
	ctx context.Context
	ApiService *GeneApiService
	v2OrthologRequest *V2OrthologRequest
}

func (r GeneApiGeneOrthologsByPostRequest) V2OrthologRequest(v2OrthologRequest V2OrthologRequest) GeneApiGeneOrthologsByPostRequest {
	r.v2OrthologRequest = &v2OrthologRequest
	return r
}

func (r GeneApiGeneOrthologsByPostRequest) Execute() (*V2reportsGeneDataReportPage, *http.Response, error) {
	return r.ApiService.GeneOrthologsByPostExecute(r)
}

/*
GeneOrthologsByPost Get gene orthologs by gene ID

Get a gene summary for an ortholog set by gene ID in a JSON output format by POST

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return GeneApiGeneOrthologsByPostRequest
*/
func (a *GeneApiService) GeneOrthologsByPost(ctx context.Context) GeneApiGeneOrthologsByPostRequest {
	return GeneApiGeneOrthologsByPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V2reportsGeneDataReportPage
func (a *GeneApiService) GeneOrthologsByPostExecute(r GeneApiGeneOrthologsByPostRequest) (*V2reportsGeneDataReportPage, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V2reportsGeneDataReportPage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GeneApiService.GeneOrthologsByPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/gene/orthologs"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.v2OrthologRequest == nil {
		return localVarReturnValue, nil, reportError("v2OrthologRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.v2OrthologRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuthHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v RpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type GeneApiGeneReportsByIdRequest struct {
	ctx context.Context
	ApiService *GeneApiService
	geneIds []int32
	returnedContent *V2GeneDatasetReportsRequestContentType
	tableFields *[]string
	includeTabularHeader *V2IncludeTabularHeader
	pageSize *int32
	pageToken *string
}

// Return either gene-ids, or entire gene metadata
func (r GeneApiGeneReportsByIdRequest) ReturnedContent(returnedContent V2GeneDatasetReportsRequestContentType) GeneApiGeneReportsByIdRequest {
	r.returnedContent = &returnedContent
	return r
}

// Specify which fields to include in the tabular report
func (r GeneApiGeneReportsByIdRequest) TableFields(tableFields []string) GeneApiGeneReportsByIdRequest {
	r.tableFields = &tableFields
	return r
}

// Whether this request for tabular data should include the header row
func (r GeneApiGeneReportsByIdRequest) IncludeTabularHeader(includeTabularHeader V2IncludeTabularHeader) GeneApiGeneReportsByIdRequest {
	r.includeTabularHeader = &includeTabularHeader
	return r
}

// The maximum number of gene reports to return. Default is 20 and maximum is 1000. If the number of results exceeds the page size, &#x60;page_token&#x60; can be used to retrieve the remaining results.
func (r GeneApiGeneReportsByIdRequest) PageSize(pageSize int32) GeneApiGeneReportsByIdRequest {
	r.pageSize = &pageSize
	return r
}

// A page token is returned from an &#x60;AssemblyDatasetReportsRequest&#x60; call with more than &#x60;page_size&#x60; results. Use this token, along with the previous &#x60;AssemblyDatasetReportsRequest&#x60; parameters, to retrieve the next page of results. When &#x60;page_token&#x60; is empty, all results have been retrieved.
func (r GeneApiGeneReportsByIdRequest) PageToken(pageToken string) GeneApiGeneReportsByIdRequest {
	r.pageToken = &pageToken
	return r
}

func (r GeneApiGeneReportsByIdRequest) Execute() (*V2reportsGeneDataReportPage, *http.Response, error) {
	return r.ApiService.GeneReportsByIdExecute(r)
}

/*
GeneReportsById Get gene reports by GeneID

Get a gene summary by GeneID. By default, in paged JSON format, but also available as tabular (accept: text/tab-separated-values) or json-lines (accept: application/x-ndjson)

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param geneIds NCBI gene ids
 @return GeneApiGeneReportsByIdRequest
*/
func (a *GeneApiService) GeneReportsById(ctx context.Context, geneIds []int32) GeneApiGeneReportsByIdRequest {
	return GeneApiGeneReportsByIdRequest{
		ApiService: a,
		ctx: ctx,
		geneIds: geneIds,
	}
}

// Execute executes the request
//  @return V2reportsGeneDataReportPage
func (a *GeneApiService) GeneReportsByIdExecute(r GeneApiGeneReportsByIdRequest) (*V2reportsGeneDataReportPage, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V2reportsGeneDataReportPage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GeneApiService.GeneReportsById")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/gene/id/{gene_ids}"
	localVarPath = strings.Replace(localVarPath, "{"+"gene_ids"+"}", url.PathEscape(parameterToString(r.geneIds, "csv")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.returnedContent != nil {
		localVarQueryParams.Add("returned_content", parameterToString(*r.returnedContent, ""))
	}
	if r.tableFields != nil {
		t := *r.tableFields
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("table_fields", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("table_fields", parameterToString(t, "multi"))
		}
	}
	if r.includeTabularHeader != nil {
		localVarQueryParams.Add("include_tabular_header", parameterToString(*r.includeTabularHeader, ""))
	}
	if r.pageSize != nil {
		localVarQueryParams.Add("page_size", parameterToString(*r.pageSize, ""))
	}
	if r.pageToken != nil {
		localVarQueryParams.Add("page_token", parameterToString(*r.pageToken, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "application/x-ndjson", "text/tab-separated-values"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuthHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v RpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type GeneApiGeneReportsByTaxonRequest struct {
	ctx context.Context
	ApiService *GeneApiService
	taxon string
	returnedContent *V2GeneDatasetReportsRequestContentType
	tableFields *[]string
	includeTabularHeader *V2IncludeTabularHeader
	pageSize *int32
	pageToken *string
	query *string
	types *[]V2GeneType
}

// Return either gene-ids, or entire gene metadata
func (r GeneApiGeneReportsByTaxonRequest) ReturnedContent(returnedContent V2GeneDatasetReportsRequestContentType) GeneApiGeneReportsByTaxonRequest {
	r.returnedContent = &returnedContent
	return r
}

// Specify which fields to include in the tabular report
func (r GeneApiGeneReportsByTaxonRequest) TableFields(tableFields []string) GeneApiGeneReportsByTaxonRequest {
	r.tableFields = &tableFields
	return r
}

// Whether this request for tabular data should include the header row
func (r GeneApiGeneReportsByTaxonRequest) IncludeTabularHeader(includeTabularHeader V2IncludeTabularHeader) GeneApiGeneReportsByTaxonRequest {
	r.includeTabularHeader = &includeTabularHeader
	return r
}

// The maximum number of gene reports to return. Default is 20 and maximum is 1000. If the number of results exceeds the page size, &#x60;page_token&#x60; can be used to retrieve the remaining results.
func (r GeneApiGeneReportsByTaxonRequest) PageSize(pageSize int32) GeneApiGeneReportsByTaxonRequest {
	r.pageSize = &pageSize
	return r
}

// A page token is returned from an &#x60;AssemblyDatasetReportsRequest&#x60; call with more than &#x60;page_size&#x60; results. Use this token, along with the previous &#x60;AssemblyDatasetReportsRequest&#x60; parameters, to retrieve the next page of results. When &#x60;page_token&#x60; is empty, all results have been retrieved.
func (r GeneApiGeneReportsByTaxonRequest) PageToken(pageToken string) GeneApiGeneReportsByTaxonRequest {
	r.pageToken = &pageToken
	return r
}

// text search within gene symbol, aliases, name, and protein name
func (r GeneApiGeneReportsByTaxonRequest) Query(query string) GeneApiGeneReportsByTaxonRequest {
	r.query = &query
	return r
}

// Gene types to filter
func (r GeneApiGeneReportsByTaxonRequest) Types(types []V2GeneType) GeneApiGeneReportsByTaxonRequest {
	r.types = &types
	return r
}

func (r GeneApiGeneReportsByTaxonRequest) Execute() (*V2reportsGeneDataReportPage, *http.Response, error) {
	return r.ApiService.GeneReportsByTaxonExecute(r)
}

/*
GeneReportsByTaxon Get gene reports by taxonomic identifier

Get a gene summary for a specified NCBI Taxonomy ID or name (common or scientific). By default, in paged JSON format, but also available as tabular (accept: text/tab-separated-values) or json-lines (accept: application/x-ndjson)

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param taxon NCBI Taxonomy ID or name (common or scientific) that the genes are annotated at  end oneof }
 @return GeneApiGeneReportsByTaxonRequest
*/
func (a *GeneApiService) GeneReportsByTaxon(ctx context.Context, taxon string) GeneApiGeneReportsByTaxonRequest {
	return GeneApiGeneReportsByTaxonRequest{
		ApiService: a,
		ctx: ctx,
		taxon: taxon,
	}
}

// Execute executes the request
//  @return V2reportsGeneDataReportPage
func (a *GeneApiService) GeneReportsByTaxonExecute(r GeneApiGeneReportsByTaxonRequest) (*V2reportsGeneDataReportPage, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V2reportsGeneDataReportPage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GeneApiService.GeneReportsByTaxon")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/gene/taxon/{taxon}"
	localVarPath = strings.Replace(localVarPath, "{"+"taxon"+"}", url.PathEscape(parameterToString(r.taxon, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.returnedContent != nil {
		localVarQueryParams.Add("returned_content", parameterToString(*r.returnedContent, ""))
	}
	if r.tableFields != nil {
		t := *r.tableFields
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("table_fields", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("table_fields", parameterToString(t, "multi"))
		}
	}
	if r.includeTabularHeader != nil {
		localVarQueryParams.Add("include_tabular_header", parameterToString(*r.includeTabularHeader, ""))
	}
	if r.pageSize != nil {
		localVarQueryParams.Add("page_size", parameterToString(*r.pageSize, ""))
	}
	if r.pageToken != nil {
		localVarQueryParams.Add("page_token", parameterToString(*r.pageToken, ""))
	}
	if r.query != nil {
		localVarQueryParams.Add("query", parameterToString(*r.query, ""))
	}
	if r.types != nil {
		t := *r.types
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("types", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("types", parameterToString(t, "multi"))
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "application/x-ndjson", "text/tab-separated-values"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuthHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v RpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
