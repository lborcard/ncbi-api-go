//go:build go1.22

// Package openapi provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.4.0 DO NOT EDIT.
package openapi

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"
	"time"

	"github.com/oapi-codegen/runtime"
)

const (
	ApiKeyAuthHeaderScopes = "ApiKeyAuthHeader.Scopes"
)

// Defines values for V2AnnotationForAssemblyType.
const (
	V2AnnotationForAssemblyTypeCDSFASTA       V2AnnotationForAssemblyType = "CDS_FASTA"
	V2AnnotationForAssemblyTypeGENOMEFASTA    V2AnnotationForAssemblyType = "GENOME_FASTA"
	V2AnnotationForAssemblyTypeGENOMEGBFF     V2AnnotationForAssemblyType = "GENOME_GBFF"
	V2AnnotationForAssemblyTypeGENOMEGFF      V2AnnotationForAssemblyType = "GENOME_GFF"
	V2AnnotationForAssemblyTypeGENOMEGTF      V2AnnotationForAssemblyType = "GENOME_GTF"
	V2AnnotationForAssemblyTypePROTFASTA      V2AnnotationForAssemblyType = "PROT_FASTA"
	V2AnnotationForAssemblyTypeRNAFASTA       V2AnnotationForAssemblyType = "RNA_FASTA"
	V2AnnotationForAssemblyTypeSEQUENCEREPORT V2AnnotationForAssemblyType = "SEQUENCE_REPORT"
)

// Defines values for V2AnnotationForOrganelleType.
const (
	V2AnnotationForOrganelleTypeCDSFASTA     V2AnnotationForOrganelleType = "CDS_FASTA"
	V2AnnotationForOrganelleTypeGENOMEFASTA  V2AnnotationForOrganelleType = "GENOME_FASTA"
	V2AnnotationForOrganelleTypePROTEINFASTA V2AnnotationForOrganelleType = "PROTEIN_FASTA"
)

// Defines values for V2AssemblyDatasetDescriptorsFilterAssemblySource.
const (
	All     V2AssemblyDatasetDescriptorsFilterAssemblySource = "all"
	Genbank V2AssemblyDatasetDescriptorsFilterAssemblySource = "genbank"
	Refseq  V2AssemblyDatasetDescriptorsFilterAssemblySource = "refseq"
)

// Defines values for V2AssemblyDatasetDescriptorsFilterAssemblyVersion.
const (
	V2AssemblyDatasetDescriptorsFilterAssemblyVersionAllAssemblies V2AssemblyDatasetDescriptorsFilterAssemblyVersion = "all_assemblies"
	V2AssemblyDatasetDescriptorsFilterAssemblyVersionCurrent       V2AssemblyDatasetDescriptorsFilterAssemblyVersion = "current"
)

// Defines values for V2AssemblyDatasetDescriptorsFilterMetagenomeDerivedFilter.
const (
	METAGENOMEDERIVEDUNSET   V2AssemblyDatasetDescriptorsFilterMetagenomeDerivedFilter = "METAGENOME_DERIVED_UNSET"
	MetagenomeDerivedExclude V2AssemblyDatasetDescriptorsFilterMetagenomeDerivedFilter = "metagenome_derived_exclude"
	MetagenomeDerivedOnly    V2AssemblyDatasetDescriptorsFilterMetagenomeDerivedFilter = "metagenome_derived_only"
)

// Defines values for V2AssemblyDatasetDescriptorsFilterTypeMaterialCategory.
const (
	V2AssemblyDatasetDescriptorsFilterTypeMaterialCategoryNONE                V2AssemblyDatasetDescriptorsFilterTypeMaterialCategory = "NONE"
	V2AssemblyDatasetDescriptorsFilterTypeMaterialCategoryPATHOVARTYPE        V2AssemblyDatasetDescriptorsFilterTypeMaterialCategory = "PATHOVAR_TYPE"
	V2AssemblyDatasetDescriptorsFilterTypeMaterialCategoryTYPEMATERIAL        V2AssemblyDatasetDescriptorsFilterTypeMaterialCategory = "TYPE_MATERIAL"
	V2AssemblyDatasetDescriptorsFilterTypeMaterialCategoryTYPEMATERIALCLADE   V2AssemblyDatasetDescriptorsFilterTypeMaterialCategory = "TYPE_MATERIAL_CLADE"
	V2AssemblyDatasetDescriptorsFilterTypeMaterialCategoryTYPEMATERIALNEOTYPE V2AssemblyDatasetDescriptorsFilterTypeMaterialCategory = "TYPE_MATERIAL_NEOTYPE"
	V2AssemblyDatasetDescriptorsFilterTypeMaterialCategoryTYPEMATERIALREFTYPE V2AssemblyDatasetDescriptorsFilterTypeMaterialCategory = "TYPE_MATERIAL_REFTYPE"
	V2AssemblyDatasetDescriptorsFilterTypeMaterialCategoryTYPEMATERIALSYN     V2AssemblyDatasetDescriptorsFilterTypeMaterialCategory = "TYPE_MATERIAL_SYN"
)

// Defines values for V2AssemblyDatasetReportsRequestContentType.
const (
	V2AssemblyDatasetReportsRequestContentTypeASSMACC   V2AssemblyDatasetReportsRequestContentType = "ASSM_ACC"
	V2AssemblyDatasetReportsRequestContentTypeCOMPLETE  V2AssemblyDatasetReportsRequestContentType = "COMPLETE"
	V2AssemblyDatasetReportsRequestContentTypePAIREDACC V2AssemblyDatasetReportsRequestContentType = "PAIRED_ACC"
)

// Defines values for V2AssemblyDatasetRequestResolution.
const (
	DATAREPORTONLY V2AssemblyDatasetRequestResolution = "DATA_REPORT_ONLY"
	FULLYHYDRATED  V2AssemblyDatasetRequestResolution = "FULLY_HYDRATED"
)

// Defines values for V2AssemblyLinksReplyAssemblyLinkType.
const (
	V2AssemblyLinksReplyAssemblyLinkTypeASSEMBLYNUCCOREGENBANK V2AssemblyLinksReplyAssemblyLinkType = "ASSEMBLY_NUCCORE_GENBANK"
	V2AssemblyLinksReplyAssemblyLinkTypeASSEMBLYNUCCOREREFSEQ  V2AssemblyLinksReplyAssemblyLinkType = "ASSEMBLY_NUCCORE_REFSEQ"
	V2AssemblyLinksReplyAssemblyLinkTypeASSEMBLYPUBMED         V2AssemblyLinksReplyAssemblyLinkType = "ASSEMBLY_PUBMED"
	V2AssemblyLinksReplyAssemblyLinkTypeBLASTLINK              V2AssemblyLinksReplyAssemblyLinkType = "BLAST_LINK"
	V2AssemblyLinksReplyAssemblyLinkTypeFTPLINK                V2AssemblyLinksReplyAssemblyLinkType = "FTP_LINK"
	V2AssemblyLinksReplyAssemblyLinkTypeGDVLINK                V2AssemblyLinksReplyAssemblyLinkType = "GDV_LINK"
)

// Defines values for V2Fasta.
const (
	FASTA3PUTR       V2Fasta = "FASTA_3P_UTR"
	FASTA5PUTR       V2Fasta = "FASTA_5P_UTR"
	FASTACDS         V2Fasta = "FASTA_CDS"
	FASTAGENE        V2Fasta = "FASTA_GENE"
	FASTAGENEFLANK   V2Fasta = "FASTA_GENE_FLANK"
	FASTAPROTEIN     V2Fasta = "FASTA_PROTEIN"
	FASTARNA         V2Fasta = "FASTA_RNA"
	FASTAUNSPECIFIED V2Fasta = "FASTA_UNSPECIFIED"
)

// Defines values for V2GeneDatasetReportsRequestContentType.
const (
	V2GeneDatasetReportsRequestContentTypeCOMPLETE   V2GeneDatasetReportsRequestContentType = "COMPLETE"
	V2GeneDatasetReportsRequestContentTypeCOUNTSONLY V2GeneDatasetReportsRequestContentType = "COUNTS_ONLY"
	V2GeneDatasetReportsRequestContentTypeIDSONLY    V2GeneDatasetReportsRequestContentType = "IDS_ONLY"
	V2GeneDatasetReportsRequestContentTypePRODUCT    V2GeneDatasetReportsRequestContentType = "PRODUCT"
)

// Defines values for V2GeneDatasetRequestContentType.
const (
	V2GeneDatasetRequestContentTypeCOMPLETE V2GeneDatasetRequestContentType = "COMPLETE"
	V2GeneDatasetRequestContentTypeIDSONLY  V2GeneDatasetRequestContentType = "IDS_ONLY"
)

// Defines values for V2GeneDatasetRequestGeneDatasetReportType.
const (
	V2GeneDatasetRequestGeneDatasetReportTypeDATASETREPORT V2GeneDatasetRequestGeneDatasetReportType = "DATASET_REPORT"
	V2GeneDatasetRequestGeneDatasetReportTypePRODUCTREPORT V2GeneDatasetRequestGeneDatasetReportType = "PRODUCT_REPORT"
)

// Defines values for V2GeneLinksReplyGeneLinkType.
const (
	V2GeneLinksReplyGeneLinkTypeGDVLINK      V2GeneLinksReplyGeneLinkType = "GDV_LINK"
	V2GeneLinksReplyGeneLinkTypeGENELINK     V2GeneLinksReplyGeneLinkType = "GENE_LINK"
	V2GeneLinksReplyGeneLinkTypeORTHOLOGLINK V2GeneLinksReplyGeneLinkType = "ORTHOLOG_LINK"
)

// Defines values for V2GeneType.
const (
	V2GeneTypeBIOLOGICALREGION V2GeneType = "BIOLOGICAL_REGION"
	V2GeneTypeMiscRNA          V2GeneType = "miscRNA"
	V2GeneTypeNcRNA            V2GeneType = "ncRNA"
	V2GeneTypeOTHER            V2GeneType = "OTHER"
	V2GeneTypePROTEINCODING    V2GeneType = "PROTEIN_CODING"
	V2GeneTypePSEUDO           V2GeneType = "PSEUDO"
	V2GeneTypeRRNA             V2GeneType = "rRNA"
	V2GeneTypeScRNA            V2GeneType = "scRNA"
	V2GeneTypeSnRNA            V2GeneType = "snRNA"
	V2GeneTypeSnoRNA           V2GeneType = "snoRNA"
	V2GeneTypeTRANSPOSON       V2GeneType = "TRANSPOSON"
	V2GeneTypeTRNA             V2GeneType = "tRNA"
	V2GeneTypeUNKNOWN          V2GeneType = "UNKNOWN"
)

// Defines values for V2GenomeAnnotationRequestAnnotationType.
const (
	GENOMEFASTA V2GenomeAnnotationRequestAnnotationType = "GENOME_FASTA"
	PROTFASTA   V2GenomeAnnotationRequestAnnotationType = "PROT_FASTA"
	RNAFASTA    V2GenomeAnnotationRequestAnnotationType = "RNA_FASTA"
)

// Defines values for V2GenomeAnnotationRequestGenomeAnnotationTableFormat.
const (
	V2GenomeAnnotationRequestGenomeAnnotationTableFormatNOTABLE V2GenomeAnnotationRequestGenomeAnnotationTableFormat = "NO_TABLE"
	V2GenomeAnnotationRequestGenomeAnnotationTableFormatPRODUCT V2GenomeAnnotationRequestGenomeAnnotationTableFormat = "PRODUCT"
	V2GenomeAnnotationRequestGenomeAnnotationTableFormatSUMMARY V2GenomeAnnotationRequestGenomeAnnotationTableFormat = "SUMMARY"
)

// Defines values for V2ImageSize.
const (
	V2ImageSizeMEDIUM      V2ImageSize = "MEDIUM"
	V2ImageSizeSMALL       V2ImageSize = "SMALL"
	V2ImageSizeUNSPECIFIED V2ImageSize = "UNSPECIFIED"
)

// Defines values for V2IncludeTabularHeader.
const (
	INCLUDETABULARHEADERALWAYS        V2IncludeTabularHeader = "INCLUDE_TABULAR_HEADER_ALWAYS"
	INCLUDETABULARHEADERFIRSTPAGEONLY V2IncludeTabularHeader = "INCLUDE_TABULAR_HEADER_FIRST_PAGE_ONLY"
	INCLUDETABULARHEADERNEVER         V2IncludeTabularHeader = "INCLUDE_TABULAR_HEADER_NEVER"
)

// Defines values for V2OrganelleMetadataRequestContentType.
const (
	V2OrganelleMetadataRequestContentTypeASSMACC  V2OrganelleMetadataRequestContentType = "ASSM_ACC"
	V2OrganelleMetadataRequestContentTypeCOMPLETE V2OrganelleMetadataRequestContentType = "COMPLETE"
)

// Defines values for V2OrganelleMetadataRequestOrganelleTableFormat.
const (
	V2OrganelleMetadataRequestOrganelleTableFormatORGANELLETABLEFORMATNOTABLE V2OrganelleMetadataRequestOrganelleTableFormat = "ORGANELLE_TABLE_FORMAT_NO_TABLE"
	V2OrganelleMetadataRequestOrganelleTableFormatSUMMARY                     V2OrganelleMetadataRequestOrganelleTableFormat = "SUMMARY"
)

// Defines values for V2OrganismQueryRequestTaxRankFilter.
const (
	HigherTaxon V2OrganismQueryRequestTaxRankFilter = "higher_taxon"
	Species     V2OrganismQueryRequestTaxRankFilter = "species"
)

// Defines values for V2OrganismQueryRequestTaxonResourceFilter.
const (
	TAXONRESOURCEFILTERALL       V2OrganismQueryRequestTaxonResourceFilter = "TAXON_RESOURCE_FILTER_ALL"
	TAXONRESOURCEFILTERGENE      V2OrganismQueryRequestTaxonResourceFilter = "TAXON_RESOURCE_FILTER_GENE"
	TAXONRESOURCEFILTERGENOME    V2OrganismQueryRequestTaxonResourceFilter = "TAXON_RESOURCE_FILTER_GENOME"
	TAXONRESOURCEFILTERORGANELLE V2OrganismQueryRequestTaxonResourceFilter = "TAXON_RESOURCE_FILTER_ORGANELLE"
)

// Defines values for V2OrthologRequestContentType.
const (
	V2OrthologRequestContentTypeCOMPLETE V2OrthologRequestContentType = "COMPLETE"
	V2OrthologRequestContentTypeIDSONLY  V2OrthologRequestContentType = "IDS_ONLY"
)

// Defines values for V2SortDirection.
const (
	SORTDIRECTIONASCENDING   V2SortDirection = "SORT_DIRECTION_ASCENDING"
	SORTDIRECTIONDESCENDING  V2SortDirection = "SORT_DIRECTION_DESCENDING"
	SORTDIRECTIONUNSPECIFIED V2SortDirection = "SORT_DIRECTION_UNSPECIFIED"
)

// Defines values for V2TableFormat.
const (
	Csv   V2TableFormat = "csv"
	Jsonl V2TableFormat = "jsonl"
	Tsv   V2TableFormat = "tsv"
)

// Defines values for V2TaxonomyDatasetRequestTaxonomyReportType.
const (
	NAMESREPORT     V2TaxonomyDatasetRequestTaxonomyReportType = "NAMES_REPORT"
	TAXONOMYSUMMARY V2TaxonomyDatasetRequestTaxonomyReportType = "TAXONOMY_SUMMARY"
)

// Defines values for V2TaxonomyFilteredSubtreeResponseEdgeChildStatus.
const (
	V2TaxonomyFilteredSubtreeResponseEdgeChildStatusHASMORECHILDREN   V2TaxonomyFilteredSubtreeResponseEdgeChildStatus = "HAS_MORE_CHILDREN"
	V2TaxonomyFilteredSubtreeResponseEdgeChildStatusNOVISIBLECHILDREN V2TaxonomyFilteredSubtreeResponseEdgeChildStatus = "NO_VISIBLE_CHILDREN"
	V2TaxonomyFilteredSubtreeResponseEdgeChildStatusUNSPECIFIED       V2TaxonomyFilteredSubtreeResponseEdgeChildStatus = "UNSPECIFIED"
)

// Defines values for V2TaxonomyMetadataRequestContentType.
const (
	V2TaxonomyMetadataRequestContentTypeCOMPLETE V2TaxonomyMetadataRequestContentType = "COMPLETE"
	V2TaxonomyMetadataRequestContentTypeMETADATA V2TaxonomyMetadataRequestContentType = "METADATA"
	V2TaxonomyMetadataRequestContentTypeTAXIDS   V2TaxonomyMetadataRequestContentType = "TAXIDS"
)

// Defines values for V2TaxonomyMetadataRequestTableFormat.
const (
	SUMMARY V2TaxonomyMetadataRequestTableFormat = "SUMMARY"
)

// Defines values for V2ViralSequenceType.
const (
	V2ViralSequenceTypeBIOSAMPLE V2ViralSequenceType = "BIOSAMPLE"
	V2ViralSequenceTypeCDS       V2ViralSequenceType = "CDS"
	V2ViralSequenceTypeGENOME    V2ViralSequenceType = "GENOME"
	V2ViralSequenceTypeNONE      V2ViralSequenceType = "NONE"
	V2ViralSequenceTypePROTEIN   V2ViralSequenceType = "PROTEIN"
)

// Defines values for V2VirusDataReportRequestContentType.
const (
	V2VirusDataReportRequestContentTypeACCESSIONSONLY V2VirusDataReportRequestContentType = "ACCESSIONS_ONLY"
	V2VirusDataReportRequestContentTypeCOMPLETE       V2VirusDataReportRequestContentType = "COMPLETE"
)

// Defines values for V2VirusDatasetReportType.
const (
	V2VirusDatasetReportTypeANNOTATION      V2VirusDatasetReportType = "ANNOTATION"
	V2VirusDatasetReportTypeBIOSAMPLEREPORT V2VirusDatasetReportType = "BIOSAMPLE_REPORT"
	V2VirusDatasetReportTypeDATASETREPORT   V2VirusDatasetReportType = "DATASET_REPORT"
)

// Defines values for V2VirusTableField.
const (
	Bioproject          V2VirusTableField = "bioproject"
	Biosample           V2VirusTableField = "biosample"
	CdsSpan             V2VirusTableField = "cds_span"
	CollectionDate      V2VirusTableField = "collection_date"
	Family              V2VirusTableField = "family"
	Genus               V2VirusTableField = "genus"
	GeoLocation         V2VirusTableField = "geo_location"
	HostName            V2VirusTableField = "host_name"
	HostTaxId           V2VirusTableField = "host_tax_id"
	IsolateName         V2VirusTableField = "isolate_name"
	NucCompleteness     V2VirusTableField = "nuc_completeness"
	NucleotideAccession V2VirusTableField = "nucleotide_accession"
	NucleotideLength    V2VirusTableField = "nucleotide_length"
	PolyproteinName     V2VirusTableField = "polyprotein_name"
	ProteinAccession    V2VirusTableField = "protein_accession"
	ProteinName         V2VirusTableField = "protein_name"
	ProteinSynonym      V2VirusTableField = "protein_synonym"
	SequenceType        V2VirusTableField = "sequence_type"
	SpeciesName         V2VirusTableField = "species_name"
	SpeciesTaxId        V2VirusTableField = "species_tax_id"
	Unspecified         V2VirusTableField = "unspecified"
	UsState             V2VirusTableField = "us_state"
)

// Defines values for V2reportsANITypeCategory.
const (
	ANICATEGORYUNKNOWN V2reportsANITypeCategory = "ANI_CATEGORY_UNKNOWN"
	CategoryNa         V2reportsANITypeCategory = "category_na"
	Claderef           V2reportsANITypeCategory = "claderef"
	Neotype            V2reportsANITypeCategory = "neotype"
	NoType             V2reportsANITypeCategory = "no_type"
	Pathovar           V2reportsANITypeCategory = "pathovar"
	Reftype            V2reportsANITypeCategory = "reftype"
	SuspectedType      V2reportsANITypeCategory = "suspected_type"
	Syntype            V2reportsANITypeCategory = "syntype"
	Type               V2reportsANITypeCategory = "type"
)

// Defines values for V2reportsAssemblyLevel.
const (
	Chromosome     V2reportsAssemblyLevel = "chromosome"
	CompleteGenome V2reportsAssemblyLevel = "complete_genome"
	Contig         V2reportsAssemblyLevel = "contig"
	Scaffold       V2reportsAssemblyLevel = "scaffold"
)

// Defines values for V2reportsAssemblyStatus.
const (
	V2reportsAssemblyStatusASSEMBLYSTATUSUNKNOWN V2reportsAssemblyStatus = "ASSEMBLY_STATUS_UNKNOWN"
	V2reportsAssemblyStatusCurrent               V2reportsAssemblyStatus = "current"
	V2reportsAssemblyStatusPrevious              V2reportsAssemblyStatus = "previous"
	V2reportsAssemblyStatusRetired               V2reportsAssemblyStatus = "retired"
	V2reportsAssemblyStatusSuppressed            V2reportsAssemblyStatus = "suppressed"
)

// Defines values for V2reportsAverageNucleotideIdentityMatchStatus.
const (
	ApprovedMismatch           V2reportsAverageNucleotideIdentityMatchStatus = "approved_mismatch"
	BESTMATCHSTATUSUNKNOWN     V2reportsAverageNucleotideIdentityMatchStatus = "BEST_MATCH_STATUS_UNKNOWN"
	BelowThresholdLineageMatch V2reportsAverageNucleotideIdentityMatchStatus = "below_threshold_lineage_match"
	BelowThresholdMatch        V2reportsAverageNucleotideIdentityMatchStatus = "below_threshold_match"
	BelowThresholdMismatch     V2reportsAverageNucleotideIdentityMatchStatus = "below_threshold_mismatch"
	BestMatchStatus            V2reportsAverageNucleotideIdentityMatchStatus = "best_match_status"
	DerivedSpeciesMatch        V2reportsAverageNucleotideIdentityMatchStatus = "derived_species_match"
	GenusMatch                 V2reportsAverageNucleotideIdentityMatchStatus = "genus_match"
	LineageMatch               V2reportsAverageNucleotideIdentityMatchStatus = "lineage_match"
	LowCoverage                V2reportsAverageNucleotideIdentityMatchStatus = "low_coverage"
	Mismatch                   V2reportsAverageNucleotideIdentityMatchStatus = "mismatch"
	SpeciesMatch               V2reportsAverageNucleotideIdentityMatchStatus = "species_match"
	StatusNa                   V2reportsAverageNucleotideIdentityMatchStatus = "status_na"
	SubspeciesMatch            V2reportsAverageNucleotideIdentityMatchStatus = "subspecies_match"
	SynonymMatch               V2reportsAverageNucleotideIdentityMatchStatus = "synonym_match"
)

// Defines values for V2reportsAverageNucleotideIdentityTaxonomyCheckStatus.
const (
	Failed                     V2reportsAverageNucleotideIdentityTaxonomyCheckStatus = "Failed"
	Inconclusive               V2reportsAverageNucleotideIdentityTaxonomyCheckStatus = "Inconclusive"
	OK                         V2reportsAverageNucleotideIdentityTaxonomyCheckStatus = "OK"
	TAXONOMYCHECKSTATUSUNKNOWN V2reportsAverageNucleotideIdentityTaxonomyCheckStatus = "TAXONOMY_CHECK_STATUS_UNKNOWN"
)

// Defines values for V2reportsCollectionType.
const (
	CollectionCultureCollection V2reportsCollectionType = "collection_culture_collection"
	NoCollectionType            V2reportsCollectionType = "no_collection_type"
	SpecimenVoucher             V2reportsCollectionType = "specimen_voucher"
)

// Defines values for V2reportsContentType.
const (
	V2reportsContentTypeASSMACC   V2reportsContentType = "ASSM_ACC"
	V2reportsContentTypeCOMPLETE  V2reportsContentType = "COMPLETE"
	V2reportsContentTypePAIREDACC V2reportsContentType = "PAIRED_ACC"
)

// Defines values for V2reportsCountType.
const (
	COUNTTYPEASSEMBLY         V2reportsCountType = "COUNT_TYPE_ASSEMBLY"
	COUNTTYPEBIOLOGICALREGION V2reportsCountType = "COUNT_TYPE_BIOLOGICAL_REGION"
	COUNTTYPEGENE             V2reportsCountType = "COUNT_TYPE_GENE"
	COUNTTYPEMiscRNA          V2reportsCountType = "COUNT_TYPE_miscRNA"
	COUNTTYPENcRNA            V2reportsCountType = "COUNT_TYPE_ncRNA"
	COUNTTYPEORGANELLE        V2reportsCountType = "COUNT_TYPE_ORGANELLE"
	COUNTTYPEOTHER            V2reportsCountType = "COUNT_TYPE_OTHER"
	COUNTTYPEPROTEINCODING    V2reportsCountType = "COUNT_TYPE_PROTEIN_CODING"
	COUNTTYPEPSEUDO           V2reportsCountType = "COUNT_TYPE_PSEUDO"
	COUNTTYPERRNA             V2reportsCountType = "COUNT_TYPE_rRNA"
	COUNTTYPEScRNA            V2reportsCountType = "COUNT_TYPE_scRNA"
	COUNTTYPESnRNA            V2reportsCountType = "COUNT_TYPE_snRNA"
	COUNTTYPESnoRNA           V2reportsCountType = "COUNT_TYPE_snoRNA"
	COUNTTYPETRANSPOSON       V2reportsCountType = "COUNT_TYPE_TRANSPOSON"
	COUNTTYPETRNA             V2reportsCountType = "COUNT_TYPE_tRNA"
	COUNTTYPEUNSPECIFIED      V2reportsCountType = "COUNT_TYPE_UNSPECIFIED"
)

// Defines values for V2reportsErrorAssemblyErrorCode.
const (
	INVALIDBIOPROJECTIDS         V2reportsErrorAssemblyErrorCode = "INVALID_BIOPROJECT_IDS"
	INVALIDBIOSAMPLEIDS          V2reportsErrorAssemblyErrorCode = "INVALID_BIOSAMPLE_IDS"
	INVALIDTAXON                 V2reportsErrorAssemblyErrorCode = "INVALID_TAXON"
	INVALIDWGSACCESSIONS         V2reportsErrorAssemblyErrorCode = "INVALID_WGS_ACCESSIONS"
	MISSINGSEARCHFIELD           V2reportsErrorAssemblyErrorCode = "MISSING_SEARCH_FIELD"
	NOASSEMBLIESFORASSEMBLYNAMES V2reportsErrorAssemblyErrorCode = "NO_ASSEMBLIES_FOR_ASSEMBLY_NAMES"
	NOASSEMBLIESFORBIOPROJECTS   V2reportsErrorAssemblyErrorCode = "NO_ASSEMBLIES_FOR_BIOPROJECTS"
	NOASSEMBLIESFORBIOSAMPLEIDS  V2reportsErrorAssemblyErrorCode = "NO_ASSEMBLIES_FOR_BIOSAMPLE_IDS"
	NOASSEMBLIESFORWGSACCESSIONS V2reportsErrorAssemblyErrorCode = "NO_ASSEMBLIES_FOR_WGS_ACCESSIONS"
	UNKNOWNASSEMBLYERRORCODE     V2reportsErrorAssemblyErrorCode = "UNKNOWN_ASSEMBLY_ERROR_CODE"
)

// Defines values for V2reportsErrorGeneErrorCode.
const (
	INCOMPLETELOOKUPSYMBOL   V2reportsErrorGeneErrorCode = "INCOMPLETE_LOOKUP_SYMBOL"
	INVALIDTAXONGENEARGUMENT V2reportsErrorGeneErrorCode = "INVALID_TAXON_GENE_ARGUMENT"
	UNKNOWNGENEERRORCODE     V2reportsErrorGeneErrorCode = "UNKNOWN_GENE_ERROR_CODE"
)

// Defines values for V2reportsErrorOrganelleErrorCode.
const (
	INVALIDORGANELLETAXON     V2reportsErrorOrganelleErrorCode = "INVALID_ORGANELLE_TAXON"
	NOORGANELLESFORACCESSION  V2reportsErrorOrganelleErrorCode = "NO_ORGANELLES_FOR_ACCESSION"
	UNKNOWNORGANELLEERRORCODE V2reportsErrorOrganelleErrorCode = "UNKNOWN_ORGANELLE_ERROR_CODE"
)

// Defines values for V2reportsErrorTaxonomyErrorCode.
const (
	INVALIDTAXONOMYTAXON     V2reportsErrorTaxonomyErrorCode = "INVALID_TAXONOMY_TAXON"
	UNKNOWNTAXONOMYERRORCODE V2reportsErrorTaxonomyErrorCode = "UNKNOWN_TAXONOMY_ERROR_CODE"
)

// Defines values for V2reportsErrorVirusErrorCode.
const (
	UNKNOWNVIRUSERRORCODE V2reportsErrorVirusErrorCode = "UNKNOWN_VIRUS_ERROR_CODE"
)

// Defines values for V2reportsGeneType.
const (
	V2reportsGeneTypeBIOLOGICALREGION V2reportsGeneType = "BIOLOGICAL_REGION"
	V2reportsGeneTypeMiscRNA          V2reportsGeneType = "miscRNA"
	V2reportsGeneTypeNcRNA            V2reportsGeneType = "ncRNA"
	V2reportsGeneTypeOTHER            V2reportsGeneType = "OTHER"
	V2reportsGeneTypePROTEINCODING    V2reportsGeneType = "PROTEIN_CODING"
	V2reportsGeneTypePSEUDO           V2reportsGeneType = "PSEUDO"
	V2reportsGeneTypeRRNA             V2reportsGeneType = "rRNA"
	V2reportsGeneTypeScRNA            V2reportsGeneType = "scRNA"
	V2reportsGeneTypeSnRNA            V2reportsGeneType = "snRNA"
	V2reportsGeneTypeSnoRNA           V2reportsGeneType = "snoRNA"
	V2reportsGeneTypeTRANSPOSON       V2reportsGeneType = "TRANSPOSON"
	V2reportsGeneTypeTRNA             V2reportsGeneType = "tRNA"
	V2reportsGeneTypeUNKNOWN          V2reportsGeneType = "UNKNOWN"
)

// Defines values for V2reportsGenomicRegionGenomicRegionType.
const (
	V2reportsGenomicRegionGenomicRegionTypeBIOLOGICALREGION V2reportsGenomicRegionGenomicRegionType = "BIOLOGICAL_REGION"
	V2reportsGenomicRegionGenomicRegionTypeOTHER            V2reportsGenomicRegionGenomicRegionType = "OTHER"
	V2reportsGenomicRegionGenomicRegionTypePSEUDOGENE       V2reportsGenomicRegionGenomicRegionType = "PSEUDOGENE"
	V2reportsGenomicRegionGenomicRegionTypeREFSEQGENE       V2reportsGenomicRegionGenomicRegionType = "REFSEQ_GENE"
	V2reportsGenomicRegionGenomicRegionTypeUNKNOWN          V2reportsGenomicRegionGenomicRegionType = "UNKNOWN"
)

// Defines values for V2reportsLinkedAssemblyType.
const (
	AlternatePseudohaplotypeOfDiploid V2reportsLinkedAssemblyType = "alternate_pseudohaplotype_of_diploid"
	Haploid                           V2reportsLinkedAssemblyType = "haploid"
	Haplotype1                        V2reportsLinkedAssemblyType = "haplotype_1"
	Haplotype2                        V2reportsLinkedAssemblyType = "haplotype_2"
	Haplotype3                        V2reportsLinkedAssemblyType = "haplotype_3"
	Haplotype4                        V2reportsLinkedAssemblyType = "haplotype_4"
	LINKEDASSEMBLYTYPEUNKNOWN         V2reportsLinkedAssemblyType = "LINKED_ASSEMBLY_TYPE_UNKNOWN"
	MaternalHaplotypeOfDiploid        V2reportsLinkedAssemblyType = "maternal_haplotype_of_diploid"
	PaternalHaplotypeOfDiploid        V2reportsLinkedAssemblyType = "paternal_haplotype_of_diploid"
	PrincipalPseudohaplotypeOfDiploid V2reportsLinkedAssemblyType = "principal_pseudohaplotype_of_diploid"
)

// Defines values for V2reportsNameAndAuthorityNoteClassifier.
const (
	EffectiveName         V2reportsNameAndAuthorityNoteClassifier = "effective_name"
	IctvAccepted          V2reportsNameAndAuthorityNoteClassifier = "ictv_accepted"
	NoAuthorityClassifier V2reportsNameAndAuthorityNoteClassifier = "no_authority_classifier"
	NomenApprobbatum      V2reportsNameAndAuthorityNoteClassifier = "nomen_approbbatum"
)

// Defines values for V2reportsOrganelleTopology.
const (
	Circular        V2reportsOrganelleTopology = "Circular"
	Linear          V2reportsOrganelleTopology = "Linear"
	TOPOLOGYUNKNOWN V2reportsOrganelleTopology = "TOPOLOGY_UNKNOWN"
	Tandem          V2reportsOrganelleTopology = "Tandem"
)

// Defines values for V2reportsOrganelleType.
const (
	Apicoplast           V2reportsOrganelleType = "Apicoplast"
	Chloroplast          V2reportsOrganelleType = "Chloroplast"
	Chromatophore        V2reportsOrganelleType = "Chromatophore"
	Cyanelle             V2reportsOrganelleType = "Cyanelle"
	Kinetoplast          V2reportsOrganelleType = "Kinetoplast"
	Mitochondrion        V2reportsOrganelleType = "Mitochondrion"
	ORGANELLETYPEUNKNOWN V2reportsOrganelleType = "ORGANELLE_TYPE_UNKNOWN"
	Plastid              V2reportsOrganelleType = "Plastid"
)

// Defines values for V2reportsOrientation.
const (
	Minus V2reportsOrientation = "minus"
	None  V2reportsOrientation = "none"
	Plus  V2reportsOrientation = "plus"
)

// Defines values for V2reportsPurposeOfSampling.
const (
	PURPOSEOFSAMPLINGBASELINESURVEILLANCE V2reportsPurposeOfSampling = "PURPOSE_OF_SAMPLING_BASELINE_SURVEILLANCE"
	PURPOSEOFSAMPLINGUNKNOWN              V2reportsPurposeOfSampling = "PURPOSE_OF_SAMPLING_UNKNOWN"
)

// Defines values for V2reportsRankType.
const (
	BIOTYPE         V2reportsRankType = "BIOTYPE"
	CLADE           V2reportsRankType = "CLADE"
	CLASS           V2reportsRankType = "CLASS"
	COHORT          V2reportsRankType = "COHORT"
	FAMILY          V2reportsRankType = "FAMILY"
	FORMA           V2reportsRankType = "FORMA"
	FORMASPECIALIS  V2reportsRankType = "FORMA_SPECIALIS"
	GENOTYPE        V2reportsRankType = "GENOTYPE"
	GENUS           V2reportsRankType = "GENUS"
	INFRACLASS      V2reportsRankType = "INFRACLASS"
	INFRAORDER      V2reportsRankType = "INFRAORDER"
	ISOLATE         V2reportsRankType = "ISOLATE"
	KINGDOM         V2reportsRankType = "KINGDOM"
	MORPH           V2reportsRankType = "MORPH"
	NORANK          V2reportsRankType = "NO_RANK"
	ORDER           V2reportsRankType = "ORDER"
	PARVORDER       V2reportsRankType = "PARVORDER"
	PATHOGROUP      V2reportsRankType = "PATHOGROUP"
	PHYLUM          V2reportsRankType = "PHYLUM"
	SECTION         V2reportsRankType = "SECTION"
	SERIES          V2reportsRankType = "SERIES"
	SEROGROUP       V2reportsRankType = "SEROGROUP"
	SEROTYPE        V2reportsRankType = "SEROTYPE"
	SPECIES         V2reportsRankType = "SPECIES"
	SPECIESGROUP    V2reportsRankType = "SPECIES_GROUP"
	SPECIESSUBGROUP V2reportsRankType = "SPECIES_SUBGROUP"
	STRAIN          V2reportsRankType = "STRAIN"
	SUBCLASS        V2reportsRankType = "SUBCLASS"
	SUBCOHORT       V2reportsRankType = "SUBCOHORT"
	SUBFAMILY       V2reportsRankType = "SUBFAMILY"
	SUBGENUS        V2reportsRankType = "SUBGENUS"
	SUBKINGDOM      V2reportsRankType = "SUBKINGDOM"
	SUBORDER        V2reportsRankType = "SUBORDER"
	SUBPHYLUM       V2reportsRankType = "SUBPHYLUM"
	SUBSECTION      V2reportsRankType = "SUBSECTION"
	SUBSPECIES      V2reportsRankType = "SUBSPECIES"
	SUBTRIBE        V2reportsRankType = "SUBTRIBE"
	SUBVARIETY      V2reportsRankType = "SUBVARIETY"
	SUPERCLASS      V2reportsRankType = "SUPERCLASS"
	SUPERFAMILY     V2reportsRankType = "SUPERFAMILY"
	SUPERKINGDOM    V2reportsRankType = "SUPERKINGDOM"
	SUPERORDER      V2reportsRankType = "SUPERORDER"
	SUPERPHYLUM     V2reportsRankType = "SUPERPHYLUM"
	TRIBE           V2reportsRankType = "TRIBE"
	VARIETAS        V2reportsRankType = "VARIETAS"
)

// Defines values for V2reportsRnaType.
const (
	Premsg     V2reportsRnaType = "premsg"
	RnaUNKNOWN V2reportsRnaType = "rna_UNKNOWN"
	TmRna      V2reportsRnaType = "tmRna"
)

// Defines values for V2reportsSourceDatabase.
const (
	SOURCEDATABASEGENBANK     V2reportsSourceDatabase = "SOURCE_DATABASE_GENBANK"
	SOURCEDATABASEREFSEQ      V2reportsSourceDatabase = "SOURCE_DATABASE_REFSEQ"
	SOURCEDATABASEUNSPECIFIED V2reportsSourceDatabase = "SOURCE_DATABASE_UNSPECIFIED"
)

// Defines values for V2reportsTranscriptTranscriptType.
const (
	V2reportsTranscriptTranscriptTypeNONCODING          V2reportsTranscriptTranscriptType = "NON_CODING"
	V2reportsTranscriptTranscriptTypeNONCODINGMODEL     V2reportsTranscriptTranscriptType = "NON_CODING_MODEL"
	V2reportsTranscriptTranscriptTypePROTEINCODING      V2reportsTranscriptTranscriptType = "PROTEIN_CODING"
	V2reportsTranscriptTranscriptTypePROTEINCODINGMODEL V2reportsTranscriptTranscriptType = "PROTEIN_CODING_MODEL"
	V2reportsTranscriptTranscriptTypeUNKNOWN            V2reportsTranscriptTranscriptType = "UNKNOWN"
)

// Defines values for V2reportsVirusAssemblyCompleteness.
const (
	V2reportsVirusAssemblyCompletenessCOMPLETE V2reportsVirusAssemblyCompleteness = "COMPLETE"
	V2reportsVirusAssemblyCompletenessPARTIAL  V2reportsVirusAssemblyCompleteness = "PARTIAL"
	V2reportsVirusAssemblyCompletenessUNKNOWN  V2reportsVirusAssemblyCompleteness = "UNKNOWN"
)

// Defines values for V2reportsVirusPeptideViralPeptideCompleteness.
const (
	V2reportsVirusPeptideViralPeptideCompletenessCOMPLETE V2reportsVirusPeptideViralPeptideCompleteness = "COMPLETE"
	V2reportsVirusPeptideViralPeptideCompletenessPARTIAL  V2reportsVirusPeptideViralPeptideCompleteness = "PARTIAL"
	V2reportsVirusPeptideViralPeptideCompletenessUNKNOWN  V2reportsVirusPeptideViralPeptideCompleteness = "UNKNOWN"
)

// Defines values for V2reportsWarningGeneWarningCode.
const (
	ABOVESPECIESTAXON        V2reportsWarningGeneWarningCode = "ABOVE_SPECIES_TAXON"
	ACCESSIONVERSIONMISMATCH V2reportsWarningGeneWarningCode = "ACCESSION_VERSION_MISMATCH"
	DISCONTINUEDGENEID       V2reportsWarningGeneWarningCode = "DISCONTINUED_GENE_ID"
	NOGENEANNOTATIONFOUND    V2reportsWarningGeneWarningCode = "NO_GENE_ANNOTATION_FOUND"
	REPLACEDGENEID           V2reportsWarningGeneWarningCode = "REPLACED_GENE_ID"
	UNKNOWNGENEWARNINGCODE   V2reportsWarningGeneWarningCode = "UNKNOWN_GENE_WARNING_CODE"
	UNRECOGNIZEDACCESSION    V2reportsWarningGeneWarningCode = "UNRECOGNIZED_ACCESSION"
	UNRECOGNIZEDGENEID       V2reportsWarningGeneWarningCode = "UNRECOGNIZED_GENE_ID"
	UNRECOGNIZEDGENESYMBOL   V2reportsWarningGeneWarningCode = "UNRECOGNIZED_GENE_SYMBOL"
	UNRECOGNIZEDTAXTOKEN     V2reportsWarningGeneWarningCode = "UNRECOGNIZED_TAX_TOKEN"
)

// ProtobufAny defines model for protobufAny.
type ProtobufAny struct {
	TypeUrl *string `json:"type_url,omitempty"`
	Value   *[]byte `json:"value,omitempty"`
}

// RpcStatus defines model for rpcStatus.
type RpcStatus struct {
	Code    *int32         `json:"code,omitempty"`
	Details *[]ProtobufAny `json:"details,omitempty"`
	Message *string        `json:"message,omitempty"`
}

// V2AnnotationForAssemblyType defines model for v2AnnotationForAssemblyType.
type V2AnnotationForAssemblyType string

// V2AnnotationForOrganelleType defines model for v2AnnotationForOrganelleType.
type V2AnnotationForOrganelleType string

// V2AssemblyAccessions defines model for v2AssemblyAccessions.
type V2AssemblyAccessions struct {
	Accessions *[]string `json:"accessions,omitempty"`
}

// V2AssemblyCheckMHistogramReply defines model for v2AssemblyCheckMHistogramReply.
type V2AssemblyCheckMHistogramReply struct {
	HistogramIntervals *[]V2AssemblyCheckMHistogramReplyHistogramInterval `json:"histogram_intervals,omitempty"`
	SpeciesTaxid       *int                                               `json:"species_taxid,omitempty"`
}

// V2AssemblyCheckMHistogramReplyHistogramInterval defines model for v2AssemblyCheckMHistogramReplyHistogramInterval.
type V2AssemblyCheckMHistogramReplyHistogramInterval struct {
	Count    *float32 `json:"count,omitempty"`
	StartPos *float32 `json:"start_pos,omitempty"`
	StopPos  *float32 `json:"stop_pos,omitempty"`
}

// V2AssemblyCheckMHistogramRequest defines model for v2AssemblyCheckMHistogramRequest.
type V2AssemblyCheckMHistogramRequest struct {
	SpeciesTaxon *string `json:"species_taxon,omitempty"`
}

// V2AssemblyDatasetAvailability defines model for v2AssemblyDatasetAvailability.
type V2AssemblyDatasetAvailability struct {
	InvalidAssemblies *[]string `json:"invalid_assemblies,omitempty"`
	Reason            *string   `json:"reason,omitempty"`
	ValidAssemblies   *[]string `json:"valid_assemblies,omitempty"`
}

// V2AssemblyDatasetDescriptorsFilter defines model for v2AssemblyDatasetDescriptorsFilter.
type V2AssemblyDatasetDescriptorsFilter struct {
	AssemblyLevel        *[]V2reportsAssemblyLevel                                  `json:"assembly_level,omitempty"`
	AssemblySource       *V2AssemblyDatasetDescriptorsFilterAssemblySource          `json:"assembly_source,omitempty"`
	AssemblyVersion      *V2AssemblyDatasetDescriptorsFilterAssemblyVersion         `json:"assembly_version,omitempty"`
	ExcludeAtypical      *bool                                                      `json:"exclude_atypical,omitempty"`
	ExcludeMultiIsolate  *bool                                                      `json:"exclude_multi_isolate,omitempty"`
	ExcludePairedReports *bool                                                      `json:"exclude_paired_reports,omitempty"`
	FirstReleaseDate     *time.Time                                                 `json:"first_release_date,omitempty"`
	HasAnnotation        *bool                                                      `json:"has_annotation,omitempty"`
	IsIctvExemplar       *bool                                                      `json:"is_ictv_exemplar,omitempty"`
	IsMetagenomeDerived  *V2AssemblyDatasetDescriptorsFilterMetagenomeDerivedFilter `json:"is_metagenome_derived,omitempty"`
	IsTypeMaterial       *bool                                                      `json:"is_type_material,omitempty"`
	LastReleaseDate      *time.Time                                                 `json:"last_release_date,omitempty"`
	ReferenceOnly        *bool                                                      `json:"reference_only,omitempty"`
	SearchText           *[]string                                                  `json:"search_text,omitempty"`
	TypeMaterialCategory *V2AssemblyDatasetDescriptorsFilterTypeMaterialCategory    `json:"type_material_category,omitempty"`
}

// V2AssemblyDatasetDescriptorsFilterAssemblySource defines model for v2AssemblyDatasetDescriptorsFilterAssemblySource.
type V2AssemblyDatasetDescriptorsFilterAssemblySource string

// V2AssemblyDatasetDescriptorsFilterAssemblyVersion defines model for v2AssemblyDatasetDescriptorsFilterAssemblyVersion.
type V2AssemblyDatasetDescriptorsFilterAssemblyVersion string

// V2AssemblyDatasetDescriptorsFilterMetagenomeDerivedFilter defines model for v2AssemblyDatasetDescriptorsFilterMetagenomeDerivedFilter.
type V2AssemblyDatasetDescriptorsFilterMetagenomeDerivedFilter string

// V2AssemblyDatasetDescriptorsFilterTypeMaterialCategory defines model for v2AssemblyDatasetDescriptorsFilterTypeMaterialCategory.
type V2AssemblyDatasetDescriptorsFilterTypeMaterialCategory string

// V2AssemblyDatasetReportsRequest defines model for v2AssemblyDatasetReportsRequest.
type V2AssemblyDatasetReportsRequest struct {
	Accessions           *[]string                                   `json:"accessions,omitempty"`
	AssemblyNames        *[]string                                   `json:"assembly_names,omitempty"`
	Bioprojects          *[]string                                   `json:"bioprojects,omitempty"`
	BiosampleIds         *[]string                                   `json:"biosample_ids,omitempty"`
	Chromosomes          *[]string                                   `json:"chromosomes,omitempty"`
	Filters              *V2AssemblyDatasetDescriptorsFilter         `json:"filters,omitempty"`
	IncludeTabularHeader *V2IncludeTabularHeader                     `json:"include_tabular_header,omitempty"`
	PageSize             *int                                        `json:"page_size,omitempty"`
	PageToken            *string                                     `json:"page_token,omitempty"`
	ReturnedContent      *V2AssemblyDatasetReportsRequestContentType `json:"returned_content,omitempty"`
	Sort                 *[]V2SortField                              `json:"sort,omitempty"`
	TableFields          *[]string                                   `json:"table_fields,omitempty"`
	TableFormat          *string                                     `json:"table_format,omitempty"`
	TaxExactMatch        *bool                                       `json:"tax_exact_match,omitempty"`
	Taxons               *[]string                                   `json:"taxons,omitempty"`
	WgsAccessions        *[]string                                   `json:"wgs_accessions,omitempty"`
}

// V2AssemblyDatasetReportsRequestContentType defines model for v2AssemblyDatasetReportsRequestContentType.
type V2AssemblyDatasetReportsRequestContentType string

// V2AssemblyDatasetRequest defines model for v2AssemblyDatasetRequest.
type V2AssemblyDatasetRequest struct {
	ExpDebugValues        *string                             `json:"_exp_debug_values,omitempty"`
	Accessions            *[]string                           `json:"accessions,omitempty"`
	Chromosomes           *[]string                           `json:"chromosomes,omitempty"`
	Hydrated              *V2AssemblyDatasetRequestResolution `json:"hydrated,omitempty"`
	IncludeAnnotationType *[]V2AnnotationForAssemblyType      `json:"include_annotation_type,omitempty"`
	IncludeTsv            *bool                               `json:"include_tsv,omitempty"`
}

// V2AssemblyDatasetRequestResolution defines model for v2AssemblyDatasetRequestResolution.
type V2AssemblyDatasetRequestResolution string

// V2AssemblyLinksReply defines model for v2AssemblyLinksReply.
type V2AssemblyLinksReply struct {
	AssemblyLinks *[]V2AssemblyLinksReplyAssemblyLink `json:"assembly_links,omitempty"`
}

// V2AssemblyLinksReplyAssemblyLink defines model for v2AssemblyLinksReplyAssemblyLink.
type V2AssemblyLinksReplyAssemblyLink struct {
	Accession         *string                               `json:"accession,omitempty"`
	AssemblyLinkType  *V2AssemblyLinksReplyAssemblyLinkType `json:"assembly_link_type,omitempty"`
	LinkedIdentifiers *[]string                             `json:"linked_identifiers,omitempty"`
	ResourceLink      *string                               `json:"resource_link,omitempty"`
}

// V2AssemblyLinksReplyAssemblyLinkType defines model for v2AssemblyLinksReplyAssemblyLinkType.
type V2AssemblyLinksReplyAssemblyLinkType string

// V2AssemblyLinksRequest defines model for v2AssemblyLinksRequest.
type V2AssemblyLinksRequest struct {
	Accessions *[]string `json:"accessions,omitempty"`
}

// V2AssemblyRevisionHistory defines model for v2AssemblyRevisionHistory.
type V2AssemblyRevisionHistory struct {
	AssemblyRevisions *[]V2reportsAssemblyRevision `json:"assembly_revisions,omitempty"`
	TotalCount        *int                         `json:"total_count,omitempty"`
}

// V2AssemblyRevisionHistoryRequest defines model for v2AssemblyRevisionHistoryRequest.
type V2AssemblyRevisionHistoryRequest struct {
	Accession *string `json:"accession,omitempty"`
}

// V2AssemblySequenceReportsRequest defines model for v2AssemblySequenceReportsRequest.
type V2AssemblySequenceReportsRequest struct {
	Accession             *string                 `json:"accession,omitempty"`
	Chromosomes           *[]string               `json:"chromosomes,omitempty"`
	CountAssemblyUnplaced *bool                   `json:"count_assembly_unplaced,omitempty"`
	IncludeTabularHeader  *V2IncludeTabularHeader `json:"include_tabular_header,omitempty"`
	PageSize              *int                    `json:"page_size,omitempty"`
	PageToken             *string                 `json:"page_token,omitempty"`
	RoleFilters           *[]string               `json:"role_filters,omitempty"`
	TableFields           *[]string               `json:"table_fields,omitempty"`
	TableFormat           *string                 `json:"table_format,omitempty"`
}

// V2DownloadSummary defines model for v2DownloadSummary.
type V2DownloadSummary struct {
	AssemblyCount     *int                             `json:"assembly_count,omitempty"`
	AvailableFiles    *V2DownloadSummaryAvailableFiles `json:"available_files,omitempty"`
	Dehydrated        *V2DownloadSummaryDehydrated     `json:"dehydrated,omitempty"`
	Errors            *[]V2reportsError                `json:"errors,omitempty"`
	Hydrated          *V2DownloadSummaryHydrated       `json:"hydrated,omitempty"`
	Messages          *[]V2reportsMessage              `json:"messages,omitempty"`
	RecordCount       *int                             `json:"record_count,omitempty"`
	ResourceUpdatedOn *time.Time                       `json:"resource_updated_on,omitempty"`
}

// V2DownloadSummaryAvailableFiles defines model for v2DownloadSummaryAvailableFiles.
type V2DownloadSummaryAvailableFiles struct {
	AllGenomicFasta  *V2DownloadSummaryFileSummary `json:"all_genomic_fasta,omitempty"`
	AnnotationReport *V2DownloadSummaryFileSummary `json:"annotation_report,omitempty"`
	CdsFasta         *V2DownloadSummaryFileSummary `json:"cds_fasta,omitempty"`
	GenomeGbff       *V2DownloadSummaryFileSummary `json:"genome_gbff,omitempty"`
	GenomeGff        *V2DownloadSummaryFileSummary `json:"genome_gff,omitempty"`
	GenomeGtf        *V2DownloadSummaryFileSummary `json:"genome_gtf,omitempty"`
	ProtFasta        *V2DownloadSummaryFileSummary `json:"prot_fasta,omitempty"`
	RnaFasta         *V2DownloadSummaryFileSummary `json:"rna_fasta,omitempty"`
	SequenceReport   *V2DownloadSummaryFileSummary `json:"sequence_report,omitempty"`
}

// V2DownloadSummaryDehydrated defines model for v2DownloadSummaryDehydrated.
type V2DownloadSummaryDehydrated struct {
	CliDownloadCommandLine  *string `json:"cli_download_command_line,omitempty"`
	CliRehydrateCommandLine *string `json:"cli_rehydrate_command_line,omitempty"`
	EstimatedFileSizeMb     *int    `json:"estimated_file_size_mb,omitempty"`
	Url                     *string `json:"url,omitempty"`
}

// V2DownloadSummaryFileSummary defines model for v2DownloadSummaryFileSummary.
type V2DownloadSummaryFileSummary struct {
	FileCount *int     `json:"file_count,omitempty"`
	SizeMb    *float32 `json:"size_mb,omitempty"`
}

// V2DownloadSummaryHydrated defines model for v2DownloadSummaryHydrated.
type V2DownloadSummaryHydrated struct {
	CliDownloadCommandLine *string `json:"cli_download_command_line,omitempty"`
	EstimatedFileSizeMb    *int    `json:"estimated_file_size_mb,omitempty"`
	Url                    *string `json:"url,omitempty"`
}

// V2Fasta defines model for v2Fasta.
type V2Fasta string

// V2GeneChromosomeSummaryReply defines model for v2GeneChromosomeSummaryReply.
type V2GeneChromosomeSummaryReply struct {
	GeneChromosomeSummaries *[]V2GeneChromosomeSummaryReplyGeneChromosomeSummary `json:"gene_chromosome_summaries,omitempty"`
}

// V2GeneChromosomeSummaryReplyGeneChromosomeSummary defines model for v2GeneChromosomeSummaryReplyGeneChromosomeSummary.
type V2GeneChromosomeSummaryReplyGeneChromosomeSummary struct {
	Accession *string `json:"accession,omitempty"`
	Count     *int    `json:"count,omitempty"`
	Name      *string `json:"name,omitempty"`
}

// V2GeneCountsByTaxonReply defines model for v2GeneCountsByTaxonReply.
type V2GeneCountsByTaxonReply struct {
	Report *[]V2GeneCountsByTaxonReplyGeneTypeAndCount `json:"report,omitempty"`
}

// V2GeneCountsByTaxonReplyGeneTypeAndCount defines model for v2GeneCountsByTaxonReplyGeneTypeAndCount.
type V2GeneCountsByTaxonReplyGeneTypeAndCount struct {
	Count    *int    `json:"count,omitempty"`
	GeneType *string `json:"gene_type,omitempty"`
}

// V2GeneCountsByTaxonRequest defines model for v2GeneCountsByTaxonRequest.
type V2GeneCountsByTaxonRequest struct {
	Taxon *string `json:"taxon,omitempty"`
}

// V2GeneDatasetReportsRequest defines model for v2GeneDatasetReportsRequest.
type V2GeneDatasetReportsRequest struct {
	Accessions           *[]string                                   `json:"accessions,omitempty"`
	GeneIds              *[]int                                      `json:"gene_ids,omitempty"`
	IncludeTabularHeader *V2IncludeTabularHeader                     `json:"include_tabular_header,omitempty"`
	PageSize             *int                                        `json:"page_size,omitempty"`
	PageToken            *string                                     `json:"page_token,omitempty"`
	Query                *string                                     `json:"query,omitempty"`
	ReturnedContent      *V2GeneDatasetReportsRequestContentType     `json:"returned_content,omitempty"`
	SymbolsForTaxon      *V2GeneDatasetReportsRequestSymbolsForTaxon `json:"symbols_for_taxon,omitempty"`
	TableFields          *[]string                                   `json:"table_fields,omitempty"`
	TableFormat          *string                                     `json:"table_format,omitempty"`
	Taxon                *string                                     `json:"taxon,omitempty"`
	Types                *[]V2GeneType                               `json:"types,omitempty"`
}

// V2GeneDatasetReportsRequestContentType defines model for v2GeneDatasetReportsRequestContentType.
type V2GeneDatasetReportsRequestContentType string

// V2GeneDatasetReportsRequestSymbolsForTaxon defines model for v2GeneDatasetReportsRequestSymbolsForTaxon.
type V2GeneDatasetReportsRequestSymbolsForTaxon struct {
	Symbols *[]string `json:"symbols,omitempty"`
	Taxon   *string   `json:"taxon,omitempty"`
}

// V2GeneDatasetRequest defines model for v2GeneDatasetRequest.
type V2GeneDatasetRequest struct {
	AuxReport             *[]V2GeneDatasetRequestGeneDatasetReportType `json:"aux_report,omitempty"`
	FastaFilter           *[]string                                    `json:"fasta_filter,omitempty"`
	GeneIds               *[]int                                       `json:"gene_ids,omitempty"`
	IncludeAnnotationType *[]V2Fasta                                   `json:"include_annotation_type,omitempty"`
	ReturnedContent       *V2GeneDatasetRequestContentType             `json:"returned_content,omitempty"`
	TableFields           *[]string                                    `json:"table_fields,omitempty"`
	TableReportType       *V2GeneDatasetRequestGeneDatasetReportType   `json:"table_report_type,omitempty"`
}

// V2GeneDatasetRequestContentType defines model for v2GeneDatasetRequestContentType.
type V2GeneDatasetRequestContentType string

// V2GeneDatasetRequestGeneDatasetReportType defines model for v2GeneDatasetRequestGeneDatasetReportType.
type V2GeneDatasetRequestGeneDatasetReportType string

// V2GeneLinksReply defines model for v2GeneLinksReply.
type V2GeneLinksReply struct {
	GeneLinks *[]V2GeneLinksReplyGeneLink `json:"gene_links,omitempty"`
}

// V2GeneLinksReplyGeneLink defines model for v2GeneLinksReplyGeneLink.
type V2GeneLinksReplyGeneLink struct {
	GeneId       *int                          `json:"gene_id,omitempty"`
	GeneLinkType *V2GeneLinksReplyGeneLinkType `json:"gene_link_type,omitempty"`
	ResourceId   *string                       `json:"resource_id,omitempty"`
	ResourceLink *string                       `json:"resource_link,omitempty"`
}

// V2GeneLinksReplyGeneLinkType defines model for v2GeneLinksReplyGeneLinkType.
type V2GeneLinksReplyGeneLinkType string

// V2GeneLinksRequest defines model for v2GeneLinksRequest.
type V2GeneLinksRequest struct {
	GeneIds *[]int `json:"gene_ids,omitempty"`
}

// V2GeneType defines model for v2GeneType.
type V2GeneType string

// V2GenomeAnnotationRequest defines model for v2GenomeAnnotationRequest.
type V2GenomeAnnotationRequest struct {
	Accession             *string                                               `json:"accession,omitempty"`
	AnnotationIds         *[]string                                             `json:"annotation_ids,omitempty"`
	GeneTypes             *[]string                                             `json:"gene_types,omitempty"`
	IncludeAnnotationType *[]V2GenomeAnnotationRequestAnnotationType            `json:"include_annotation_type,omitempty"`
	IncludeTabularHeader  *V2IncludeTabularHeader                               `json:"include_tabular_header,omitempty"`
	Locations             *[]string                                             `json:"locations,omitempty"`
	PageSize              *int                                                  `json:"page_size,omitempty"`
	PageToken             *string                                               `json:"page_token,omitempty"`
	SearchText            *[]string                                             `json:"search_text,omitempty"`
	Sort                  *[]V2SortField                                        `json:"sort,omitempty"`
	Symbols               *[]string                                             `json:"symbols,omitempty"`
	TableFields           *[]string                                             `json:"table_fields,omitempty"`
	TableFormat           *V2GenomeAnnotationRequestGenomeAnnotationTableFormat `json:"table_format,omitempty"`
}

// V2GenomeAnnotationRequestAnnotationType defines model for v2GenomeAnnotationRequestAnnotationType.
type V2GenomeAnnotationRequestAnnotationType string

// V2GenomeAnnotationRequestGenomeAnnotationTableFormat defines model for v2GenomeAnnotationRequestGenomeAnnotationTableFormat.
type V2GenomeAnnotationRequestGenomeAnnotationTableFormat string

// V2GenomeAnnotationTableSummaryReply defines model for v2GenomeAnnotationTableSummaryReply.
type V2GenomeAnnotationTableSummaryReply struct {
	Accession    *string   `json:"accession,omitempty"`
	Chromosomes  *[]string `json:"chromosomes,omitempty"`
	EmptyColumns *[]string `json:"empty_columns,omitempty"`
	GeneTypes    *[]string `json:"gene_types,omitempty"`
}

// V2HttpBody defines model for v2HttpBody.
type V2HttpBody struct {
	ContentType *string `json:"content_type,omitempty"`
	Data        *[]byte `json:"data,omitempty"`
}

// V2ImageSize defines model for v2ImageSize.
type V2ImageSize string

// V2IncludeTabularHeader defines model for v2IncludeTabularHeader.
type V2IncludeTabularHeader string

// V2OrganelleDownloadRequest defines model for v2OrganelleDownloadRequest.
type V2OrganelleDownloadRequest struct {
	Accessions            *[]string                       `json:"accessions,omitempty"`
	ExcludeSequence       *bool                           `json:"exclude_sequence,omitempty"`
	IncludeAnnotationType *[]V2AnnotationForOrganelleType `json:"include_annotation_type,omitempty"`
}

// V2OrganelleMetadataRequest defines model for v2OrganelleMetadataRequest.
type V2OrganelleMetadataRequest struct {
	Accessions           *[]string                                       `json:"accessions,omitempty"`
	FirstReleaseDate     *time.Time                                      `json:"first_release_date,omitempty"`
	IncludeTabularHeader *V2IncludeTabularHeader                         `json:"include_tabular_header,omitempty"`
	LastReleaseDate      *time.Time                                      `json:"last_release_date,omitempty"`
	OrganelleTypes       *[]V2reportsOrganelleType                       `json:"organelle_types,omitempty"`
	PageSize             *int                                            `json:"page_size,omitempty"`
	PageToken            *string                                         `json:"page_token,omitempty"`
	ReturnedContent      *V2OrganelleMetadataRequestContentType          `json:"returned_content,omitempty"`
	Sort                 *[]V2OrganelleSort                              `json:"sort,omitempty"`
	TableFormat          *V2OrganelleMetadataRequestOrganelleTableFormat `json:"table_format,omitempty"`
	TaxExactMatch        *bool                                           `json:"tax_exact_match,omitempty"`
	Taxons               *[]string                                       `json:"taxons,omitempty"`
}

// V2OrganelleMetadataRequestContentType defines model for v2OrganelleMetadataRequestContentType.
type V2OrganelleMetadataRequestContentType string

// V2OrganelleMetadataRequestOrganelleTableFormat defines model for v2OrganelleMetadataRequestOrganelleTableFormat.
type V2OrganelleMetadataRequestOrganelleTableFormat string

// V2OrganelleSort defines model for v2OrganelleSort.
type V2OrganelleSort struct {
	Direction *V2SortDirection `json:"direction,omitempty"`
	Field     *string          `json:"field,omitempty"`
}

// V2OrganismQueryRequest defines model for v2OrganismQueryRequest.
type V2OrganismQueryRequest struct {
	ExactMatch          *bool                                      `json:"exact_match,omitempty"`
	OrganismQuery       *string                                    `json:"organism_query,omitempty"`
	TaxRankFilter       *V2OrganismQueryRequestTaxRankFilter       `json:"tax_rank_filter,omitempty"`
	TaxonQuery          *string                                    `json:"taxon_query,omitempty"`
	TaxonResourceFilter *V2OrganismQueryRequestTaxonResourceFilter `json:"taxon_resource_filter,omitempty"`
}

// V2OrganismQueryRequestTaxRankFilter defines model for v2OrganismQueryRequestTaxRankFilter.
type V2OrganismQueryRequestTaxRankFilter string

// V2OrganismQueryRequestTaxonResourceFilter defines model for v2OrganismQueryRequestTaxonResourceFilter.
type V2OrganismQueryRequestTaxonResourceFilter string

// V2OrthologRequest defines model for v2OrthologRequest.
type V2OrthologRequest struct {
	GeneId          *int                          `json:"gene_id,omitempty"`
	PageSize        *int                          `json:"page_size,omitempty"`
	PageToken       *string                       `json:"page_token,omitempty"`
	ReturnedContent *V2OrthologRequestContentType `json:"returned_content,omitempty"`
	TaxonFilter     *[]string                     `json:"taxon_filter,omitempty"`
}

// V2OrthologRequestContentType defines model for v2OrthologRequestContentType.
type V2OrthologRequestContentType string

// V2ProkaryoteGeneRequest defines model for v2ProkaryoteGeneRequest.
type V2ProkaryoteGeneRequest struct {
	Accessions            *[]string                               `json:"accessions,omitempty"`
	GeneFlankConfig       *V2ProkaryoteGeneRequestGeneFlankConfig `json:"gene_flank_config,omitempty"`
	IncludeAnnotationType *[]V2Fasta                              `json:"include_annotation_type,omitempty"`
	Taxon                 *string                                 `json:"taxon,omitempty"`
}

// V2ProkaryoteGeneRequestGeneFlankConfig defines model for v2ProkaryoteGeneRequestGeneFlankConfig.
type V2ProkaryoteGeneRequestGeneFlankConfig struct {
	Length *int `json:"length,omitempty"`
}

// V2Sars2ProteinDatasetRequest defines model for v2Sars2ProteinDatasetRequest.
type V2Sars2ProteinDatasetRequest struct {
	AnnotatedOnly   *bool                       `json:"annotated_only,omitempty"`
	AuxReport       *[]V2VirusDatasetReportType `json:"aux_report,omitempty"`
	CompleteOnly    *bool                       `json:"complete_only,omitempty"`
	Format          *V2TableFormat              `json:"format,omitempty"`
	GeoLocation     *string                     `json:"geo_location,omitempty"`
	Host            *string                     `json:"host,omitempty"`
	IncludeSequence *[]V2ViralSequenceType      `json:"include_sequence,omitempty"`
	Proteins        *[]string                   `json:"proteins,omitempty"`
	RefseqOnly      *bool                       `json:"refseq_only,omitempty"`
	ReleasedSince   *time.Time                  `json:"released_since,omitempty"`
	TableFields     *[]V2VirusTableField        `json:"table_fields,omitempty"`
	UpdatedSince    *time.Time                  `json:"updated_since,omitempty"`
}

// V2SciNameAndIds defines model for v2SciNameAndIds.
type V2SciNameAndIds struct {
	SciNameAndIds *[]V2SciNameAndIdsSciNameAndId `json:"sci_name_and_ids,omitempty"`
}

// V2SciNameAndIdsSciNameAndId defines model for v2SciNameAndIdsSciNameAndId.
type V2SciNameAndIdsSciNameAndId struct {
	CommonName  *string            `json:"common_name,omitempty"`
	GroupName   *string            `json:"group_name,omitempty"`
	MatchedTerm *string            `json:"matched_term,omitempty"`
	Rank        *V2reportsRankType `json:"rank,omitempty"`
	SciName     *string            `json:"sci_name,omitempty"`
	TaxId       *string            `json:"tax_id,omitempty"`
}

// V2SequenceAccessionRequest defines model for v2SequenceAccessionRequest.
type V2SequenceAccessionRequest struct {
	Accession *string `json:"accession,omitempty"`
}

// V2SequenceReportPage defines model for v2SequenceReportPage.
type V2SequenceReportPage struct {
	FirstPage     *bool                    `json:"_first_page,omitempty"`
	ReportFields  *[]string                `json:"_report_fields,omitempty"`
	ReportFormat  *string                  `json:"_report_format,omitempty"`
	ReportType    *string                  `json:"_report_type,omitempty"`
	NextPageToken *string                  `json:"next_page_token,omitempty"`
	Reports       *[]V2reportsSequenceInfo `json:"reports,omitempty"`
	TotalCount    *int                     `json:"total_count,omitempty"`
}

// V2SortDirection defines model for v2SortDirection.
type V2SortDirection string

// V2SortField defines model for v2SortField.
type V2SortField struct {
	Direction *V2SortDirection `json:"direction,omitempty"`
	Field     *string          `json:"field,omitempty"`
}

// V2TableFormat defines model for v2TableFormat.
type V2TableFormat string

// V2TabularOutput defines model for v2TabularOutput.
type V2TabularOutput struct {
	Data *string `json:"data,omitempty"`
}

// V2TaxonomyDatasetRequest defines model for v2TaxonomyDatasetRequest.
type V2TaxonomyDatasetRequest struct {
	AuxReports *[]V2TaxonomyDatasetRequestTaxonomyReportType `json:"aux_reports,omitempty"`
	TaxIds     *[]int                                        `json:"tax_ids,omitempty"`
}

// V2TaxonomyDatasetRequestTaxonomyReportType defines model for v2TaxonomyDatasetRequestTaxonomyReportType.
type V2TaxonomyDatasetRequestTaxonomyReportType string

// V2TaxonomyFilteredSubtreeRequest defines model for v2TaxonomyFilteredSubtreeRequest.
type V2TaxonomyFilteredSubtreeRequest struct {
	RankLimits     *[]V2reportsRankType `json:"rank_limits,omitempty"`
	SpecifiedLimit *bool                `json:"specified_limit,omitempty"`
	Taxons         *[]string            `json:"taxons,omitempty"`
}

// V2TaxonomyFilteredSubtreeResponse defines model for v2TaxonomyFilteredSubtreeResponse.
type V2TaxonomyFilteredSubtreeResponse struct {
	// Edges A map.
	Edges     *V2TaxonomyFilteredSubtreeResponseEdgesEntry `json:"edges,omitempty"`
	Errors    *[]V2reportsError                            `json:"errors,omitempty"`
	RootNodes *[]int                                       `json:"root_nodes,omitempty"`
	Warnings  *[]V2reportsWarning                          `json:"warnings,omitempty"`
}

// V2TaxonomyFilteredSubtreeResponseEdge defines model for v2TaxonomyFilteredSubtreeResponseEdge.
type V2TaxonomyFilteredSubtreeResponseEdge struct {
	ChildrenStatus  *V2TaxonomyFilteredSubtreeResponseEdgeChildStatus `json:"children_status,omitempty"`
	VisibleChildren *[]int                                            `json:"visible_children,omitempty"`
}

// V2TaxonomyFilteredSubtreeResponseEdgeChildStatus defines model for v2TaxonomyFilteredSubtreeResponseEdgeChildStatus.
type V2TaxonomyFilteredSubtreeResponseEdgeChildStatus string

// V2TaxonomyFilteredSubtreeResponseEdgesEntry A map.
type V2TaxonomyFilteredSubtreeResponseEdgesEntry struct {
	Default              *V2TaxonomyFilteredSubtreeResponseEdge           `json:"default,omitempty"`
	AdditionalProperties map[string]V2TaxonomyFilteredSubtreeResponseEdge `json:"-"`
}

// V2TaxonomyImageMetadataRequest defines model for v2TaxonomyImageMetadataRequest.
type V2TaxonomyImageMetadataRequest struct {
	Taxon *string `json:"taxon,omitempty"`
}

// V2TaxonomyImageMetadataResponse defines model for v2TaxonomyImageMetadataResponse.
type V2TaxonomyImageMetadataResponse struct {
	Attribution *string        `json:"attribution,omitempty"`
	Format      *string        `json:"format,omitempty"`
	ImageSizes  *[]V2ImageSize `json:"image_sizes,omitempty"`
	License     *string        `json:"license,omitempty"`
	Source      *string        `json:"source,omitempty"`
	Src         *string        `json:"src,omitempty"`
	TaxId       *string        `json:"tax_id,omitempty"`
}

// V2TaxonomyImageRequest defines model for v2TaxonomyImageRequest.
type V2TaxonomyImageRequest struct {
	ImageSize *V2ImageSize `json:"image_size,omitempty"`
	Taxon     *string      `json:"taxon,omitempty"`
}

// V2TaxonomyLinksRequest defines model for v2TaxonomyLinksRequest.
type V2TaxonomyLinksRequest struct {
	Taxon *string `json:"taxon,omitempty"`
}

// V2TaxonomyLinksResponse defines model for v2TaxonomyLinksResponse.
type V2TaxonomyLinksResponse struct {
	EncyclopediaOfLife                    *string                               `json:"encyclopedia_of_life,omitempty"`
	GenericLinks                          *[]V2TaxonomyLinksResponseGenericLink `json:"generic_links,omitempty"`
	GlobalBiodiversityInformationFacility *string                               `json:"global_biodiversity_information_facility,omitempty"`
	Inaturalist                           *string                               `json:"inaturalist,omitempty"`
	TaxId                                 *string                               `json:"tax_id,omitempty"`
	Viralzone                             *string                               `json:"viralzone,omitempty"`
	Wikipedia                             *string                               `json:"wikipedia,omitempty"`
}

// V2TaxonomyLinksResponseGenericLink defines model for v2TaxonomyLinksResponseGenericLink.
type V2TaxonomyLinksResponseGenericLink struct {
	LinkName *string `json:"link_name,omitempty"`
	LinkUrl  *string `json:"link_url,omitempty"`
}

// V2TaxonomyMatch defines model for v2TaxonomyMatch.
type V2TaxonomyMatch struct {
	Errors   *[]V2reportsError   `json:"errors,omitempty"`
	Query    *[]string           `json:"query,omitempty"`
	Taxonomy *V2TaxonomyNode     `json:"taxonomy,omitempty"`
	Warnings *[]V2reportsWarning `json:"warnings,omitempty"`
}

// V2TaxonomyMetadataRequest defines model for v2TaxonomyMetadataRequest.
type V2TaxonomyMetadataRequest struct {
	Children             *bool                                 `json:"children,omitempty"`
	IncludeTabularHeader *V2IncludeTabularHeader               `json:"include_tabular_header,omitempty"`
	PageSize             *int                                  `json:"page_size,omitempty"`
	PageToken            *string                               `json:"page_token,omitempty"`
	Ranks                *[]V2reportsRankType                  `json:"ranks,omitempty"`
	ReturnedContent      *V2TaxonomyMetadataRequestContentType `json:"returned_content,omitempty"`
	TableFormat          *V2TaxonomyMetadataRequestTableFormat `json:"table_format,omitempty"`
	Taxons               *[]string                             `json:"taxons,omitempty"`
}

// V2TaxonomyMetadataRequestContentType defines model for v2TaxonomyMetadataRequestContentType.
type V2TaxonomyMetadataRequestContentType string

// V2TaxonomyMetadataRequestTableFormat defines model for v2TaxonomyMetadataRequestTableFormat.
type V2TaxonomyMetadataRequestTableFormat string

// V2TaxonomyMetadataResponse defines model for v2TaxonomyMetadataResponse.
type V2TaxonomyMetadataResponse struct {
	Messages      *[]V2reportsMessage `json:"messages,omitempty"`
	TaxonomyNodes *[]V2TaxonomyMatch  `json:"taxonomy_nodes,omitempty"`
}

// V2TaxonomyNode defines model for v2TaxonomyNode.
type V2TaxonomyNode struct {
	IndexedNames                             *[]string                    `json:"_indexed_names,omitempty"`
	Acronyms                                 *[]string                    `json:"acronyms,omitempty"`
	BlastName                                *string                      `json:"blast_name,omitempty"`
	Children                                 *[]int                       `json:"children,omitempty"`
	CommonName                               *string                      `json:"common_name,omitempty"`
	Counts                                   *[]V2TaxonomyNodeCountByType `json:"counts,omitempty"`
	DescendentWithDescribedSpeciesNamesCount *int                         `json:"descendent_with_described_species_names_count,omitempty"`
	Extinct                                  *bool                        `json:"extinct,omitempty"`
	GenbankAcronym                           *string                      `json:"genbank_acronym,omitempty"`
	GenbankCommonName                        *string                      `json:"genbank_common_name,omitempty"`
	GenomicMoltype                           *string                      `json:"genomic_moltype,omitempty"`
	HasDescribedSpeciesName                  *bool                        `json:"has_described_species_name,omitempty"`
	Lineage                                  *[]int                       `json:"lineage,omitempty"`
	MaxOrd                                   *int                         `json:"max_ord,omitempty"`
	MinOrd                                   *int                         `json:"min_ord,omitempty"`
	OrganismName                             *string                      `json:"organism_name,omitempty"`
	Rank                                     *V2reportsRankType           `json:"rank,omitempty"`
	TaxId                                    *int                         `json:"tax_id,omitempty"`
}

// V2TaxonomyNodeCountByType defines model for v2TaxonomyNodeCountByType.
type V2TaxonomyNodeCountByType struct {
	Count *int                `json:"count,omitempty"`
	Type  *V2reportsCountType `json:"type,omitempty"`
}

// V2TaxonomyRelatedIdRequest defines model for v2TaxonomyRelatedIdRequest.
type V2TaxonomyRelatedIdRequest struct {
	IncludeLineage *bool                `json:"include_lineage,omitempty"`
	IncludeSubtree *bool                `json:"include_subtree,omitempty"`
	PageSize       *int                 `json:"page_size,omitempty"`
	PageToken      *string              `json:"page_token,omitempty"`
	Ranks          *[]V2reportsRankType `json:"ranks,omitempty"`
	TaxId          *int                 `json:"tax_id,omitempty"`
}

// V2TaxonomyTaxIdsPage defines model for v2TaxonomyTaxIdsPage.
type V2TaxonomyTaxIdsPage struct {
	NextPageToken *string `json:"next_page_token,omitempty"`
	TaxIds        *[]int  `json:"tax_ids,omitempty"`
}

// V2VersionReply defines model for v2VersionReply.
type V2VersionReply struct {
	MajorVer *int    `json:"major_ver,omitempty"`
	MinorVer *int    `json:"minor_ver,omitempty"`
	PatchVer *int    `json:"patch_ver,omitempty"`
	Version  *string `json:"version,omitempty"`
}

// V2ViralSequenceType defines model for v2ViralSequenceType.
type V2ViralSequenceType string

// V2VirusAnnotationFilter defines model for v2VirusAnnotationFilter.
type V2VirusAnnotationFilter struct {
	Accessions             *[]string  `json:"accessions,omitempty"`
	CompleteOnly           *bool      `json:"complete_only,omitempty"`
	GeoLocation            *string    `json:"geo_location,omitempty"`
	Host                   *string    `json:"host,omitempty"`
	PangolinClassification *string    `json:"pangolin_classification,omitempty"`
	RefseqOnly             *bool      `json:"refseq_only,omitempty"`
	ReleasedSince          *time.Time `json:"released_since,omitempty"`
	Taxon                  *string    `json:"taxon,omitempty"`
	UpdatedSince           *time.Time `json:"updated_since,omitempty"`
}

// V2VirusAnnotationReportRequest defines model for v2VirusAnnotationReportRequest.
type V2VirusAnnotationReportRequest struct {
	Filter      *V2VirusAnnotationFilter `json:"filter,omitempty"`
	PageSize    *int                     `json:"page_size,omitempty"`
	PageToken   *string                  `json:"page_token,omitempty"`
	TableFields *[]string                `json:"table_fields,omitempty"`
	TableFormat *string                  `json:"table_format,omitempty"`
}

// V2VirusAvailability defines model for v2VirusAvailability.
type V2VirusAvailability struct {
	InvalidAccessions *[]string `json:"invalid_accessions,omitempty"`
	Message           *string   `json:"message,omitempty"`
	ValidAccessions   *[]string `json:"valid_accessions,omitempty"`
}

// V2VirusAvailabilityRequest defines model for v2VirusAvailabilityRequest.
type V2VirusAvailabilityRequest struct {
	Accessions *[]string `json:"accessions,omitempty"`
}

// V2VirusDataReportRequest defines model for v2VirusDataReportRequest.
type V2VirusDataReportRequest struct {
	Filter          *V2VirusDatasetFilter                `json:"filter,omitempty"`
	PageSize        *int                                 `json:"page_size,omitempty"`
	PageToken       *string                              `json:"page_token,omitempty"`
	ReturnedContent *V2VirusDataReportRequestContentType `json:"returned_content,omitempty"`
	TableFields     *[]string                            `json:"table_fields,omitempty"`
	TableFormat     *string                              `json:"table_format,omitempty"`
}

// V2VirusDataReportRequestContentType defines model for v2VirusDataReportRequestContentType.
type V2VirusDataReportRequestContentType string

// V2VirusDatasetFilter defines model for v2VirusDatasetFilter.
type V2VirusDatasetFilter struct {
	Accessions             *[]string  `json:"accessions,omitempty"`
	AnnotatedOnly          *bool      `json:"annotated_only,omitempty"`
	CompleteOnly           *bool      `json:"complete_only,omitempty"`
	GeoLocation            *string    `json:"geo_location,omitempty"`
	Host                   *string    `json:"host,omitempty"`
	PangolinClassification *string    `json:"pangolin_classification,omitempty"`
	RefseqOnly             *bool      `json:"refseq_only,omitempty"`
	ReleasedSince          *time.Time `json:"released_since,omitempty"`
	Taxon                  *string    `json:"taxon,omitempty"`
	UpdatedSince           *time.Time `json:"updated_since,omitempty"`
}

// V2VirusDatasetReportType defines model for v2VirusDatasetReportType.
type V2VirusDatasetReportType string

// V2VirusDatasetRequest defines model for v2VirusDatasetRequest.
type V2VirusDatasetRequest struct {
	Accessions             *[]string                   `json:"accessions,omitempty"`
	AnnotatedOnly          *bool                       `json:"annotated_only,omitempty"`
	AuxReport              *[]V2VirusDatasetReportType `json:"aux_report,omitempty"`
	CompleteOnly           *bool                       `json:"complete_only,omitempty"`
	Format                 *V2TableFormat              `json:"format,omitempty"`
	GeoLocation            *string                     `json:"geo_location,omitempty"`
	Host                   *string                     `json:"host,omitempty"`
	IncludeSequence        *[]V2ViralSequenceType      `json:"include_sequence,omitempty"`
	PangolinClassification *string                     `json:"pangolin_classification,omitempty"`
	RefseqOnly             *bool                       `json:"refseq_only,omitempty"`
	ReleasedSince          *time.Time                  `json:"released_since,omitempty"`
	TableFields            *[]V2VirusTableField        `json:"table_fields,omitempty"`
	Taxon                  *string                     `json:"taxon,omitempty"`
	UpdatedSince           *time.Time                  `json:"updated_since,omitempty"`
	UsePsg                 *bool                       `json:"use_psg,omitempty"`
}

// V2VirusTableField defines model for v2VirusTableField.
type V2VirusTableField string

// V2reportsANIMatch defines model for v2reportsANIMatch.
type V2reportsANIMatch struct {
	Ani                  *float32                  `json:"ani,omitempty"`
	Assembly             *string                   `json:"assembly,omitempty"`
	AssemblyCoverage     *float32                  `json:"assembly_coverage,omitempty"`
	Category             *V2reportsANITypeCategory `json:"category,omitempty"`
	OrganismName         *string                   `json:"organism_name,omitempty"`
	TypeAssemblyCoverage *float32                  `json:"type_assembly_coverage,omitempty"`
}

// V2reportsANITypeCategory defines model for v2reportsANITypeCategory.
type V2reportsANITypeCategory string

// V2reportsAnnotation defines model for v2reportsAnnotation.
type V2reportsAnnotation struct {
	AnnotationName        *string                     `json:"annotation_name,omitempty"`
	AnnotationReleaseDate *string                     `json:"annotation_release_date,omitempty"`
	AssemblyAccession     *string                     `json:"assembly_accession,omitempty"`
	AssemblyName          *string                     `json:"assembly_name,omitempty"`
	GenomicLocations      *[]V2reportsGenomicLocation `json:"genomic_locations,omitempty"`
}

// V2reportsAnnotationInfo defines model for v2reportsAnnotationInfo.
type V2reportsAnnotationInfo struct {
	Busco           *V2reportsBuscoStat     `json:"busco,omitempty"`
	Method          *string                 `json:"method,omitempty"`
	Name            *string                 `json:"name,omitempty"`
	Pipeline        *string                 `json:"pipeline,omitempty"`
	Provider        *string                 `json:"provider,omitempty"`
	ReleaseDate     *string                 `json:"release_date,omitempty"`
	ReleaseVersion  *string                 `json:"release_version,omitempty"`
	ReportUrl       *string                 `json:"report_url,omitempty"`
	SoftwareVersion *string                 `json:"software_version,omitempty"`
	Stats           *V2reportsFeatureCounts `json:"stats,omitempty"`
	Status          *string                 `json:"status,omitempty"`
}

// V2reportsAssemblyDataReport defines model for v2reportsAssemblyDataReport.
type V2reportsAssemblyDataReport struct {
	Accession                 *string                             `json:"accession,omitempty"`
	AnnotationInfo            *V2reportsAnnotationInfo            `json:"annotation_info,omitempty"`
	AssemblyInfo              *V2reportsAssemblyInfo              `json:"assembly_info,omitempty"`
	AssemblyStats             *V2reportsAssemblyStats             `json:"assembly_stats,omitempty"`
	AverageNucleotideIdentity *V2reportsAverageNucleotideIdentity `json:"average_nucleotide_identity,omitempty"`
	CheckmInfo                *V2reportsCheckM                    `json:"checkm_info,omitempty"`
	CurrentAccession          *string                             `json:"current_accession,omitempty"`
	OrganelleInfo             *[]V2reportsOrganelleInfo           `json:"organelle_info,omitempty"`
	Organism                  *V2reportsOrganism                  `json:"organism,omitempty"`
	PairedAccession           *string                             `json:"paired_accession,omitempty"`
	SourceDatabase            *V2reportsSourceDatabase            `json:"source_database,omitempty"`
	TypeMaterial              *V2reportsTypeMaterial              `json:"type_material,omitempty"`
	WgsInfo                   *V2reportsWGSInfo                   `json:"wgs_info,omitempty"`
}

// V2reportsAssemblyDataReportPage defines model for v2reportsAssemblyDataReportPage.
type V2reportsAssemblyDataReportPage struct {
	FirstPage     *bool                          `json:"_first_page,omitempty"`
	ReportFields  *[]string                      `json:"_report_fields,omitempty"`
	ReportFormat  *string                        `json:"_report_format,omitempty"`
	ReportType    *string                        `json:"_report_type,omitempty"`
	ContentType   *V2reportsContentType          `json:"content_type,omitempty"`
	Messages      *[]V2reportsMessage            `json:"messages,omitempty"`
	NextPageToken *string                        `json:"next_page_token,omitempty"`
	Reports       *[]V2reportsAssemblyDataReport `json:"reports,omitempty"`
	TotalCount    *int                           `json:"total_count,omitempty"`
}

// V2reportsAssemblyInfo defines model for v2reportsAssemblyInfo.
type V2reportsAssemblyInfo struct {
	AssemblyLevel       *string                       `json:"assembly_level,omitempty"`
	AssemblyMethod      *string                       `json:"assembly_method,omitempty"`
	AssemblyName        *string                       `json:"assembly_name,omitempty"`
	AssemblyStatus      *V2reportsAssemblyStatus      `json:"assembly_status,omitempty"`
	AssemblyType        *string                       `json:"assembly_type,omitempty"`
	Atypical            *V2reportsAtypicalInfo        `json:"atypical,omitempty"`
	BioprojectAccession *string                       `json:"bioproject_accession,omitempty"`
	BioprojectLineage   *[]V2reportsBioProjectLineage `json:"bioproject_lineage,omitempty"`
	Biosample           *V2reportsBioSampleDescriptor `json:"biosample,omitempty"`
	BlastUrl            *string                       `json:"blast_url,omitempty"`
	Comments            *string                       `json:"comments,omitempty"`
	Description         *string                       `json:"description,omitempty"`
	DiploidRole         *V2reportsLinkedAssemblyType  `json:"diploid_role,omitempty"`
	GenomeNotes         *[]string                     `json:"genome_notes,omitempty"`
	LinkedAssemblies    *[]V2reportsLinkedAssembly    `json:"linked_assemblies,omitempty"`
	LinkedAssembly      *string                       `json:"linked_assembly,omitempty"`
	PairedAssembly      *V2reportsPairedAssembly      `json:"paired_assembly,omitempty"`
	RefseqCategory      *string                       `json:"refseq_category,omitempty"`
	ReleaseDate         *string                       `json:"release_date,omitempty"`
	SequencingTech      *string                       `json:"sequencing_tech,omitempty"`
	SubmissionDate      *string                       `json:"submission_date,omitempty"`
	Submitter           *string                       `json:"submitter,omitempty"`
	SuppressionReason   *string                       `json:"suppression_reason,omitempty"`
	Synonym             *string                       `json:"synonym,omitempty"`
}

// V2reportsAssemblyLevel defines model for v2reportsAssemblyLevel.
type V2reportsAssemblyLevel string

// V2reportsAssemblyRevision defines model for v2reportsAssemblyRevision.
type V2reportsAssemblyRevision struct {
	AssemblyLevel        *V2reportsAssemblyLevel `json:"assembly_level,omitempty"`
	AssemblyName         *string                 `json:"assembly_name,omitempty"`
	GenbankAccession     *string                 `json:"genbank_accession,omitempty"`
	RefseqAccession      *string                 `json:"refseq_accession,omitempty"`
	ReleaseDate          *string                 `json:"release_date,omitempty"`
	SequencingTechnology *string                 `json:"sequencing_technology,omitempty"`
	SubmissionDate       *string                 `json:"submission_date,omitempty"`
}

// V2reportsAssemblyStats defines model for v2reportsAssemblyStats.
type V2reportsAssemblyStats struct {
	ContigL50                  *int     `json:"contig_l50,omitempty"`
	ContigN50                  *int     `json:"contig_n50,omitempty"`
	GapsBetweenScaffoldsCount  *int     `json:"gaps_between_scaffolds_count,omitempty"`
	GcCount                    *string  `json:"gc_count,omitempty"`
	GcPercent                  *float32 `json:"gc_percent,omitempty"`
	GenomeCoverage             *string  `json:"genome_coverage,omitempty"`
	NumberOfComponentSequences *int     `json:"number_of_component_sequences,omitempty"`
	NumberOfContigs            *int     `json:"number_of_contigs,omitempty"`
	NumberOfOrganelles         *int     `json:"number_of_organelles,omitempty"`
	NumberOfScaffolds          *int     `json:"number_of_scaffolds,omitempty"`
	ScaffoldL50                *int     `json:"scaffold_l50,omitempty"`
	ScaffoldN50                *int     `json:"scaffold_n50,omitempty"`
	TotalNumberOfChromosomes   *int     `json:"total_number_of_chromosomes,omitempty"`
	TotalSequenceLength        *string  `json:"total_sequence_length,omitempty"`
	TotalUngappedLength        *string  `json:"total_ungapped_length,omitempty"`
}

// V2reportsAssemblyStatus defines model for v2reportsAssemblyStatus.
type V2reportsAssemblyStatus string

// V2reportsAtypicalInfo defines model for v2reportsAtypicalInfo.
type V2reportsAtypicalInfo struct {
	IsAtypical *bool     `json:"is_atypical,omitempty"`
	Warnings   *[]string `json:"warnings,omitempty"`
}

// V2reportsAverageNucleotideIdentity defines model for v2reportsAverageNucleotideIdentity.
type V2reportsAverageNucleotideIdentity struct {
	BestAniMatch        *V2reportsANIMatch                                     `json:"best_ani_match,omitempty"`
	Category            *V2reportsANITypeCategory                              `json:"category,omitempty"`
	Comment             *string                                                `json:"comment,omitempty"`
	MatchStatus         *V2reportsAverageNucleotideIdentityMatchStatus         `json:"match_status,omitempty"`
	SubmittedAniMatch   *V2reportsANIMatch                                     `json:"submitted_ani_match,omitempty"`
	SubmittedOrganism   *string                                                `json:"submitted_organism,omitempty"`
	SubmittedSpecies    *string                                                `json:"submitted_species,omitempty"`
	TaxonomyCheckStatus *V2reportsAverageNucleotideIdentityTaxonomyCheckStatus `json:"taxonomy_check_status,omitempty"`
}

// V2reportsAverageNucleotideIdentityMatchStatus defines model for v2reportsAverageNucleotideIdentityMatchStatus.
type V2reportsAverageNucleotideIdentityMatchStatus string

// V2reportsAverageNucleotideIdentityTaxonomyCheckStatus defines model for v2reportsAverageNucleotideIdentityTaxonomyCheckStatus.
type V2reportsAverageNucleotideIdentityTaxonomyCheckStatus string

// V2reportsBioProject defines model for v2reportsBioProject.
type V2reportsBioProject struct {
	Accession        *string   `json:"accession,omitempty"`
	ParentAccession  *string   `json:"parent_accession,omitempty"`
	ParentAccessions *[]string `json:"parent_accessions,omitempty"`
	Title            *string   `json:"title,omitempty"`
}

// V2reportsBioProjectLineage defines model for v2reportsBioProjectLineage.
type V2reportsBioProjectLineage struct {
	Bioprojects *[]V2reportsBioProject `json:"bioprojects,omitempty"`
}

// V2reportsBioSampleAttribute defines model for v2reportsBioSampleAttribute.
type V2reportsBioSampleAttribute struct {
	Name  *string `json:"name,omitempty"`
	Value *string `json:"value,omitempty"`
}

// V2reportsBioSampleContact defines model for v2reportsBioSampleContact.
type V2reportsBioSampleContact struct {
	Lab *string `json:"lab,omitempty"`
}

// V2reportsBioSampleDataReport defines model for v2reportsBioSampleDataReport.
type V2reportsBioSampleDataReport struct {
	Accession           *string                        `json:"accession,omitempty"`
	Age                 *string                        `json:"age,omitempty"`
	Attributes          *[]V2reportsBioSampleAttribute `json:"attributes,omitempty"`
	BiomaterialProvider *string                        `json:"biomaterial_provider,omitempty"`
	Bioprojects         *[]V2reportsBioProject         `json:"bioprojects,omitempty"`
	Breed               *string                        `json:"breed,omitempty"`
	CollectedBy         *string                        `json:"collected_by,omitempty"`
	CollectionDate      *string                        `json:"collection_date,omitempty"`
	Cultivar            *string                        `json:"cultivar,omitempty"`
	Description         *V2reportsBioSampleDescription `json:"description,omitempty"`
	DevStage            *string                        `json:"dev_stage,omitempty"`
	Ecotype             *string                        `json:"ecotype,omitempty"`
	GeoLocName          *string                        `json:"geo_loc_name,omitempty"`
	Host                *string                        `json:"host,omitempty"`
	HostDisease         *string                        `json:"host_disease,omitempty"`
	IdentifiedBy        *string                        `json:"identified_by,omitempty"`
	IfsacCategory       *string                        `json:"ifsac_category,omitempty"`
	Isolate             *string                        `json:"isolate,omitempty"`
	IsolateNameAlias    *string                        `json:"isolate_name_alias,omitempty"`
	IsolationSource     *string                        `json:"isolation_source,omitempty"`
	LastUpdated         *string                        `json:"last_updated,omitempty"`
	LatLon              *string                        `json:"lat_lon,omitempty"`
	Models              *[]string                      `json:"models,omitempty"`
	Owner               *V2reportsBioSampleOwner       `json:"owner,omitempty"`
	Package             *string                        `json:"package,omitempty"`
	ProjectName         *string                        `json:"project_name,omitempty"`
	PublicationDate     *string                        `json:"publication_date,omitempty"`
	SampleIds           *[]V2reportsBioSampleId        `json:"sample_ids,omitempty"`
	SampleName          *string                        `json:"sample_name,omitempty"`
	Serotype            *string                        `json:"serotype,omitempty"`
	Serovar             *string                        `json:"serovar,omitempty"`
	Sex                 *string                        `json:"sex,omitempty"`
	SourceType          *string                        `json:"source_type,omitempty"`
	Status              *V2reportsBioSampleStatus      `json:"status,omitempty"`
	Strain              *string                        `json:"strain,omitempty"`
	SubSpecies          *string                        `json:"sub_species,omitempty"`
	SubmissionDate      *string                        `json:"submission_date,omitempty"`
	Tissue              *string                        `json:"tissue,omitempty"`
}

// V2reportsBioSampleDataReportPage defines model for v2reportsBioSampleDataReportPage.
type V2reportsBioSampleDataReportPage struct {
	ReportFields  *[]string                       `json:"_report_fields,omitempty"`
	ReportFormat  *string                         `json:"_report_format,omitempty"`
	ReportType    *string                         `json:"_report_type,omitempty"`
	Messages      *[]V2reportsMessage             `json:"messages,omitempty"`
	NextPageToken *string                         `json:"next_page_token,omitempty"`
	Reports       *[]V2reportsBioSampleDataReport `json:"reports,omitempty"`
	TotalCount    *int                            `json:"total_count,omitempty"`
}

// V2reportsBioSampleDescription defines model for v2reportsBioSampleDescription.
type V2reportsBioSampleDescription struct {
	Comment  *string            `json:"comment,omitempty"`
	Organism *V2reportsOrganism `json:"organism,omitempty"`
	Title    *string            `json:"title,omitempty"`
}

// V2reportsBioSampleDescriptor defines model for v2reportsBioSampleDescriptor.
type V2reportsBioSampleDescriptor struct {
	Accession           *string                        `json:"accession,omitempty"`
	Age                 *string                        `json:"age,omitempty"`
	Attributes          *[]V2reportsBioSampleAttribute `json:"attributes,omitempty"`
	BiomaterialProvider *string                        `json:"biomaterial_provider,omitempty"`
	Bioprojects         *[]V2reportsBioProject         `json:"bioprojects,omitempty"`
	Breed               *string                        `json:"breed,omitempty"`
	CollectedBy         *string                        `json:"collected_by,omitempty"`
	CollectionDate      *string                        `json:"collection_date,omitempty"`
	Cultivar            *string                        `json:"cultivar,omitempty"`
	Description         *V2reportsBioSampleDescription `json:"description,omitempty"`
	DevStage            *string                        `json:"dev_stage,omitempty"`
	Ecotype             *string                        `json:"ecotype,omitempty"`
	GeoLocName          *string                        `json:"geo_loc_name,omitempty"`
	Host                *string                        `json:"host,omitempty"`
	HostDisease         *string                        `json:"host_disease,omitempty"`
	IdentifiedBy        *string                        `json:"identified_by,omitempty"`
	IfsacCategory       *string                        `json:"ifsac_category,omitempty"`
	Isolate             *string                        `json:"isolate,omitempty"`
	IsolateNameAlias    *string                        `json:"isolate_name_alias,omitempty"`
	IsolationSource     *string                        `json:"isolation_source,omitempty"`
	LastUpdated         *string                        `json:"last_updated,omitempty"`
	LatLon              *string                        `json:"lat_lon,omitempty"`
	Models              *[]string                      `json:"models,omitempty"`
	Owner               *V2reportsBioSampleOwner       `json:"owner,omitempty"`
	Package             *string                        `json:"package,omitempty"`
	ProjectName         *string                        `json:"project_name,omitempty"`
	PublicationDate     *string                        `json:"publication_date,omitempty"`
	SampleIds           *[]V2reportsBioSampleId        `json:"sample_ids,omitempty"`
	SampleName          *string                        `json:"sample_name,omitempty"`
	Serotype            *string                        `json:"serotype,omitempty"`
	Serovar             *string                        `json:"serovar,omitempty"`
	Sex                 *string                        `json:"sex,omitempty"`
	SourceType          *string                        `json:"source_type,omitempty"`
	Status              *V2reportsBioSampleStatus      `json:"status,omitempty"`
	Strain              *string                        `json:"strain,omitempty"`
	SubSpecies          *string                        `json:"sub_species,omitempty"`
	SubmissionDate      *string                        `json:"submission_date,omitempty"`
	Tissue              *string                        `json:"tissue,omitempty"`
}

// V2reportsBioSampleId defines model for v2reportsBioSampleId.
type V2reportsBioSampleId struct {
	Db    *string `json:"db,omitempty"`
	Label *string `json:"label,omitempty"`
	Value *string `json:"value,omitempty"`
}

// V2reportsBioSampleOwner defines model for v2reportsBioSampleOwner.
type V2reportsBioSampleOwner struct {
	Contacts *[]V2reportsBioSampleContact `json:"contacts,omitempty"`
	Name     *string                      `json:"name,omitempty"`
}

// V2reportsBioSampleStatus defines model for v2reportsBioSampleStatus.
type V2reportsBioSampleStatus struct {
	Status *string `json:"status,omitempty"`
	When   *string `json:"when,omitempty"`
}

// V2reportsBuscoStat defines model for v2reportsBuscoStat.
type V2reportsBuscoStat struct {
	BuscoLineage *string  `json:"busco_lineage,omitempty"`
	BuscoVer     *string  `json:"busco_ver,omitempty"`
	Complete     *float32 `json:"complete,omitempty"`
	Duplicated   *float32 `json:"duplicated,omitempty"`
	Fragmented   *float32 `json:"fragmented,omitempty"`
	Missing      *float32 `json:"missing,omitempty"`
	SingleCopy   *float32 `json:"single_copy,omitempty"`
	TotalCount   *string  `json:"total_count,omitempty"`
}

// V2reportsCheckM defines model for v2reportsCheckM.
type V2reportsCheckM struct {
	CheckmMarkerSet        *string  `json:"checkm_marker_set,omitempty"`
	CheckmMarkerSetRank    *string  `json:"checkm_marker_set_rank,omitempty"`
	CheckmSpeciesTaxId     *int     `json:"checkm_species_tax_id,omitempty"`
	CheckmVersion          *string  `json:"checkm_version,omitempty"`
	Completeness           *float32 `json:"completeness,omitempty"`
	CompletenessPercentile *float32 `json:"completeness_percentile,omitempty"`
	Contamination          *float32 `json:"contamination,omitempty"`
}

// V2reportsClassification defines model for v2reportsClassification.
type V2reportsClassification struct {
	Class        *V2reportsTaxData `json:"class,omitempty"`
	Family       *V2reportsTaxData `json:"family,omitempty"`
	Genus        *V2reportsTaxData `json:"genus,omitempty"`
	Kingdom      *V2reportsTaxData `json:"kingdom,omitempty"`
	Order        *V2reportsTaxData `json:"order,omitempty"`
	Phylum       *V2reportsTaxData `json:"phylum,omitempty"`
	Species      *V2reportsTaxData `json:"species,omitempty"`
	Superkingdom *V2reportsTaxData `json:"superkingdom,omitempty"`
}

// V2reportsCollectionType defines model for v2reportsCollectionType.
type V2reportsCollectionType string

// V2reportsConservedDomain defines model for v2reportsConservedDomain.
type V2reportsConservedDomain struct {
	Accession *string         `json:"accession,omitempty"`
	Name      *string         `json:"name,omitempty"`
	Range     *V2reportsRange `json:"range,omitempty"`
}

// V2reportsContentType defines model for v2reportsContentType.
type V2reportsContentType string

// V2reportsCountType defines model for v2reportsCountType.
type V2reportsCountType string

// V2reportsError defines model for v2reportsError.
type V2reportsError struct {
	AssemblyErrorCode  *V2reportsErrorAssemblyErrorCode  `json:"assembly_error_code,omitempty"`
	GeneErrorCode      *V2reportsErrorGeneErrorCode      `json:"gene_error_code,omitempty"`
	InvalidIdentifiers *[]string                         `json:"invalid_identifiers,omitempty"`
	Message            *string                           `json:"message,omitempty"`
	OrganelleErrorCode *V2reportsErrorOrganelleErrorCode `json:"organelle_error_code,omitempty"`
	Reason             *string                           `json:"reason,omitempty"`
	TaxonomyErrorCode  *V2reportsErrorTaxonomyErrorCode  `json:"taxonomy_error_code,omitempty"`
	VirusErrorCode     *V2reportsErrorVirusErrorCode     `json:"virus_error_code,omitempty"`
}

// V2reportsErrorAssemblyErrorCode defines model for v2reportsErrorAssemblyErrorCode.
type V2reportsErrorAssemblyErrorCode string

// V2reportsErrorGeneErrorCode defines model for v2reportsErrorGeneErrorCode.
type V2reportsErrorGeneErrorCode string

// V2reportsErrorOrganelleErrorCode defines model for v2reportsErrorOrganelleErrorCode.
type V2reportsErrorOrganelleErrorCode string

// V2reportsErrorTaxonomyErrorCode defines model for v2reportsErrorTaxonomyErrorCode.
type V2reportsErrorTaxonomyErrorCode string

// V2reportsErrorVirusErrorCode defines model for v2reportsErrorVirusErrorCode.
type V2reportsErrorVirusErrorCode string

// V2reportsFeatureCounts defines model for v2reportsFeatureCounts.
type V2reportsFeatureCounts struct {
	GeneCounts *V2reportsGeneCounts `json:"gene_counts,omitempty"`
}

// V2reportsGeneCounts defines model for v2reportsGeneCounts.
type V2reportsGeneCounts struct {
	NonCoding     *int `json:"non_coding,omitempty"`
	Other         *int `json:"other,omitempty"`
	ProteinCoding *int `json:"protein_coding,omitempty"`
	Pseudogene    *int `json:"pseudogene,omitempty"`
	Total         *int `json:"total,omitempty"`
}

// V2reportsGeneDataReportPage defines model for v2reportsGeneDataReportPage.
type V2reportsGeneDataReportPage struct {
	FirstPage     *bool                       `json:"_first_page,omitempty"`
	ReportFields  *[]string                   `json:"_report_fields,omitempty"`
	ReportFormat  *string                     `json:"_report_format,omitempty"`
	ReportType    *string                     `json:"_report_type,omitempty"`
	Messages      *[]V2reportsMessage         `json:"messages,omitempty"`
	NextPageToken *string                     `json:"next_page_token,omitempty"`
	Reports       *[]V2reportsGeneReportMatch `json:"reports,omitempty"`
	TotalCount    *int                        `json:"total_count,omitempty"`
}

// V2reportsGeneDescriptor defines model for v2reportsGeneDescriptor.
type V2reportsGeneDescriptor struct {
	Annotations           *[]V2reportsAnnotation          `json:"annotations,omitempty"`
	Chromosomes           *[]string                       `json:"chromosomes,omitempty"`
	CommonName            *string                         `json:"common_name,omitempty"`
	Description           *string                         `json:"description,omitempty"`
	EnsemblGeneIds        *[]string                       `json:"ensembl_gene_ids,omitempty"`
	GeneGroups            *[]V2reportsGeneGroup           `json:"gene_groups,omitempty"`
	GeneId                *string                         `json:"gene_id,omitempty"`
	GenomicRegions        *[]V2reportsGenomicRegion       `json:"genomic_regions,omitempty"`
	NomenclatureAuthority *V2reportsNomenclatureAuthority `json:"nomenclature_authority,omitempty"`
	OmimIds               *[]string                       `json:"omim_ids,omitempty"`
	Orientation           *V2reportsOrientation           `json:"orientation,omitempty"`
	ProteinCount          *int                            `json:"protein_count,omitempty"`
	ReferenceStandards    *[]V2reportsGenomicRegion       `json:"reference_standards,omitempty"`
	ReplacedGeneId        *string                         `json:"replaced_gene_id,omitempty"`
	RnaType               *V2reportsRnaType               `json:"rna_type,omitempty"`
	SwissProtAccessions   *[]string                       `json:"swiss_prot_accessions,omitempty"`
	Symbol                *string                         `json:"symbol,omitempty"`
	Synonyms              *[]string                       `json:"synonyms,omitempty"`
	TaxId                 *string                         `json:"tax_id,omitempty"`
	Taxname               *string                         `json:"taxname,omitempty"`
	TranscriptCount       *int                            `json:"transcript_count,omitempty"`
	TranscriptTypeCounts  *[]V2reportsTranscriptTypeCount `json:"transcript_type_counts,omitempty"`
	Type                  *V2reportsGeneType              `json:"type,omitempty"`
}

// V2reportsGeneGroup defines model for v2reportsGeneGroup.
type V2reportsGeneGroup struct {
	Id     *string `json:"id,omitempty"`
	Method *string `json:"method,omitempty"`
}

// V2reportsGeneReportMatch defines model for v2reportsGeneReportMatch.
type V2reportsGeneReportMatch struct {
	Errors   *[]V2reportsError           `json:"errors,omitempty"`
	Gene     *V2reportsGeneDescriptor    `json:"gene,omitempty"`
	Product  *V2reportsProductDescriptor `json:"product,omitempty"`
	Query    *[]string                   `json:"query,omitempty"`
	Warning  *V2reportsWarning           `json:"warning,omitempty"`
	Warnings *[]V2reportsWarning         `json:"warnings,omitempty"`
}

// V2reportsGeneType defines model for v2reportsGeneType.
type V2reportsGeneType string

// V2reportsGenomeAnnotation defines model for v2reportsGenomeAnnotation.
type V2reportsGenomeAnnotation struct {
	Annotations         *[]V2reportsAnnotation    `json:"annotations,omitempty"`
	Chromosomes         *[]string                 `json:"chromosomes,omitempty"`
	CommonName          *string                   `json:"common_name,omitempty"`
	Description         *string                   `json:"description,omitempty"`
	EnsemblGeneIds      *[]string                 `json:"ensembl_gene_ids,omitempty"`
	GeneId              *string                   `json:"gene_id,omitempty"`
	GeneType            *string                   `json:"gene_type,omitempty"`
	GenomicRegions      *[]V2reportsGenomicRegion `json:"genomic_regions,omitempty"`
	LocusTag            *string                   `json:"locus_tag,omitempty"`
	Name                *string                   `json:"name,omitempty"`
	OmimIds             *[]string                 `json:"omim_ids,omitempty"`
	Orientation         *V2reportsOrientation     `json:"orientation,omitempty"`
	Proteins            *[]V2reportsProtein       `json:"proteins,omitempty"`
	ReferenceStandards  *[]V2reportsGenomicRegion `json:"reference_standards,omitempty"`
	RnaType             *V2reportsRnaType         `json:"rna_type,omitempty"`
	SwissProtAccessions *[]string                 `json:"swiss_prot_accessions,omitempty"`
	Symbol              *string                   `json:"symbol,omitempty"`
	Synonyms            *[]string                 `json:"synonyms,omitempty"`
	TaxId               *string                   `json:"tax_id,omitempty"`
	Taxname             *string                   `json:"taxname,omitempty"`
	Transcripts         *[]V2reportsTranscript    `json:"transcripts,omitempty"`
	Type                *V2reportsGeneType        `json:"type,omitempty"`
}

// V2reportsGenomeAnnotationReportMatch defines model for v2reportsGenomeAnnotationReportMatch.
type V2reportsGenomeAnnotationReportMatch struct {
	Annotation *V2reportsGenomeAnnotation `json:"annotation,omitempty"`
	Errors     *[]V2reportsError          `json:"errors,omitempty"`
	Query      *[]string                  `json:"query,omitempty"`
	RowId      *string                    `json:"row_id,omitempty"`
	Warning    *V2reportsWarning          `json:"warning,omitempty"`
}

// V2reportsGenomeAnnotationReportPage defines model for v2reportsGenomeAnnotationReportPage.
type V2reportsGenomeAnnotationReportPage struct {
	FirstPage     *bool                                   `json:"_first_page,omitempty"`
	ReportFields  *[]string                               `json:"_report_fields,omitempty"`
	ReportFormat  *string                                 `json:"_report_format,omitempty"`
	ReportType    *string                                 `json:"_report_type,omitempty"`
	Messages      *[]V2reportsMessage                     `json:"messages,omitempty"`
	NextPageToken *string                                 `json:"next_page_token,omitempty"`
	Reports       *[]V2reportsGenomeAnnotationReportMatch `json:"reports,omitempty"`
	TotalCount    *int                                    `json:"total_count,omitempty"`
}

// V2reportsGenomicLocation defines model for v2reportsGenomicLocation.
type V2reportsGenomicLocation struct {
	Exons                   *[]V2reportsRange `json:"exons,omitempty"`
	GenomicAccessionVersion *string           `json:"genomic_accession_version,omitempty"`
	GenomicRange            *V2reportsRange   `json:"genomic_range,omitempty"`
	SequenceName            *string           `json:"sequence_name,omitempty"`
}

// V2reportsGenomicRegion defines model for v2reportsGenomicRegion.
type V2reportsGenomicRegion struct {
	GeneRange *V2reportsSeqRangeSet                    `json:"gene_range,omitempty"`
	Type      *V2reportsGenomicRegionGenomicRegionType `json:"type,omitempty"`
}

// V2reportsGenomicRegionGenomicRegionType defines model for v2reportsGenomicRegionGenomicRegionType.
type V2reportsGenomicRegionGenomicRegionType string

// V2reportsInfraspecificNames defines model for v2reportsInfraspecificNames.
type V2reportsInfraspecificNames struct {
	Breed    *string `json:"breed,omitempty"`
	Cultivar *string `json:"cultivar,omitempty"`
	Ecotype  *string `json:"ecotype,omitempty"`
	Isolate  *string `json:"isolate,omitempty"`
	Sex      *string `json:"sex,omitempty"`
	Strain   *string `json:"strain,omitempty"`
}

// V2reportsIsolate defines model for v2reportsIsolate.
type V2reportsIsolate struct {
	CollectionDate *string `json:"collection_date,omitempty"`
	Name           *string `json:"name,omitempty"`
	Source         *string `json:"source,omitempty"`
}

// V2reportsLineageOrganism defines model for v2reportsLineageOrganism.
type V2reportsLineageOrganism struct {
	Name  *string `json:"name,omitempty"`
	TaxId *int    `json:"tax_id,omitempty"`
}

// V2reportsLinkedAssembly defines model for v2reportsLinkedAssembly.
type V2reportsLinkedAssembly struct {
	AssemblyType   *V2reportsLinkedAssemblyType `json:"assembly_type,omitempty"`
	LinkedAssembly *string                      `json:"linked_assembly,omitempty"`
}

// V2reportsLinkedAssemblyType defines model for v2reportsLinkedAssemblyType.
type V2reportsLinkedAssemblyType string

// V2reportsMaturePeptide defines model for v2reportsMaturePeptide.
type V2reportsMaturePeptide struct {
	AccessionVersion *string `json:"accession_version,omitempty"`
	Length           *int    `json:"length,omitempty"`
	Name             *string `json:"name,omitempty"`
}

// V2reportsMessage defines model for v2reportsMessage.
type V2reportsMessage struct {
	Error   *V2reportsError   `json:"error,omitempty"`
	Warning *V2reportsWarning `json:"warning,omitempty"`
}

// V2reportsNameAndAuthority defines model for v2reportsNameAndAuthority.
type V2reportsNameAndAuthority struct {
	Authority           *string                                 `json:"authority,omitempty"`
	Basionym            *V2reportsNameAndAuthority              `json:"basionym,omitempty"`
	CuratorSynonym      *string                                 `json:"curator_synonym,omitempty"`
	Formal              *bool                                   `json:"formal,omitempty"`
	HeterotypicSynonyms *[]V2reportsNameAndAuthority            `json:"heterotypic_synonyms,omitempty"`
	HomotypicSynonyms   *[]V2reportsNameAndAuthority            `json:"homotypic_synonyms,omitempty"`
	InformalNames       *[]string                               `json:"informal_names,omitempty"`
	Name                *string                                 `json:"name,omitempty"`
	Notes               *[]V2reportsNameAndAuthorityNote        `json:"notes,omitempty"`
	OtherSynonyms       *[]V2reportsNameAndAuthority            `json:"other_synonyms,omitempty"`
	Publications        *[]V2reportsNameAndAuthorityPublication `json:"publications,omitempty"`
	TypeStrains         *[]V2reportsTaxonomyTypeMaterial        `json:"type_strains,omitempty"`
}

// V2reportsNameAndAuthorityNote defines model for v2reportsNameAndAuthorityNote.
type V2reportsNameAndAuthorityNote struct {
	Name           *string                                  `json:"name,omitempty"`
	Note           *string                                  `json:"note,omitempty"`
	NoteClassifier *V2reportsNameAndAuthorityNoteClassifier `json:"note_classifier,omitempty"`
}

// V2reportsNameAndAuthorityNoteClassifier defines model for v2reportsNameAndAuthorityNoteClassifier.
type V2reportsNameAndAuthorityNoteClassifier string

// V2reportsNameAndAuthorityPublication defines model for v2reportsNameAndAuthorityPublication.
type V2reportsNameAndAuthorityPublication struct {
	Citation *string `json:"citation,omitempty"`
	Name     *string `json:"name,omitempty"`
}

// V2reportsNomenclatureAuthority defines model for v2reportsNomenclatureAuthority.
type V2reportsNomenclatureAuthority struct {
	Authority  *string `json:"authority,omitempty"`
	Identifier *string `json:"identifier,omitempty"`
}

// V2reportsOrganelle defines model for v2reportsOrganelle.
type V2reportsOrganelle struct {
	Bioprojects *[]V2reportsBioProject        `json:"bioprojects,omitempty"`
	Biosample   *V2reportsOrganelleBiosample  `json:"biosample,omitempty"`
	Description *V2reportsOrganelleType       `json:"description,omitempty"`
	Genbank     *V2reportsSequenceInformation `json:"genbank,omitempty"`
	GeneCount   *int                          `json:"gene_count,omitempty"`
	GeneCounts  *V2reportsOrganelleGeneCounts `json:"gene_counts,omitempty"`
	Length      *int                          `json:"length,omitempty"`
	Organism    *V2reportsOrganism            `json:"organism,omitempty"`
	Refseq      *V2reportsSequenceInformation `json:"refseq,omitempty"`
	Topology    *V2reportsOrganelleTopology   `json:"topology,omitempty"`
}

// V2reportsOrganelleBiosample defines model for v2reportsOrganelleBiosample.
type V2reportsOrganelleBiosample struct {
	Accession *string `json:"accession,omitempty"`
}

// V2reportsOrganelleDataReports defines model for v2reportsOrganelleDataReports.
type V2reportsOrganelleDataReports struct {
	FirstPage     *bool                 `json:"_first_page,omitempty"`
	ReportFields  *[]string             `json:"_report_fields,omitempty"`
	ReportFormat  *string               `json:"_report_format,omitempty"`
	ReportType    *string               `json:"_report_type,omitempty"`
	Messages      *[]V2reportsMessage   `json:"messages,omitempty"`
	NextPageToken *string               `json:"next_page_token,omitempty"`
	Reports       *[]V2reportsOrganelle `json:"reports,omitempty"`
	TotalCount    *int                  `json:"total_count,omitempty"`
}

// V2reportsOrganelleGeneCounts defines model for v2reportsOrganelleGeneCounts.
type V2reportsOrganelleGeneCounts struct {
	Lncrna        *int `json:"lncrna,omitempty"`
	ProteinCoding *int `json:"protein_coding,omitempty"`
	Rrna          *int `json:"rrna,omitempty"`
	Total         *int `json:"total,omitempty"`
	Trna          *int `json:"trna,omitempty"`
}

// V2reportsOrganelleInfo defines model for v2reportsOrganelleInfo.
type V2reportsOrganelleInfo struct {
	AssemblyName      *string   `json:"assembly_name,omitempty"`
	Bioproject        *[]string `json:"bioproject,omitempty"`
	Description       *string   `json:"description,omitempty"`
	InfraspecificName *string   `json:"infraspecific_name,omitempty"`
	Submitter         *string   `json:"submitter,omitempty"`
	TotalSeqLength    *string   `json:"total_seq_length,omitempty"`
}

// V2reportsOrganelleTopology defines model for v2reportsOrganelleTopology.
type V2reportsOrganelleTopology string

// V2reportsOrganelleType defines model for v2reportsOrganelleType.
type V2reportsOrganelleType string

// V2reportsOrganism defines model for v2reportsOrganism.
type V2reportsOrganism struct {
	CommonName             *string                      `json:"common_name,omitempty"`
	InfraspecificNames     *V2reportsInfraspecificNames `json:"infraspecific_names,omitempty"`
	Lineage                *[]V2reportsLineageOrganism  `json:"lineage,omitempty"`
	OrganismName           *string                      `json:"organism_name,omitempty"`
	PangolinClassification *string                      `json:"pangolin_classification,omitempty"`
	SciName                *string                      `json:"sci_name,omitempty"`
	Strain                 *string                      `json:"strain,omitempty"`
	TaxId                  *int                         `json:"tax_id,omitempty"`
}

// V2reportsOrientation defines model for v2reportsOrientation.
type V2reportsOrientation string

// V2reportsPairedAssembly defines model for v2reportsPairedAssembly.
type V2reportsPairedAssembly struct {
	Accession      *string                  `json:"accession,omitempty"`
	AnnotationName *string                  `json:"annotation_name,omitempty"`
	Changed        *string                  `json:"changed,omitempty"`
	ManualDiff     *string                  `json:"manual_diff,omitempty"`
	OnlyGenbank    *string                  `json:"only_genbank,omitempty"`
	OnlyRefseq     *string                  `json:"only_refseq,omitempty"`
	Status         *V2reportsAssemblyStatus `json:"status,omitempty"`
}

// V2reportsProductDescriptor defines model for v2reportsProductDescriptor.
type V2reportsProductDescriptor struct {
	CommonName           *string                         `json:"common_name,omitempty"`
	Description          *string                         `json:"description,omitempty"`
	GeneId               *string                         `json:"gene_id,omitempty"`
	ProteinCount         *int                            `json:"protein_count,omitempty"`
	RnaType              *V2reportsRnaType               `json:"rna_type,omitempty"`
	Symbol               *string                         `json:"symbol,omitempty"`
	TaxId                *string                         `json:"tax_id,omitempty"`
	Taxname              *string                         `json:"taxname,omitempty"`
	TranscriptCount      *int                            `json:"transcript_count,omitempty"`
	TranscriptTypeCounts *[]V2reportsTranscriptTypeCount `json:"transcript_type_counts,omitempty"`
	Transcripts          *[]V2reportsTranscript          `json:"transcripts,omitempty"`
	Type                 *V2reportsGeneType              `json:"type,omitempty"`
}

// V2reportsProtein defines model for v2reportsProtein.
type V2reportsProtein struct {
	AccessionVersion *string                   `json:"accession_version,omitempty"`
	EnsemblProtein   *string                   `json:"ensembl_protein,omitempty"`
	IsoformName      *string                   `json:"isoform_name,omitempty"`
	Length           *int                      `json:"length,omitempty"`
	MaturePeptides   *[]V2reportsMaturePeptide `json:"mature_peptides,omitempty"`
	Name             *string                   `json:"name,omitempty"`
}

// V2reportsPurposeOfSampling defines model for v2reportsPurposeOfSampling.
type V2reportsPurposeOfSampling string

// V2reportsRange defines model for v2reportsRange.
type V2reportsRange struct {
	Begin             *string               `json:"begin,omitempty"`
	End               *string               `json:"end,omitempty"`
	Order             *int                  `json:"order,omitempty"`
	Orientation       *V2reportsOrientation `json:"orientation,omitempty"`
	RibosomalSlippage *int                  `json:"ribosomal_slippage,omitempty"`
}

// V2reportsRankType defines model for v2reportsRankType.
type V2reportsRankType string

// V2reportsRnaType defines model for v2reportsRnaType.
type V2reportsRnaType string

// V2reportsSeqRangeSet defines model for v2reportsSeqRangeSet.
type V2reportsSeqRangeSet struct {
	AccessionVersion *string           `json:"accession_version,omitempty"`
	Range            *[]V2reportsRange `json:"range,omitempty"`
}

// V2reportsSeqRangeSetFasta defines model for v2reportsSeqRangeSetFasta.
type V2reportsSeqRangeSetFasta struct {
	AccessionVersion *string           `json:"accession_version,omitempty"`
	Range            *[]V2reportsRange `json:"range,omitempty"`
	SeqId            *string           `json:"seq_id,omitempty"`
	SequenceHash     *string           `json:"sequence_hash,omitempty"`
	Title            *string           `json:"title,omitempty"`
}

// V2reportsSequenceInfo defines model for v2reportsSequenceInfo.
type V2reportsSequenceInfo struct {
	AssemblyAccession            *string  `json:"assembly_accession,omitempty"`
	AssemblyUnit                 *string  `json:"assembly_unit,omitempty"`
	AssemblyUnplacedCount        *int     `json:"assembly_unplaced_count,omitempty"`
	AssignedMoleculeLocationType *string  `json:"assigned_molecule_location_type,omitempty"`
	ChrName                      *string  `json:"chr_name,omitempty"`
	GcCount                      *string  `json:"gc_count,omitempty"`
	GcPercent                    *float32 `json:"gc_percent,omitempty"`
	GenbankAccession             *string  `json:"genbank_accession,omitempty"`
	Length                       *int     `json:"length,omitempty"`
	RefseqAccession              *string  `json:"refseq_accession,omitempty"`
	Role                         *string  `json:"role,omitempty"`
	SequenceName                 *string  `json:"sequence_name,omitempty"`
	SortOrder                    *int     `json:"sort_order,omitempty"`
	UcscStyleName                *string  `json:"ucsc_style_name,omitempty"`
	UnlocalizedCount             *int     `json:"unlocalized_count,omitempty"`
}

// V2reportsSequenceInformation defines model for v2reportsSequenceInformation.
type V2reportsSequenceInformation struct {
	Accession      *string `json:"accession,omitempty"`
	SubmissionDate *string `json:"submission_date,omitempty"`
	Submitter      *string `json:"submitter,omitempty"`
}

// V2reportsSourceDatabase defines model for v2reportsSourceDatabase.
type V2reportsSourceDatabase string

// V2reportsTaxData defines model for v2reportsTaxData.
type V2reportsTaxData struct {
	Id   *int    `json:"id,omitempty"`
	Name *string `json:"name,omitempty"`
}

// V2reportsTaxonomyDataReportPage defines model for v2reportsTaxonomyDataReportPage.
type V2reportsTaxonomyDataReportPage struct {
	FirstPage     *bool                           `json:"_first_page,omitempty"`
	ReportFields  *[]string                       `json:"_report_fields,omitempty"`
	ReportFormat  *string                         `json:"_report_format,omitempty"`
	ReportType    *string                         `json:"_report_type,omitempty"`
	Messages      *[]V2reportsMessage             `json:"messages,omitempty"`
	NextPageToken *string                         `json:"next_page_token,omitempty"`
	Reports       *[]V2reportsTaxonomyReportMatch `json:"reports,omitempty"`
	TotalCount    *int                            `json:"total_count,omitempty"`
}

// V2reportsTaxonomyNamesDataReportPage defines model for v2reportsTaxonomyNamesDataReportPage.
type V2reportsTaxonomyNamesDataReportPage struct {
	FirstPage     *bool                                `json:"_first_page,omitempty"`
	ReportFields  *[]string                            `json:"_report_fields,omitempty"`
	ReportFormat  *string                              `json:"_report_format,omitempty"`
	ReportType    *string                              `json:"_report_type,omitempty"`
	Messages      *[]V2reportsMessage                  `json:"messages,omitempty"`
	NextPageToken *string                              `json:"next_page_token,omitempty"`
	Reports       *[]V2reportsTaxonomyNamesReportMatch `json:"reports,omitempty"`
	TotalCount    *int                                 `json:"total_count,omitempty"`
}

// V2reportsTaxonomyNamesDescriptor defines model for v2reportsTaxonomyNamesDescriptor.
type V2reportsTaxonomyNamesDescriptor struct {
	Citations                     *[]V2reportsTaxonomyNamesDescriptorCitation `json:"citations,omitempty"`
	CuratorCommonName             *string                                     `json:"curator_common_name,omitempty"`
	CurrentScientificName         *V2reportsNameAndAuthority                  `json:"current_scientific_name,omitempty"`
	CurrentScientificNameIsFormal *bool                                       `json:"current_scientific_name_is_formal,omitempty"`
	GeneralNotes                  *[]string                                   `json:"general_notes,omitempty"`
	GroupName                     *string                                     `json:"group_name,omitempty"`
	LinksFromType                 *string                                     `json:"links_from_type,omitempty"`
	OtherCommonNames              *[]string                                   `json:"other_common_names,omitempty"`
	Rank                          *V2reportsRankType                          `json:"rank,omitempty"`
	TaxId                         *string                                     `json:"tax_id,omitempty"`
}

// V2reportsTaxonomyNamesDescriptorCitation defines model for v2reportsTaxonomyNamesDescriptorCitation.
type V2reportsTaxonomyNamesDescriptorCitation struct {
	FullCitation  *string `json:"full_citation,omitempty"`
	Pmid          *string `json:"pmid,omitempty"`
	ShortCitation *string `json:"short_citation,omitempty"`
}

// V2reportsTaxonomyNamesReportMatch defines model for v2reportsTaxonomyNamesReportMatch.
type V2reportsTaxonomyNamesReportMatch struct {
	Errors   *[]V2reportsError                 `json:"errors,omitempty"`
	Query    *[]string                         `json:"query,omitempty"`
	Taxonomy *V2reportsTaxonomyNamesDescriptor `json:"taxonomy,omitempty"`
	Warning  *V2reportsWarning                 `json:"warning,omitempty"`
}

// V2reportsTaxonomyNode defines model for v2reportsTaxonomyNode.
type V2reportsTaxonomyNode struct {
	Basionym              *V2reportsNameAndAuthority          `json:"basionym,omitempty"`
	Children              *[]int                              `json:"children,omitempty"`
	Classification        *V2reportsClassification            `json:"classification,omitempty"`
	Counts                *[]V2reportsTaxonomyNodeCountByType `json:"counts,omitempty"`
	CuratorCommonName     *string                             `json:"curator_common_name,omitempty"`
	CurrentScientificName *V2reportsNameAndAuthority          `json:"current_scientific_name,omitempty"`
	GenomicMoltype        *string                             `json:"genomic_moltype,omitempty"`
	GroupName             *string                             `json:"group_name,omitempty"`
	HasTypeMaterial       *bool                               `json:"has_type_material,omitempty"`
	Parents               *[]int                              `json:"parents,omitempty"`
	Rank                  *V2reportsRankType                  `json:"rank,omitempty"`
	TaxId                 *int                                `json:"tax_id,omitempty"`
}

// V2reportsTaxonomyNodeCountByType defines model for v2reportsTaxonomyNodeCountByType.
type V2reportsTaxonomyNodeCountByType struct {
	Count *int                `json:"count,omitempty"`
	Type  *V2reportsCountType `json:"type,omitempty"`
}

// V2reportsTaxonomyReportMatch defines model for v2reportsTaxonomyReportMatch.
type V2reportsTaxonomyReportMatch struct {
	Errors   *[]V2reportsError      `json:"errors,omitempty"`
	Query    *[]string              `json:"query,omitempty"`
	Taxonomy *V2reportsTaxonomyNode `json:"taxonomy,omitempty"`
	Warning  *V2reportsWarning      `json:"warning,omitempty"`
}

// V2reportsTaxonomyTypeMaterial defines model for v2reportsTaxonomyTypeMaterial.
type V2reportsTaxonomyTypeMaterial struct {
	BioCollectionId   *string                    `json:"bio_collection_id,omitempty"`
	BioCollectionName *string                    `json:"bio_collection_name,omitempty"`
	CollectionType    *[]V2reportsCollectionType `json:"collection_type,omitempty"`
	TypeClass         *string                    `json:"type_class,omitempty"`
	TypeStrainId      *string                    `json:"type_strain_id,omitempty"`
	TypeStrainName    *string                    `json:"type_strain_name,omitempty"`
}

// V2reportsTranscript defines model for v2reportsTranscript.
type V2reportsTranscript struct {
	AccessionVersion  *string                            `json:"accession_version,omitempty"`
	Cds               *V2reportsSeqRangeSet              `json:"cds,omitempty"`
	EnsemblTranscript *string                            `json:"ensembl_transcript,omitempty"`
	GenomicLocations  *[]V2reportsGenomicLocation        `json:"genomic_locations,omitempty"`
	Length            *int                               `json:"length,omitempty"`
	Name              *string                            `json:"name,omitempty"`
	Protein           *V2reportsProtein                  `json:"protein,omitempty"`
	Type              *V2reportsTranscriptTranscriptType `json:"type,omitempty"`
}

// V2reportsTranscriptTranscriptType defines model for v2reportsTranscriptTranscriptType.
type V2reportsTranscriptTranscriptType string

// V2reportsTranscriptTypeCount defines model for v2reportsTranscriptTypeCount.
type V2reportsTranscriptTypeCount struct {
	Count *int                               `json:"count,omitempty"`
	Type  *V2reportsTranscriptTranscriptType `json:"type,omitempty"`
}

// V2reportsTypeMaterial defines model for v2reportsTypeMaterial.
type V2reportsTypeMaterial struct {
	TypeDisplayText *string `json:"type_display_text,omitempty"`
	TypeLabel       *string `json:"type_label,omitempty"`
}

// V2reportsVirusAnnotationReport defines model for v2reportsVirusAnnotationReport.
type V2reportsVirusAnnotationReport struct {
	Accession   *string               `json:"accession,omitempty"`
	Genes       *[]V2reportsVirusGene `json:"genes,omitempty"`
	IsolateName *string               `json:"isolate_name,omitempty"`
}

// V2reportsVirusAnnotationReportPage defines model for v2reportsVirusAnnotationReportPage.
type V2reportsVirusAnnotationReportPage struct {
	FirstPage     *bool                             `json:"_first_page,omitempty"`
	ReportFields  *[]string                         `json:"_report_fields,omitempty"`
	ReportFormat  *string                           `json:"_report_format,omitempty"`
	ReportType    *string                           `json:"_report_type,omitempty"`
	NextPageToken *string                           `json:"next_page_token,omitempty"`
	Reports       *[]V2reportsVirusAnnotationReport `json:"reports,omitempty"`
	TotalCount    *int                              `json:"total_count,omitempty"`
}

// V2reportsVirusAssembly defines model for v2reportsVirusAssembly.
type V2reportsVirusAssembly struct {
	Accession              *string                                   `json:"accession,omitempty"`
	Bioprojects            *[]string                                 `json:"bioprojects,omitempty"`
	Biosample              *string                                   `json:"biosample,omitempty"`
	Completeness           *V2reportsVirusAssemblyCompleteness       `json:"completeness,omitempty"`
	GeneCount              *int                                      `json:"gene_count,omitempty"`
	Host                   *V2reportsOrganism                        `json:"host,omitempty"`
	IsAnnotated            *bool                                     `json:"is_annotated,omitempty"`
	IsComplete             *bool                                     `json:"is_complete,omitempty"`
	IsLabHost              *bool                                     `json:"is_lab_host,omitempty"`
	IsVaccineStrain        *bool                                     `json:"is_vaccine_strain,omitempty"`
	Isolate                *V2reportsIsolate                         `json:"isolate,omitempty"`
	LabHost                *string                                   `json:"lab_host,omitempty"`
	Length                 *int                                      `json:"length,omitempty"`
	Location               *V2reportsVirusAssemblyCollectionLocation `json:"location,omitempty"`
	MaturePeptideCount     *int                                      `json:"mature_peptide_count,omitempty"`
	MolType                *string                                   `json:"mol_type,omitempty"`
	Nucleotide             *V2reportsSeqRangeSetFasta                `json:"nucleotide,omitempty"`
	NucleotideCompleteness *string                                   `json:"nucleotide_completeness,omitempty"`
	ProteinCount           *int                                      `json:"protein_count,omitempty"`
	PurposeOfSampling      *V2reportsPurposeOfSampling               `json:"purpose_of_sampling,omitempty"`
	ReleaseDate            *string                                   `json:"release_date,omitempty"`
	SourceDatabase         *string                                   `json:"source_database,omitempty"`
	SraAccessions          *[]string                                 `json:"sra_accessions,omitempty"`
	Submitter              *V2reportsVirusAssemblySubmitterInfo      `json:"submitter,omitempty"`
	UpdateDate             *string                                   `json:"update_date,omitempty"`
	Virus                  *V2reportsOrganism                        `json:"virus,omitempty"`
}

// V2reportsVirusAssemblyCollectionLocation defines model for v2reportsVirusAssemblyCollectionLocation.
type V2reportsVirusAssemblyCollectionLocation struct {
	GeographicLocation *string `json:"geographic_location,omitempty"`
	GeographicRegion   *string `json:"geographic_region,omitempty"`
}

// V2reportsVirusAssemblyCompleteness defines model for v2reportsVirusAssemblyCompleteness.
type V2reportsVirusAssemblyCompleteness string

// V2reportsVirusAssemblySubmitterInfo defines model for v2reportsVirusAssemblySubmitterInfo.
type V2reportsVirusAssemblySubmitterInfo struct {
	Affiliation *string   `json:"affiliation,omitempty"`
	Country     *string   `json:"country,omitempty"`
	Names       *[]string `json:"names,omitempty"`
}

// V2reportsVirusDataReportPage defines model for v2reportsVirusDataReportPage.
type V2reportsVirusDataReportPage struct {
	FirstPage     *bool                     `json:"_first_page,omitempty"`
	ReportFields  *[]string                 `json:"_report_fields,omitempty"`
	ReportFormat  *string                   `json:"_report_format,omitempty"`
	ReportType    *string                   `json:"_report_type,omitempty"`
	NextPageToken *string                   `json:"next_page_token,omitempty"`
	Reports       *[]V2reportsVirusAssembly `json:"reports,omitempty"`
	TotalCount    *int                      `json:"total_count,omitempty"`
}

// V2reportsVirusGene defines model for v2reportsVirusGene.
type V2reportsVirusGene struct {
	Cds        *[]V2reportsVirusPeptide   `json:"cds,omitempty"`
	GeneId     *int                       `json:"gene_id,omitempty"`
	Name       *string                    `json:"name,omitempty"`
	Nucleotide *V2reportsSeqRangeSetFasta `json:"nucleotide,omitempty"`
}

// V2reportsVirusPeptide defines model for v2reportsVirusPeptide.
type V2reportsVirusPeptide struct {
	Accession           *string                                        `json:"accession,omitempty"`
	Cdd                 *[]V2reportsConservedDomain                    `json:"cdd,omitempty"`
	MaturePeptide       *[]V2reportsVirusPeptide                       `json:"mature_peptide,omitempty"`
	Name                *string                                        `json:"name,omitempty"`
	Nucleotide          *V2reportsSeqRangeSetFasta                     `json:"nucleotide,omitempty"`
	OtherNames          *[]string                                      `json:"other_names,omitempty"`
	PdbIds              *[]string                                      `json:"pdb_ids,omitempty"`
	Protein             *V2reportsSeqRangeSetFasta                     `json:"protein,omitempty"`
	ProteinCompleteness *V2reportsVirusPeptideViralPeptideCompleteness `json:"protein_completeness,omitempty"`
	UniProtKb           *V2reportsVirusPeptideUniProtId                `json:"uni_prot_kb,omitempty"`
}

// V2reportsVirusPeptideUniProtId defines model for v2reportsVirusPeptideUniProtId.
type V2reportsVirusPeptideUniProtId struct {
	Id   *string `json:"id,omitempty"`
	Name *string `json:"name,omitempty"`
}

// V2reportsVirusPeptideViralPeptideCompleteness defines model for v2reportsVirusPeptideViralPeptideCompleteness.
type V2reportsVirusPeptideViralPeptideCompleteness string

// V2reportsWGSInfo defines model for v2reportsWGSInfo.
type V2reportsWGSInfo struct {
	MasterWgsUrl        *string `json:"master_wgs_url,omitempty"`
	WgsContigsUrl       *string `json:"wgs_contigs_url,omitempty"`
	WgsProjectAccession *string `json:"wgs_project_accession,omitempty"`
}

// V2reportsWarning defines model for v2reportsWarning.
type V2reportsWarning struct {
	GeneWarningCode        *V2reportsWarningGeneWarningCode `json:"gene_warning_code,omitempty"`
	Message                *string                          `json:"message,omitempty"`
	Reason                 *string                          `json:"reason,omitempty"`
	ReplacedId             *V2reportsWarningReplacedId      `json:"replaced_id,omitempty"`
	UnrecognizedIdentifier *string                          `json:"unrecognized_identifier,omitempty"`
}

// V2reportsWarningGeneWarningCode defines model for v2reportsWarningGeneWarningCode.
type V2reportsWarningGeneWarningCode string

// V2reportsWarningReplacedId defines model for v2reportsWarningReplacedId.
type V2reportsWarningReplacedId struct {
	Requested *string `json:"requested,omitempty"`
	Returned  *string `json:"returned,omitempty"`
}

// GeneMetadataByAccessionParams defines parameters for GeneMetadataByAccession.
type GeneMetadataByAccessionParams struct {
	// ReturnedContent Return either gene-ids, or entire gene metadata
	ReturnedContent *V2GeneDatasetReportsRequestContentType `form:"returned_content,omitempty" json:"returned_content,omitempty"`

	// TableFields Specify which fields to include in the tabular report
	TableFields *[]string `form:"table_fields,omitempty" json:"table_fields,omitempty"`

	// IncludeTabularHeader Whether this request for tabular data should include the header row
	IncludeTabularHeader *V2IncludeTabularHeader `form:"include_tabular_header,omitempty" json:"include_tabular_header,omitempty"`

	// PageSize The maximum number of gene reports to return. Default is 20 and maximum is 1000. If the number of results exceeds the page size, `page_token` can be used to retrieve the remaining results.
	PageSize *int `form:"page_size,omitempty" json:"page_size,omitempty"`

	// PageToken A page token is returned from an `AssemblyDatasetReportsRequest` call with more than `page_size` results. Use this token, along with the previous `AssemblyDatasetReportsRequest` parameters, to retrieve the next page of results. When `page_token` is empty, all results have been retrieved.
	PageToken *string `form:"page_token,omitempty" json:"page_token,omitempty"`
}

// DownloadGenePackagePostParams defines parameters for DownloadGenePackagePost.
type DownloadGenePackagePostParams struct {
	// Filename Output file name.
	Filename *string `form:"filename,omitempty" json:"filename,omitempty"`
}

// GeneReportsByIdParams defines parameters for GeneReportsById.
type GeneReportsByIdParams struct {
	// ReturnedContent Return either gene-ids, or entire gene metadata
	ReturnedContent *V2GeneDatasetReportsRequestContentType `form:"returned_content,omitempty" json:"returned_content,omitempty"`

	// TableFields Specify which fields to include in the tabular report
	TableFields *[]string `form:"table_fields,omitempty" json:"table_fields,omitempty"`

	// IncludeTabularHeader Whether this request for tabular data should include the header row
	IncludeTabularHeader *V2IncludeTabularHeader `form:"include_tabular_header,omitempty" json:"include_tabular_header,omitempty"`

	// PageSize The maximum number of gene reports to return. Default is 20 and maximum is 1000. If the number of results exceeds the page size, `page_token` can be used to retrieve the remaining results.
	PageSize *int `form:"page_size,omitempty" json:"page_size,omitempty"`

	// PageToken A page token is returned from an `AssemblyDatasetReportsRequest` call with more than `page_size` results. Use this token, along with the previous `AssemblyDatasetReportsRequest` parameters, to retrieve the next page of results. When `page_token` is empty, all results have been retrieved.
	PageToken *string `form:"page_token,omitempty" json:"page_token,omitempty"`
}

// DownloadGenePackageParams defines parameters for DownloadGenePackage.
type DownloadGenePackageParams struct {
	// IncludeAnnotationType Select additional types of annotation to include in the data package.  If unset, no annotation is provided.
	IncludeAnnotationType *[]V2Fasta `form:"include_annotation_type,omitempty" json:"include_annotation_type,omitempty"`

	// FastaFilter Limit the FASTA sequences in the datasets package to these transcript and protein accessions
	FastaFilter *[]string `form:"fasta_filter,omitempty" json:"fasta_filter,omitempty"`

	// AuxReport list additional reports to include with download. Data report is included by default.
	AuxReport *[]V2GeneDatasetRequestGeneDatasetReportType `form:"aux_report,omitempty" json:"aux_report,omitempty"`

	// TableFields Specify which fields to include in the tabular report
	TableFields *[]string `form:"table_fields,omitempty" json:"table_fields,omitempty"`

	// TableReportType Specify the report from which the table fields will be taken
	TableReportType *V2GeneDatasetRequestGeneDatasetReportType `form:"table_report_type,omitempty" json:"table_report_type,omitempty"`

	// Filename Output file name.
	Filename *string `form:"filename,omitempty" json:"filename,omitempty"`
}

// GeneDownloadSummaryByIdParams defines parameters for GeneDownloadSummaryById.
type GeneDownloadSummaryByIdParams struct {
	// IncludeAnnotationType Select additional types of annotation to include in the data package.  If unset, no annotation is provided.
	IncludeAnnotationType *[]V2Fasta `form:"include_annotation_type,omitempty" json:"include_annotation_type,omitempty"`

	// ReturnedContent Return either gene-ids, or entire gene metadata
	ReturnedContent *V2GeneDatasetRequestContentType `form:"returned_content,omitempty" json:"returned_content,omitempty"`

	// FastaFilter Limit the FASTA sequences in the datasets package to these transcript and protein accessions
	FastaFilter *[]string `form:"fasta_filter,omitempty" json:"fasta_filter,omitempty"`

	// AuxReport list additional reports to include with download. Data report is included by default.
	AuxReport *[]V2GeneDatasetRequestGeneDatasetReportType `form:"aux_report,omitempty" json:"aux_report,omitempty"`

	// TableFields Specify which fields to include in the tabular report
	TableFields *[]string `form:"table_fields,omitempty" json:"table_fields,omitempty"`

	// TableReportType Specify the report from which the table fields will be taken
	TableReportType *V2GeneDatasetRequestGeneDatasetReportType `form:"table_report_type,omitempty" json:"table_report_type,omitempty"`
}

// GeneOrthologsByIdParams defines parameters for GeneOrthologsById.
type GeneOrthologsByIdParams struct {
	// ReturnedContent Return either gene-ids, or entire gene metadata
	ReturnedContent *V2OrthologRequestContentType `form:"returned_content,omitempty" json:"returned_content,omitempty"`

	// TaxonFilter Filter genes by taxa
	TaxonFilter *[]string `form:"taxon_filter,omitempty" json:"taxon_filter,omitempty"`

	// PageSize The maximum number of gene reports to return. Default is 20 and maximum is 1000. If the number of results exceeds the page size, `page_token` can be used to retrieve the remaining results.
	PageSize *int `form:"page_size,omitempty" json:"page_size,omitempty"`

	// PageToken A page token is returned from an `OrthologRequest` call with more than `page_size` results. Use this token, along with the previous `OrthologRequest` parameters, to retrieve the next page of results. When `page_token` is empty, all results have been retrieved.
	PageToken *string `form:"page_token,omitempty" json:"page_token,omitempty"`
}

// GeneMetadataByTaxAndSymbolParams defines parameters for GeneMetadataByTaxAndSymbol.
type GeneMetadataByTaxAndSymbolParams struct {
	// ReturnedContent Return either gene-ids, or entire gene metadata
	ReturnedContent *V2GeneDatasetReportsRequestContentType `form:"returned_content,omitempty" json:"returned_content,omitempty"`

	// TableFields Specify which fields to include in the tabular report
	TableFields *[]string `form:"table_fields,omitempty" json:"table_fields,omitempty"`

	// IncludeTabularHeader Whether this request for tabular data should include the header row
	IncludeTabularHeader *V2IncludeTabularHeader `form:"include_tabular_header,omitempty" json:"include_tabular_header,omitempty"`

	// PageSize The maximum number of gene reports to return. Default is 20 and maximum is 1000. If the number of results exceeds the page size, `page_token` can be used to retrieve the remaining results.
	PageSize *int `form:"page_size,omitempty" json:"page_size,omitempty"`

	// PageToken A page token is returned from an `AssemblyDatasetReportsRequest` call with more than `page_size` results. Use this token, along with the previous `AssemblyDatasetReportsRequest` parameters, to retrieve the next page of results. When `page_token` is empty, all results have been retrieved.
	PageToken *string `form:"page_token,omitempty" json:"page_token,omitempty"`
}

// GeneReportsByTaxonParams defines parameters for GeneReportsByTaxon.
type GeneReportsByTaxonParams struct {
	// ReturnedContent Return either gene-ids, or entire gene metadata
	ReturnedContent *V2GeneDatasetReportsRequestContentType `form:"returned_content,omitempty" json:"returned_content,omitempty"`

	// TableFields Specify which fields to include in the tabular report
	TableFields *[]string `form:"table_fields,omitempty" json:"table_fields,omitempty"`

	// IncludeTabularHeader Whether this request for tabular data should include the header row
	IncludeTabularHeader *V2IncludeTabularHeader `form:"include_tabular_header,omitempty" json:"include_tabular_header,omitempty"`

	// PageSize The maximum number of gene reports to return. Default is 20 and maximum is 1000. If the number of results exceeds the page size, `page_token` can be used to retrieve the remaining results.
	PageSize *int `form:"page_size,omitempty" json:"page_size,omitempty"`

	// PageToken A page token is returned from an `AssemblyDatasetReportsRequest` call with more than `page_size` results. Use this token, along with the previous `AssemblyDatasetReportsRequest` parameters, to retrieve the next page of results. When `page_token` is empty, all results have been retrieved.
	PageToken *string `form:"page_token,omitempty" json:"page_token,omitempty"`

	// Query text search within gene symbol, aliases, name, and protein name
	Query *string `form:"query,omitempty" json:"query,omitempty"`

	// Types Gene types to filter
	Types *[]V2GeneType `form:"types,omitempty" json:"types,omitempty"`
}

// CheckAssemblyAvailabilityParams defines parameters for CheckAssemblyAvailability.
type CheckAssemblyAvailabilityParams struct {
	// ExpDebugValues Supports debugging, e.g. by controlling data download speeds
	ExpDebugValues *string `form:"_exp_debug_values,omitempty" json:"_exp_debug_values,omitempty"`
}

// GenomeDatasetReportParams defines parameters for GenomeDatasetReport.
type GenomeDatasetReportParams struct {
	// FiltersReferenceOnly If true, only return reference and representative (GCF_ and GCA_) genome assemblies.
	FiltersReferenceOnly *bool `form:"filters.reference_only,omitempty" json:"filters.reference_only,omitempty"`

	// FiltersAssemblySource Return only RefSeq (GCF_) or GenBank (GCA_) genome assemblies
	FiltersAssemblySource *V2AssemblyDatasetDescriptorsFilterAssemblySource `form:"filters.assembly_source,omitempty" json:"filters.assembly_source,omitempty"`

	// FiltersHasAnnotation Return only annotated genome assemblies
	FiltersHasAnnotation *bool `form:"filters.has_annotation,omitempty" json:"filters.has_annotation,omitempty"`

	// FiltersExcludePairedReports For paired (GCA/GCF) records, only return the primary record
	FiltersExcludePairedReports *bool `form:"filters.exclude_paired_reports,omitempty" json:"filters.exclude_paired_reports,omitempty"`

	// FiltersExcludeAtypical If true, exclude atypical genomes, i.e. genomes that have assembly issues or are otherwise atypical
	FiltersExcludeAtypical *bool `form:"filters.exclude_atypical,omitempty" json:"filters.exclude_atypical,omitempty"`

	// FiltersAssemblyVersion Return all assemblies, including replaced and suppressed, or only current assemblies
	FiltersAssemblyVersion *V2AssemblyDatasetDescriptorsFilterAssemblyVersion `form:"filters.assembly_version,omitempty" json:"filters.assembly_version,omitempty"`

	// FiltersAssemblyLevel Only return genome assemblies that have one of the specified assembly levels. By default, do not filter.
	FiltersAssemblyLevel *[]V2reportsAssemblyLevel `form:"filters.assembly_level,omitempty" json:"filters.assembly_level,omitempty"`

	// FiltersFirstReleaseDate Only return genome assemblies that were released on or after the specified date By default, do not filter.
	FiltersFirstReleaseDate *time.Time `form:"filters.first_release_date,omitempty" json:"filters.first_release_date,omitempty"`

	// FiltersLastReleaseDate Only return genome assemblies that were released on or before to the specified date By default, do not filter.
	FiltersLastReleaseDate *time.Time `form:"filters.last_release_date,omitempty" json:"filters.last_release_date,omitempty"`

	// FiltersSearchText Only return results whose fields contain the specified search terms in their taxon, infraspecific, assembly name or submitter fields By default, do not filter
	FiltersSearchText          *[]string                                                  `form:"filters.search_text,omitempty" json:"filters.search_text,omitempty"`
	FiltersIsMetagenomeDerived *V2AssemblyDatasetDescriptorsFilterMetagenomeDerivedFilter `form:"filters.is_metagenome_derived,omitempty" json:"filters.is_metagenome_derived,omitempty"`

	// FiltersIsTypeMaterial If true, include only type materials
	FiltersIsTypeMaterial *bool `form:"filters.is_type_material,omitempty" json:"filters.is_type_material,omitempty"`

	// FiltersIsIctvExemplar If true, include only ICTV Exemplars
	FiltersIsIctvExemplar *bool `form:"filters.is_ictv_exemplar,omitempty" json:"filters.is_ictv_exemplar,omitempty"`

	// FiltersExcludeMultiIsolate If true, exclude large multi-isolate projects
	FiltersExcludeMultiIsolate  *bool                                                   `form:"filters.exclude_multi_isolate,omitempty" json:"filters.exclude_multi_isolate,omitempty"`
	FiltersTypeMaterialCategory *V2AssemblyDatasetDescriptorsFilterTypeMaterialCategory `form:"filters.type_material_category,omitempty" json:"filters.type_material_category,omitempty"`

	// TaxExactMatch If true, only return assemblies with the given NCBI Taxonomy ID, or name. Otherwise, assemblies from taxonomy subtree are included, too.
	TaxExactMatch *bool     `form:"tax_exact_match,omitempty" json:"tax_exact_match,omitempty"`
	TableFields   *[]string `form:"table_fields,omitempty" json:"table_fields,omitempty"`

	// ReturnedContent Return either assembly accessions, or complete assembly reports
	ReturnedContent *V2AssemblyDatasetReportsRequestContentType `form:"returned_content,omitempty" json:"returned_content,omitempty"`

	// PageSize The maximum number of genome assembly reports to return. Default is 20 and maximum is 1000. If the number of results exceeds the page size, `page_token` can be used to retrieve the remaining results.
	PageSize *int `form:"page_size,omitempty" json:"page_size,omitempty"`

	// PageToken A page token is returned from an `AssemblyDatasetReportsRequest` call with more than `page_size` results. Use this token, along with the previous `AssemblyDatasetReportsRequest` parameters, to retrieve the next page of results. When `page_token` is empty, all results have been retrieved.
	PageToken     *string          `form:"page_token,omitempty" json:"page_token,omitempty"`
	SortField     *string          `form:"sort.field,omitempty" json:"sort.field,omitempty"`
	SortDirection *V2SortDirection `form:"sort.direction,omitempty" json:"sort.direction,omitempty"`

	// IncludeTabularHeader Whether this request for tabular data should include the header row
	IncludeTabularHeader *V2IncludeTabularHeader `form:"include_tabular_header,omitempty" json:"include_tabular_header,omitempty"`
}

// DownloadAssemblyPackageParams defines parameters for DownloadAssemblyPackage.
type DownloadAssemblyPackageParams struct {
	// Chromosomes The default setting is all chromosome. Specify individual chromosome by string (1,2,MT or chr1,chr2.chrMT). Unplaced sequences are treated like their own chromosome ('Un'). The filter only applies to fasta sequence.
	Chromosomes *[]string `form:"chromosomes,omitempty" json:"chromosomes,omitempty"`

	// IncludeAnnotationType Select additional types of annotation to include in the data package.  If unset, no annotation is provided.
	IncludeAnnotationType *[]V2AnnotationForAssemblyType `form:"include_annotation_type,omitempty" json:"include_annotation_type,omitempty"`

	// Hydrated Set to DATA_REPORT_ONLY, to only retrieve data-reports.
	Hydrated *V2AssemblyDatasetRequestResolution `form:"hydrated,omitempty" json:"hydrated,omitempty"`

	// ExpDebugValues Supports debugging, e.g. by controlling data download speeds
	ExpDebugValues *string `form:"_exp_debug_values,omitempty" json:"_exp_debug_values,omitempty"`

	// Filename Output file name.
	Filename *string `form:"filename,omitempty" json:"filename,omitempty"`
}

// GenomeDownloadSummaryParams defines parameters for GenomeDownloadSummary.
type GenomeDownloadSummaryParams struct {
	// Chromosomes The default setting is all chromosome. Specify individual chromosome by string (1,2,MT or chr1,chr2.chrMT). Unplaced sequences are treated like their own chromosome ('Un'). The filter only applies to fasta sequence.
	Chromosomes *[]string `form:"chromosomes,omitempty" json:"chromosomes,omitempty"`

	// IncludeAnnotationType Select additional types of annotation to include in the data package.  If unset, no annotation is provided.
	IncludeAnnotationType *[]V2AnnotationForAssemblyType `form:"include_annotation_type,omitempty" json:"include_annotation_type,omitempty"`

	// ExpDebugValues Supports debugging, e.g. by controlling data download speeds
	ExpDebugValues *string `form:"_exp_debug_values,omitempty" json:"_exp_debug_values,omitempty"`
}

// GenomeAnnotationReportParams defines parameters for GenomeAnnotationReport.
type GenomeAnnotationReportParams struct {
	// AnnotationIds Limit the reports by internal, unstable annotation ids.
	AnnotationIds *[]string `form:"annotation_ids,omitempty" json:"annotation_ids,omitempty"`

	// Symbols Filter parameters
	Symbols *[]string `form:"symbols,omitempty" json:"symbols,omitempty"`

	// Locations Locations with a chromosome or accession and optional start-stop range: chromosome|accession[:start-end]
	Locations *[]string `form:"locations,omitempty" json:"locations,omitempty"`

	// GeneTypes granular gene_types
	GeneTypes     *[]string        `form:"gene_types,omitempty" json:"gene_types,omitempty"`
	SearchText    *[]string        `form:"search_text,omitempty" json:"search_text,omitempty"`
	SortField     *string          `form:"sort.field,omitempty" json:"sort.field,omitempty"`
	SortDirection *V2SortDirection `form:"sort.direction,omitempty" json:"sort.direction,omitempty"`

	// PageSize The maximum number of features to return. Default is 20 and maximum is 1000. If the number of results exceeds the page size, `page_token` can be used to retrieve the remaining results.
	PageSize *int `form:"page_size,omitempty" json:"page_size,omitempty"`

	// TableFields Specify which fields to include in the tabular report
	TableFields *[]string `form:"table_fields,omitempty" json:"table_fields,omitempty"`

	// TableFormat Optional pre-defined template for processing a tabular data request
	TableFormat *V2GenomeAnnotationRequestGenomeAnnotationTableFormat `form:"table_format,omitempty" json:"table_format,omitempty"`

	// IncludeTabularHeader Whether this request for tabular data should include the header row
	IncludeTabularHeader *V2IncludeTabularHeader `form:"include_tabular_header,omitempty" json:"include_tabular_header,omitempty"`

	// PageToken A page token is returned from a `GetFeatures` call with more than `page_size` results. Use this token, along with the previous `FeatureRequest` parameters, to retrieve the next page of results. When `page_token` is empty, all results have been retrieved.
	PageToken *string `form:"page_token,omitempty" json:"page_token,omitempty"`
}

// DownloadGenomeAnnotationPackageParams defines parameters for DownloadGenomeAnnotationPackage.
type DownloadGenomeAnnotationPackageParams struct {
	// AnnotationIds Limit the reports by internal, unstable annotation ids.
	AnnotationIds *[]string `form:"annotation_ids,omitempty" json:"annotation_ids,omitempty"`

	// Symbols Filter parameters
	Symbols *[]string `form:"symbols,omitempty" json:"symbols,omitempty"`

	// Locations Locations with a chromosome or accession and optional start-stop range: chromosome|accession[:start-end]
	Locations *[]string `form:"locations,omitempty" json:"locations,omitempty"`

	// GeneTypes granular gene_types
	GeneTypes             *[]string                                  `form:"gene_types,omitempty" json:"gene_types,omitempty"`
	SearchText            *[]string                                  `form:"search_text,omitempty" json:"search_text,omitempty"`
	SortField             *string                                    `form:"sort.field,omitempty" json:"sort.field,omitempty"`
	SortDirection         *V2SortDirection                           `form:"sort.direction,omitempty" json:"sort.direction,omitempty"`
	IncludeAnnotationType *[]V2GenomeAnnotationRequestAnnotationType `form:"include_annotation_type,omitempty" json:"include_annotation_type,omitempty"`

	// PageSize The maximum number of features to return. Default is 20 and maximum is 1000. If the number of results exceeds the page size, `page_token` can be used to retrieve the remaining results.
	PageSize *int `form:"page_size,omitempty" json:"page_size,omitempty"`

	// TableFields Specify which fields to include in the tabular report
	TableFields *[]string `form:"table_fields,omitempty" json:"table_fields,omitempty"`

	// TableFormat Optional pre-defined template for processing a tabular data request
	TableFormat *V2GenomeAnnotationRequestGenomeAnnotationTableFormat `form:"table_format,omitempty" json:"table_format,omitempty"`

	// IncludeTabularHeader Whether this request for tabular data should include the header row
	IncludeTabularHeader *V2IncludeTabularHeader `form:"include_tabular_header,omitempty" json:"include_tabular_header,omitempty"`

	// PageToken A page token is returned from a `GetFeatures` call with more than `page_size` results. Use this token, along with the previous `FeatureRequest` parameters, to retrieve the next page of results. When `page_token` is empty, all results have been retrieved.
	PageToken *string `form:"page_token,omitempty" json:"page_token,omitempty"`

	// Filename Output file name.
	Filename *string `form:"filename,omitempty" json:"filename,omitempty"`
}

// GenomeAnnotationDownloadSummaryParams defines parameters for GenomeAnnotationDownloadSummary.
type GenomeAnnotationDownloadSummaryParams struct {
	// AnnotationIds Limit the reports by internal, unstable annotation ids.
	AnnotationIds *[]string `form:"annotation_ids,omitempty" json:"annotation_ids,omitempty"`

	// Symbols Filter parameters
	Symbols *[]string `form:"symbols,omitempty" json:"symbols,omitempty"`

	// Locations Locations with a chromosome or accession and optional start-stop range: chromosome|accession[:start-end]
	Locations *[]string `form:"locations,omitempty" json:"locations,omitempty"`

	// GeneTypes granular gene_types
	GeneTypes             *[]string                                  `form:"gene_types,omitempty" json:"gene_types,omitempty"`
	SearchText            *[]string                                  `form:"search_text,omitempty" json:"search_text,omitempty"`
	SortField             *string                                    `form:"sort.field,omitempty" json:"sort.field,omitempty"`
	SortDirection         *V2SortDirection                           `form:"sort.direction,omitempty" json:"sort.direction,omitempty"`
	IncludeAnnotationType *[]V2GenomeAnnotationRequestAnnotationType `form:"include_annotation_type,omitempty" json:"include_annotation_type,omitempty"`

	// TableFields Specify which fields to include in the tabular report
	TableFields *[]string `form:"table_fields,omitempty" json:"table_fields,omitempty"`

	// TableFormat Optional pre-defined template for processing a tabular data request
	TableFormat *V2GenomeAnnotationRequestGenomeAnnotationTableFormat `form:"table_format,omitempty" json:"table_format,omitempty"`

	// IncludeTabularHeader Whether this request for tabular data should include the header row
	IncludeTabularHeader *V2IncludeTabularHeader `form:"include_tabular_header,omitempty" json:"include_tabular_header,omitempty"`
}

// AnnotationReportFacetsParams defines parameters for AnnotationReportFacets.
type AnnotationReportFacetsParams struct {
	SortField     *string          `form:"sort.field,omitempty" json:"sort.field,omitempty"`
	SortDirection *V2SortDirection `form:"sort.direction,omitempty" json:"sort.direction,omitempty"`
}

// GenomeSequenceReportParams defines parameters for GenomeSequenceReport.
type GenomeSequenceReportParams struct {
	Chromosomes           *[]string `form:"chromosomes,omitempty" json:"chromosomes,omitempty"`
	RoleFilters           *[]string `form:"role_filters,omitempty" json:"role_filters,omitempty"`
	TableFields           *[]string `form:"table_fields,omitempty" json:"table_fields,omitempty"`
	CountAssemblyUnplaced *bool     `form:"count_assembly_unplaced,omitempty" json:"count_assembly_unplaced,omitempty"`

	// PageSize The maximum number of genome assemblies to return. Default is 20 and maximum is 1000. If the number of results exceeds the page size, `page_token` can be used to retrieve the remaining results.
	PageSize *int `form:"page_size,omitempty" json:"page_size,omitempty"`

	// PageToken A page token is returned from an `GetSequenceReports` call with more than `page_size` results. Use this token, along with the previous `AssemblyMetadataRequest` parameters, to retrieve the next page of results. When `page_token` is empty, all results have been retrieved.
	PageToken            *string                 `form:"page_token,omitempty" json:"page_token,omitempty"`
	IncludeTabularHeader *V2IncludeTabularHeader `form:"include_tabular_header,omitempty" json:"include_tabular_header,omitempty"`
}

// DownloadGenomeAnnotationPackageByPostParams defines parameters for DownloadGenomeAnnotationPackageByPost.
type DownloadGenomeAnnotationPackageByPostParams struct {
	// Filename Output file name.
	Filename *string `form:"filename,omitempty" json:"filename,omitempty"`
}

// GenomeDatasetReportsByAssemblyNameParams defines parameters for GenomeDatasetReportsByAssemblyName.
type GenomeDatasetReportsByAssemblyNameParams struct {
	// FiltersReferenceOnly If true, only return reference and representative (GCF_ and GCA_) genome assemblies.
	FiltersReferenceOnly *bool `form:"filters.reference_only,omitempty" json:"filters.reference_only,omitempty"`

	// FiltersAssemblySource Return only RefSeq (GCF_) or GenBank (GCA_) genome assemblies
	FiltersAssemblySource *V2AssemblyDatasetDescriptorsFilterAssemblySource `form:"filters.assembly_source,omitempty" json:"filters.assembly_source,omitempty"`

	// FiltersHasAnnotation Return only annotated genome assemblies
	FiltersHasAnnotation *bool `form:"filters.has_annotation,omitempty" json:"filters.has_annotation,omitempty"`

	// FiltersExcludePairedReports For paired (GCA/GCF) records, only return the primary record
	FiltersExcludePairedReports *bool `form:"filters.exclude_paired_reports,omitempty" json:"filters.exclude_paired_reports,omitempty"`

	// FiltersExcludeAtypical If true, exclude atypical genomes, i.e. genomes that have assembly issues or are otherwise atypical
	FiltersExcludeAtypical *bool `form:"filters.exclude_atypical,omitempty" json:"filters.exclude_atypical,omitempty"`

	// FiltersAssemblyVersion Return all assemblies, including replaced and suppressed, or only current assemblies
	FiltersAssemblyVersion *V2AssemblyDatasetDescriptorsFilterAssemblyVersion `form:"filters.assembly_version,omitempty" json:"filters.assembly_version,omitempty"`

	// FiltersAssemblyLevel Only return genome assemblies that have one of the specified assembly levels. By default, do not filter.
	FiltersAssemblyLevel *[]V2reportsAssemblyLevel `form:"filters.assembly_level,omitempty" json:"filters.assembly_level,omitempty"`

	// FiltersFirstReleaseDate Only return genome assemblies that were released on or after the specified date By default, do not filter.
	FiltersFirstReleaseDate *time.Time `form:"filters.first_release_date,omitempty" json:"filters.first_release_date,omitempty"`

	// FiltersLastReleaseDate Only return genome assemblies that were released on or before to the specified date By default, do not filter.
	FiltersLastReleaseDate *time.Time `form:"filters.last_release_date,omitempty" json:"filters.last_release_date,omitempty"`

	// FiltersSearchText Only return results whose fields contain the specified search terms in their taxon, infraspecific, assembly name or submitter fields By default, do not filter
	FiltersSearchText          *[]string                                                  `form:"filters.search_text,omitempty" json:"filters.search_text,omitempty"`
	FiltersIsMetagenomeDerived *V2AssemblyDatasetDescriptorsFilterMetagenomeDerivedFilter `form:"filters.is_metagenome_derived,omitempty" json:"filters.is_metagenome_derived,omitempty"`

	// FiltersIsTypeMaterial If true, include only type materials
	FiltersIsTypeMaterial *bool `form:"filters.is_type_material,omitempty" json:"filters.is_type_material,omitempty"`

	// FiltersIsIctvExemplar If true, include only ICTV Exemplars
	FiltersIsIctvExemplar *bool `form:"filters.is_ictv_exemplar,omitempty" json:"filters.is_ictv_exemplar,omitempty"`

	// FiltersExcludeMultiIsolate If true, exclude large multi-isolate projects
	FiltersExcludeMultiIsolate  *bool                                                   `form:"filters.exclude_multi_isolate,omitempty" json:"filters.exclude_multi_isolate,omitempty"`
	FiltersTypeMaterialCategory *V2AssemblyDatasetDescriptorsFilterTypeMaterialCategory `form:"filters.type_material_category,omitempty" json:"filters.type_material_category,omitempty"`

	// TaxExactMatch If true, only return assemblies with the given NCBI Taxonomy ID, or name. Otherwise, assemblies from taxonomy subtree are included, too.
	TaxExactMatch *bool     `form:"tax_exact_match,omitempty" json:"tax_exact_match,omitempty"`
	TableFields   *[]string `form:"table_fields,omitempty" json:"table_fields,omitempty"`

	// ReturnedContent Return either assembly accessions, or complete assembly reports
	ReturnedContent *V2AssemblyDatasetReportsRequestContentType `form:"returned_content,omitempty" json:"returned_content,omitempty"`

	// PageSize The maximum number of genome assembly reports to return. Default is 20 and maximum is 1000. If the number of results exceeds the page size, `page_token` can be used to retrieve the remaining results.
	PageSize *int `form:"page_size,omitempty" json:"page_size,omitempty"`

	// PageToken A page token is returned from an `AssemblyDatasetReportsRequest` call with more than `page_size` results. Use this token, along with the previous `AssemblyDatasetReportsRequest` parameters, to retrieve the next page of results. When `page_token` is empty, all results have been retrieved.
	PageToken     *string          `form:"page_token,omitempty" json:"page_token,omitempty"`
	SortField     *string          `form:"sort.field,omitempty" json:"sort.field,omitempty"`
	SortDirection *V2SortDirection `form:"sort.direction,omitempty" json:"sort.direction,omitempty"`

	// IncludeTabularHeader Whether this request for tabular data should include the header row
	IncludeTabularHeader *V2IncludeTabularHeader `form:"include_tabular_header,omitempty" json:"include_tabular_header,omitempty"`
}

// GenomeDatasetReportsByBioprojectParams defines parameters for GenomeDatasetReportsByBioproject.
type GenomeDatasetReportsByBioprojectParams struct {
	// FiltersReferenceOnly If true, only return reference and representative (GCF_ and GCA_) genome assemblies.
	FiltersReferenceOnly *bool `form:"filters.reference_only,omitempty" json:"filters.reference_only,omitempty"`

	// FiltersAssemblySource Return only RefSeq (GCF_) or GenBank (GCA_) genome assemblies
	FiltersAssemblySource *V2AssemblyDatasetDescriptorsFilterAssemblySource `form:"filters.assembly_source,omitempty" json:"filters.assembly_source,omitempty"`

	// FiltersHasAnnotation Return only annotated genome assemblies
	FiltersHasAnnotation *bool `form:"filters.has_annotation,omitempty" json:"filters.has_annotation,omitempty"`

	// FiltersExcludePairedReports For paired (GCA/GCF) records, only return the primary record
	FiltersExcludePairedReports *bool `form:"filters.exclude_paired_reports,omitempty" json:"filters.exclude_paired_reports,omitempty"`

	// FiltersExcludeAtypical If true, exclude atypical genomes, i.e. genomes that have assembly issues or are otherwise atypical
	FiltersExcludeAtypical *bool `form:"filters.exclude_atypical,omitempty" json:"filters.exclude_atypical,omitempty"`

	// FiltersAssemblyVersion Return all assemblies, including replaced and suppressed, or only current assemblies
	FiltersAssemblyVersion *V2AssemblyDatasetDescriptorsFilterAssemblyVersion `form:"filters.assembly_version,omitempty" json:"filters.assembly_version,omitempty"`

	// FiltersAssemblyLevel Only return genome assemblies that have one of the specified assembly levels. By default, do not filter.
	FiltersAssemblyLevel *[]V2reportsAssemblyLevel `form:"filters.assembly_level,omitempty" json:"filters.assembly_level,omitempty"`

	// FiltersFirstReleaseDate Only return genome assemblies that were released on or after the specified date By default, do not filter.
	FiltersFirstReleaseDate *time.Time `form:"filters.first_release_date,omitempty" json:"filters.first_release_date,omitempty"`

	// FiltersLastReleaseDate Only return genome assemblies that were released on or before to the specified date By default, do not filter.
	FiltersLastReleaseDate *time.Time `form:"filters.last_release_date,omitempty" json:"filters.last_release_date,omitempty"`

	// FiltersSearchText Only return results whose fields contain the specified search terms in their taxon, infraspecific, assembly name or submitter fields By default, do not filter
	FiltersSearchText          *[]string                                                  `form:"filters.search_text,omitempty" json:"filters.search_text,omitempty"`
	FiltersIsMetagenomeDerived *V2AssemblyDatasetDescriptorsFilterMetagenomeDerivedFilter `form:"filters.is_metagenome_derived,omitempty" json:"filters.is_metagenome_derived,omitempty"`

	// FiltersIsTypeMaterial If true, include only type materials
	FiltersIsTypeMaterial *bool `form:"filters.is_type_material,omitempty" json:"filters.is_type_material,omitempty"`

	// FiltersIsIctvExemplar If true, include only ICTV Exemplars
	FiltersIsIctvExemplar *bool `form:"filters.is_ictv_exemplar,omitempty" json:"filters.is_ictv_exemplar,omitempty"`

	// FiltersExcludeMultiIsolate If true, exclude large multi-isolate projects
	FiltersExcludeMultiIsolate  *bool                                                   `form:"filters.exclude_multi_isolate,omitempty" json:"filters.exclude_multi_isolate,omitempty"`
	FiltersTypeMaterialCategory *V2AssemblyDatasetDescriptorsFilterTypeMaterialCategory `form:"filters.type_material_category,omitempty" json:"filters.type_material_category,omitempty"`

	// TaxExactMatch If true, only return assemblies with the given NCBI Taxonomy ID, or name. Otherwise, assemblies from taxonomy subtree are included, too.
	TaxExactMatch *bool     `form:"tax_exact_match,omitempty" json:"tax_exact_match,omitempty"`
	TableFields   *[]string `form:"table_fields,omitempty" json:"table_fields,omitempty"`

	// ReturnedContent Return either assembly accessions, or complete assembly reports
	ReturnedContent *V2AssemblyDatasetReportsRequestContentType `form:"returned_content,omitempty" json:"returned_content,omitempty"`

	// PageSize The maximum number of genome assembly reports to return. Default is 20 and maximum is 1000. If the number of results exceeds the page size, `page_token` can be used to retrieve the remaining results.
	PageSize *int `form:"page_size,omitempty" json:"page_size,omitempty"`

	// PageToken A page token is returned from an `AssemblyDatasetReportsRequest` call with more than `page_size` results. Use this token, along with the previous `AssemblyDatasetReportsRequest` parameters, to retrieve the next page of results. When `page_token` is empty, all results have been retrieved.
	PageToken     *string          `form:"page_token,omitempty" json:"page_token,omitempty"`
	SortField     *string          `form:"sort.field,omitempty" json:"sort.field,omitempty"`
	SortDirection *V2SortDirection `form:"sort.direction,omitempty" json:"sort.direction,omitempty"`

	// IncludeTabularHeader Whether this request for tabular data should include the header row
	IncludeTabularHeader *V2IncludeTabularHeader `form:"include_tabular_header,omitempty" json:"include_tabular_header,omitempty"`
}

// GenomeDatasetReportsByBiosampleIdParams defines parameters for GenomeDatasetReportsByBiosampleId.
type GenomeDatasetReportsByBiosampleIdParams struct {
	// FiltersReferenceOnly If true, only return reference and representative (GCF_ and GCA_) genome assemblies.
	FiltersReferenceOnly *bool `form:"filters.reference_only,omitempty" json:"filters.reference_only,omitempty"`

	// FiltersAssemblySource Return only RefSeq (GCF_) or GenBank (GCA_) genome assemblies
	FiltersAssemblySource *V2AssemblyDatasetDescriptorsFilterAssemblySource `form:"filters.assembly_source,omitempty" json:"filters.assembly_source,omitempty"`

	// FiltersHasAnnotation Return only annotated genome assemblies
	FiltersHasAnnotation *bool `form:"filters.has_annotation,omitempty" json:"filters.has_annotation,omitempty"`

	// FiltersExcludePairedReports For paired (GCA/GCF) records, only return the primary record
	FiltersExcludePairedReports *bool `form:"filters.exclude_paired_reports,omitempty" json:"filters.exclude_paired_reports,omitempty"`

	// FiltersExcludeAtypical If true, exclude atypical genomes, i.e. genomes that have assembly issues or are otherwise atypical
	FiltersExcludeAtypical *bool `form:"filters.exclude_atypical,omitempty" json:"filters.exclude_atypical,omitempty"`

	// FiltersAssemblyVersion Return all assemblies, including replaced and suppressed, or only current assemblies
	FiltersAssemblyVersion *V2AssemblyDatasetDescriptorsFilterAssemblyVersion `form:"filters.assembly_version,omitempty" json:"filters.assembly_version,omitempty"`

	// FiltersAssemblyLevel Only return genome assemblies that have one of the specified assembly levels. By default, do not filter.
	FiltersAssemblyLevel *[]V2reportsAssemblyLevel `form:"filters.assembly_level,omitempty" json:"filters.assembly_level,omitempty"`

	// FiltersFirstReleaseDate Only return genome assemblies that were released on or after the specified date By default, do not filter.
	FiltersFirstReleaseDate *time.Time `form:"filters.first_release_date,omitempty" json:"filters.first_release_date,omitempty"`

	// FiltersLastReleaseDate Only return genome assemblies that were released on or before to the specified date By default, do not filter.
	FiltersLastReleaseDate *time.Time `form:"filters.last_release_date,omitempty" json:"filters.last_release_date,omitempty"`

	// FiltersSearchText Only return results whose fields contain the specified search terms in their taxon, infraspecific, assembly name or submitter fields By default, do not filter
	FiltersSearchText          *[]string                                                  `form:"filters.search_text,omitempty" json:"filters.search_text,omitempty"`
	FiltersIsMetagenomeDerived *V2AssemblyDatasetDescriptorsFilterMetagenomeDerivedFilter `form:"filters.is_metagenome_derived,omitempty" json:"filters.is_metagenome_derived,omitempty"`

	// FiltersIsTypeMaterial If true, include only type materials
	FiltersIsTypeMaterial *bool `form:"filters.is_type_material,omitempty" json:"filters.is_type_material,omitempty"`

	// FiltersIsIctvExemplar If true, include only ICTV Exemplars
	FiltersIsIctvExemplar *bool `form:"filters.is_ictv_exemplar,omitempty" json:"filters.is_ictv_exemplar,omitempty"`

	// FiltersExcludeMultiIsolate If true, exclude large multi-isolate projects
	FiltersExcludeMultiIsolate  *bool                                                   `form:"filters.exclude_multi_isolate,omitempty" json:"filters.exclude_multi_isolate,omitempty"`
	FiltersTypeMaterialCategory *V2AssemblyDatasetDescriptorsFilterTypeMaterialCategory `form:"filters.type_material_category,omitempty" json:"filters.type_material_category,omitempty"`

	// TaxExactMatch If true, only return assemblies with the given NCBI Taxonomy ID, or name. Otherwise, assemblies from taxonomy subtree are included, too.
	TaxExactMatch *bool     `form:"tax_exact_match,omitempty" json:"tax_exact_match,omitempty"`
	TableFields   *[]string `form:"table_fields,omitempty" json:"table_fields,omitempty"`

	// ReturnedContent Return either assembly accessions, or complete assembly reports
	ReturnedContent *V2AssemblyDatasetReportsRequestContentType `form:"returned_content,omitempty" json:"returned_content,omitempty"`

	// PageSize The maximum number of genome assembly reports to return. Default is 20 and maximum is 1000. If the number of results exceeds the page size, `page_token` can be used to retrieve the remaining results.
	PageSize *int `form:"page_size,omitempty" json:"page_size,omitempty"`

	// PageToken A page token is returned from an `AssemblyDatasetReportsRequest` call with more than `page_size` results. Use this token, along with the previous `AssemblyDatasetReportsRequest` parameters, to retrieve the next page of results. When `page_token` is empty, all results have been retrieved.
	PageToken     *string          `form:"page_token,omitempty" json:"page_token,omitempty"`
	SortField     *string          `form:"sort.field,omitempty" json:"sort.field,omitempty"`
	SortDirection *V2SortDirection `form:"sort.direction,omitempty" json:"sort.direction,omitempty"`

	// IncludeTabularHeader Whether this request for tabular data should include the header row
	IncludeTabularHeader *V2IncludeTabularHeader `form:"include_tabular_header,omitempty" json:"include_tabular_header,omitempty"`
}

// DownloadAssemblyPackagePostParams defines parameters for DownloadAssemblyPackagePost.
type DownloadAssemblyPackagePostParams struct {
	// Filename Output file name.
	Filename *string `form:"filename,omitempty" json:"filename,omitempty"`
}

// GenomeDatasetReportsByTaxonParams defines parameters for GenomeDatasetReportsByTaxon.
type GenomeDatasetReportsByTaxonParams struct {
	// FiltersReferenceOnly If true, only return reference and representative (GCF_ and GCA_) genome assemblies.
	FiltersReferenceOnly *bool `form:"filters.reference_only,omitempty" json:"filters.reference_only,omitempty"`

	// FiltersAssemblySource Return only RefSeq (GCF_) or GenBank (GCA_) genome assemblies
	FiltersAssemblySource *V2AssemblyDatasetDescriptorsFilterAssemblySource `form:"filters.assembly_source,omitempty" json:"filters.assembly_source,omitempty"`

	// FiltersHasAnnotation Return only annotated genome assemblies
	FiltersHasAnnotation *bool `form:"filters.has_annotation,omitempty" json:"filters.has_annotation,omitempty"`

	// FiltersExcludePairedReports For paired (GCA/GCF) records, only return the primary record
	FiltersExcludePairedReports *bool `form:"filters.exclude_paired_reports,omitempty" json:"filters.exclude_paired_reports,omitempty"`

	// FiltersExcludeAtypical If true, exclude atypical genomes, i.e. genomes that have assembly issues or are otherwise atypical
	FiltersExcludeAtypical *bool `form:"filters.exclude_atypical,omitempty" json:"filters.exclude_atypical,omitempty"`

	// FiltersAssemblyVersion Return all assemblies, including replaced and suppressed, or only current assemblies
	FiltersAssemblyVersion *V2AssemblyDatasetDescriptorsFilterAssemblyVersion `form:"filters.assembly_version,omitempty" json:"filters.assembly_version,omitempty"`

	// FiltersAssemblyLevel Only return genome assemblies that have one of the specified assembly levels. By default, do not filter.
	FiltersAssemblyLevel *[]V2reportsAssemblyLevel `form:"filters.assembly_level,omitempty" json:"filters.assembly_level,omitempty"`

	// FiltersFirstReleaseDate Only return genome assemblies that were released on or after the specified date By default, do not filter.
	FiltersFirstReleaseDate *time.Time `form:"filters.first_release_date,omitempty" json:"filters.first_release_date,omitempty"`

	// FiltersLastReleaseDate Only return genome assemblies that were released on or before to the specified date By default, do not filter.
	FiltersLastReleaseDate *time.Time `form:"filters.last_release_date,omitempty" json:"filters.last_release_date,omitempty"`

	// FiltersSearchText Only return results whose fields contain the specified search terms in their taxon, infraspecific, assembly name or submitter fields By default, do not filter
	FiltersSearchText          *[]string                                                  `form:"filters.search_text,omitempty" json:"filters.search_text,omitempty"`
	FiltersIsMetagenomeDerived *V2AssemblyDatasetDescriptorsFilterMetagenomeDerivedFilter `form:"filters.is_metagenome_derived,omitempty" json:"filters.is_metagenome_derived,omitempty"`

	// FiltersIsTypeMaterial If true, include only type materials
	FiltersIsTypeMaterial *bool `form:"filters.is_type_material,omitempty" json:"filters.is_type_material,omitempty"`

	// FiltersIsIctvExemplar If true, include only ICTV Exemplars
	FiltersIsIctvExemplar *bool `form:"filters.is_ictv_exemplar,omitempty" json:"filters.is_ictv_exemplar,omitempty"`

	// FiltersExcludeMultiIsolate If true, exclude large multi-isolate projects
	FiltersExcludeMultiIsolate  *bool                                                   `form:"filters.exclude_multi_isolate,omitempty" json:"filters.exclude_multi_isolate,omitempty"`
	FiltersTypeMaterialCategory *V2AssemblyDatasetDescriptorsFilterTypeMaterialCategory `form:"filters.type_material_category,omitempty" json:"filters.type_material_category,omitempty"`

	// TaxExactMatch If true, only return assemblies with the given NCBI Taxonomy ID, or name. Otherwise, assemblies from taxonomy subtree are included, too.
	TaxExactMatch *bool     `form:"tax_exact_match,omitempty" json:"tax_exact_match,omitempty"`
	TableFields   *[]string `form:"table_fields,omitempty" json:"table_fields,omitempty"`

	// ReturnedContent Return either assembly accessions, or complete assembly reports
	ReturnedContent *V2AssemblyDatasetReportsRequestContentType `form:"returned_content,omitempty" json:"returned_content,omitempty"`

	// PageSize The maximum number of genome assembly reports to return. Default is 20 and maximum is 1000. If the number of results exceeds the page size, `page_token` can be used to retrieve the remaining results.
	PageSize *int `form:"page_size,omitempty" json:"page_size,omitempty"`

	// PageToken A page token is returned from an `AssemblyDatasetReportsRequest` call with more than `page_size` results. Use this token, along with the previous `AssemblyDatasetReportsRequest` parameters, to retrieve the next page of results. When `page_token` is empty, all results have been retrieved.
	PageToken     *string          `form:"page_token,omitempty" json:"page_token,omitempty"`
	SortField     *string          `form:"sort.field,omitempty" json:"sort.field,omitempty"`
	SortDirection *V2SortDirection `form:"sort.direction,omitempty" json:"sort.direction,omitempty"`

	// IncludeTabularHeader Whether this request for tabular data should include the header row
	IncludeTabularHeader *V2IncludeTabularHeader `form:"include_tabular_header,omitempty" json:"include_tabular_header,omitempty"`
}

// GenomeDatasetReportsByWgsParams defines parameters for GenomeDatasetReportsByWgs.
type GenomeDatasetReportsByWgsParams struct {
	// FiltersReferenceOnly If true, only return reference and representative (GCF_ and GCA_) genome assemblies.
	FiltersReferenceOnly *bool `form:"filters.reference_only,omitempty" json:"filters.reference_only,omitempty"`

	// FiltersAssemblySource Return only RefSeq (GCF_) or GenBank (GCA_) genome assemblies
	FiltersAssemblySource *V2AssemblyDatasetDescriptorsFilterAssemblySource `form:"filters.assembly_source,omitempty" json:"filters.assembly_source,omitempty"`

	// FiltersHasAnnotation Return only annotated genome assemblies
	FiltersHasAnnotation *bool `form:"filters.has_annotation,omitempty" json:"filters.has_annotation,omitempty"`

	// FiltersExcludePairedReports For paired (GCA/GCF) records, only return the primary record
	FiltersExcludePairedReports *bool `form:"filters.exclude_paired_reports,omitempty" json:"filters.exclude_paired_reports,omitempty"`

	// FiltersExcludeAtypical If true, exclude atypical genomes, i.e. genomes that have assembly issues or are otherwise atypical
	FiltersExcludeAtypical *bool `form:"filters.exclude_atypical,omitempty" json:"filters.exclude_atypical,omitempty"`

	// FiltersAssemblyVersion Return all assemblies, including replaced and suppressed, or only current assemblies
	FiltersAssemblyVersion *V2AssemblyDatasetDescriptorsFilterAssemblyVersion `form:"filters.assembly_version,omitempty" json:"filters.assembly_version,omitempty"`

	// FiltersAssemblyLevel Only return genome assemblies that have one of the specified assembly levels. By default, do not filter.
	FiltersAssemblyLevel *[]V2reportsAssemblyLevel `form:"filters.assembly_level,omitempty" json:"filters.assembly_level,omitempty"`

	// FiltersFirstReleaseDate Only return genome assemblies that were released on or after the specified date By default, do not filter.
	FiltersFirstReleaseDate *time.Time `form:"filters.first_release_date,omitempty" json:"filters.first_release_date,omitempty"`

	// FiltersLastReleaseDate Only return genome assemblies that were released on or before to the specified date By default, do not filter.
	FiltersLastReleaseDate *time.Time `form:"filters.last_release_date,omitempty" json:"filters.last_release_date,omitempty"`

	// FiltersSearchText Only return results whose fields contain the specified search terms in their taxon, infraspecific, assembly name or submitter fields By default, do not filter
	FiltersSearchText          *[]string                                                  `form:"filters.search_text,omitempty" json:"filters.search_text,omitempty"`
	FiltersIsMetagenomeDerived *V2AssemblyDatasetDescriptorsFilterMetagenomeDerivedFilter `form:"filters.is_metagenome_derived,omitempty" json:"filters.is_metagenome_derived,omitempty"`

	// FiltersIsTypeMaterial If true, include only type materials
	FiltersIsTypeMaterial *bool `form:"filters.is_type_material,omitempty" json:"filters.is_type_material,omitempty"`

	// FiltersIsIctvExemplar If true, include only ICTV Exemplars
	FiltersIsIctvExemplar *bool `form:"filters.is_ictv_exemplar,omitempty" json:"filters.is_ictv_exemplar,omitempty"`

	// FiltersExcludeMultiIsolate If true, exclude large multi-isolate projects
	FiltersExcludeMultiIsolate  *bool                                                   `form:"filters.exclude_multi_isolate,omitempty" json:"filters.exclude_multi_isolate,omitempty"`
	FiltersTypeMaterialCategory *V2AssemblyDatasetDescriptorsFilterTypeMaterialCategory `form:"filters.type_material_category,omitempty" json:"filters.type_material_category,omitempty"`

	// TaxExactMatch If true, only return assemblies with the given NCBI Taxonomy ID, or name. Otherwise, assemblies from taxonomy subtree are included, too.
	TaxExactMatch *bool     `form:"tax_exact_match,omitempty" json:"tax_exact_match,omitempty"`
	TableFields   *[]string `form:"table_fields,omitempty" json:"table_fields,omitempty"`

	// ReturnedContent Return either assembly accessions, or complete assembly reports
	ReturnedContent *V2AssemblyDatasetReportsRequestContentType `form:"returned_content,omitempty" json:"returned_content,omitempty"`

	// PageSize The maximum number of genome assembly reports to return. Default is 20 and maximum is 1000. If the number of results exceeds the page size, `page_token` can be used to retrieve the remaining results.
	PageSize *int `form:"page_size,omitempty" json:"page_size,omitempty"`

	// PageToken A page token is returned from an `AssemblyDatasetReportsRequest` call with more than `page_size` results. Use this token, along with the previous `AssemblyDatasetReportsRequest` parameters, to retrieve the next page of results. When `page_token` is empty, all results have been retrieved.
	PageToken     *string          `form:"page_token,omitempty" json:"page_token,omitempty"`
	SortField     *string          `form:"sort.field,omitempty" json:"sort.field,omitempty"`
	SortDirection *V2SortDirection `form:"sort.direction,omitempty" json:"sort.direction,omitempty"`

	// IncludeTabularHeader Whether this request for tabular data should include the header row
	IncludeTabularHeader *V2IncludeTabularHeader `form:"include_tabular_header,omitempty" json:"include_tabular_header,omitempty"`
}

// DownloadOrganellePackageParams defines parameters for DownloadOrganellePackage.
type DownloadOrganellePackageParams struct {
	// ExcludeSequence Set to true to omit the genomic sequence.
	ExcludeSequence *bool `form:"exclude_sequence,omitempty" json:"exclude_sequence,omitempty"`

	// IncludeAnnotationType Select additional types of annotation to include in the data package.  If unset, no annotation is provided.
	IncludeAnnotationType *[]V2AnnotationForOrganelleType `form:"include_annotation_type,omitempty" json:"include_annotation_type,omitempty"`

	// Filename Output file name.
	Filename *string `form:"filename,omitempty" json:"filename,omitempty"`
}

// OrganelleDatareportByAccessionParams defines parameters for OrganelleDatareportByAccession.
type OrganelleDatareportByAccessionParams struct {
	// Taxons NCBI Taxonomy ID or name (common or scientific) at any taxonomic rank
	Taxons         *[]string                 `form:"taxons,omitempty" json:"taxons,omitempty"`
	OrganelleTypes *[]V2reportsOrganelleType `form:"organelle_types,omitempty" json:"organelle_types,omitempty"`

	// FirstReleaseDate Only return organelle assemblies that were released on or after the specified date By default, do not filter.
	FirstReleaseDate *time.Time `form:"first_release_date,omitempty" json:"first_release_date,omitempty"`

	// LastReleaseDate Only return organelle assemblies that were released on or before to the specified date By default, do not filter.
	LastReleaseDate *time.Time `form:"last_release_date,omitempty" json:"last_release_date,omitempty"`

	// TaxExactMatch If true, only return assemblies with the given NCBI Taxonomy ID, or name. Otherwise, assemblies from taxonomy subtree are included, too.
	TaxExactMatch *bool            `form:"tax_exact_match,omitempty" json:"tax_exact_match,omitempty"`
	SortField     *string          `form:"sort.field,omitempty" json:"sort.field,omitempty"`
	SortDirection *V2SortDirection `form:"sort.direction,omitempty" json:"sort.direction,omitempty"`

	// ReturnedContent Return either assembly accessions, or entire assembly-metadata records
	ReturnedContent *V2OrganelleMetadataRequestContentType `form:"returned_content,omitempty" json:"returned_content,omitempty"`

	// TableFormat Optional pre-defined template for processing a tabular data request
	TableFormat *V2OrganelleMetadataRequestOrganelleTableFormat `form:"table_format,omitempty" json:"table_format,omitempty"`

	// IncludeTabularHeader Whether this request for tabular data should include the header row
	IncludeTabularHeader *V2IncludeTabularHeader `form:"include_tabular_header,omitempty" json:"include_tabular_header,omitempty"`
}

// DownloadOrganellePackageByPostParams defines parameters for DownloadOrganellePackageByPost.
type DownloadOrganellePackageByPostParams struct {
	// Filename Output file name.
	Filename *string `form:"filename,omitempty" json:"filename,omitempty"`
}

// OrganelleDatareportByTaxonParams defines parameters for OrganelleDatareportByTaxon.
type OrganelleDatareportByTaxonParams struct {
	OrganelleTypes *[]V2reportsOrganelleType `form:"organelle_types,omitempty" json:"organelle_types,omitempty"`

	// FirstReleaseDate Only return organelle assemblies that were released on or after the specified date By default, do not filter.
	FirstReleaseDate *time.Time `form:"first_release_date,omitempty" json:"first_release_date,omitempty"`

	// LastReleaseDate Only return organelle assemblies that were released on or before to the specified date By default, do not filter.
	LastReleaseDate *time.Time `form:"last_release_date,omitempty" json:"last_release_date,omitempty"`

	// TaxExactMatch If true, only return assemblies with the given NCBI Taxonomy ID, or name. Otherwise, assemblies from taxonomy subtree are included, too.
	TaxExactMatch *bool            `form:"tax_exact_match,omitempty" json:"tax_exact_match,omitempty"`
	SortField     *string          `form:"sort.field,omitempty" json:"sort.field,omitempty"`
	SortDirection *V2SortDirection `form:"sort.direction,omitempty" json:"sort.direction,omitempty"`

	// ReturnedContent Return either assembly accessions, or entire assembly-metadata records
	ReturnedContent *V2OrganelleMetadataRequestContentType `form:"returned_content,omitempty" json:"returned_content,omitempty"`

	// PageSize The maximum number of organelle assemblies to return. Default is 20 and maximum is 1000. If the number of results exceeds the page size, `page_token` can be used to retrieve the remaining results.
	PageSize *int `form:"page_size,omitempty" json:"page_size,omitempty"`

	// PageToken A page token is returned from an `OrganelleMetadata` call with more than `page_size` results. Use this token, along with the previous `OrganelleMetadata` parameters, to retrieve the next page of results. When `page_token` is empty, all results have been retrieved.
	PageToken *string `form:"page_token,omitempty" json:"page_token,omitempty"`

	// TableFormat Optional pre-defined template for processing a tabular data request
	TableFormat *V2OrganelleMetadataRequestOrganelleTableFormat `form:"table_format,omitempty" json:"table_format,omitempty"`

	// IncludeTabularHeader Whether this request for tabular data should include the header row
	IncludeTabularHeader *V2IncludeTabularHeader `form:"include_tabular_header,omitempty" json:"include_tabular_header,omitempty"`
}

// DownloadProkaryoteGenePackagePostParams defines parameters for DownloadProkaryoteGenePackagePost.
type DownloadProkaryoteGenePackagePostParams struct {
	// Filename Output file name.
	Filename *string `form:"filename,omitempty" json:"filename,omitempty"`
}

// DownloadProkaryoteGenePackageParams defines parameters for DownloadProkaryoteGenePackage.
type DownloadProkaryoteGenePackageParams struct {
	// IncludeAnnotationType Select additional types of annotation to include in the data package.  If unset, no annotation is provided.
	IncludeAnnotationType *[]V2Fasta `form:"include_annotation_type,omitempty" json:"include_annotation_type,omitempty"`
	GeneFlankConfigLength *int       `form:"gene_flank_config.length,omitempty" json:"gene_flank_config.length,omitempty"`

	// Taxon NCBI Taxonomy ID or name (common or scientific) at any taxonomic rank When specified, return data from this taxon and its subtree
	Taxon *string `form:"taxon,omitempty" json:"taxon,omitempty"`

	// Filename Output file name.
	Filename *string `form:"filename,omitempty" json:"filename,omitempty"`
}

// DownloadTaxonomyPackageByPostParams defines parameters for DownloadTaxonomyPackageByPost.
type DownloadTaxonomyPackageByPostParams struct {
	// Filename Output file name.
	Filename *string `form:"filename,omitempty" json:"filename,omitempty"`
}

// DownloadTaxonomyPackageParams defines parameters for DownloadTaxonomyPackage.
type DownloadTaxonomyPackageParams struct {
	// AuxReports list additional reports to include with download. TAXONOMY_REPORT is included by default.
	AuxReports *[]V2TaxonomyDatasetRequestTaxonomyReportType `form:"aux_reports,omitempty" json:"aux_reports,omitempty"`

	// Filename Output file name.
	Filename *string `form:"filename,omitempty" json:"filename,omitempty"`
}

// TaxonomyRelatedIdsParams defines parameters for TaxonomyRelatedIds.
type TaxonomyRelatedIdsParams struct {
	// IncludeLineage If true, return reports for all taxonomy nodes in the lineages of the requested tax_id
	IncludeLineage *bool `form:"include_lineage,omitempty" json:"include_lineage,omitempty"`

	// IncludeSubtree If true, return reports for all taxonomy nodes that are children of the requested tax_ids
	IncludeSubtree *bool `form:"include_subtree,omitempty" json:"include_subtree,omitempty"`

	// Ranks Only include taxons of the provided ranks. If empty, return all ranks.
	Ranks *[]V2reportsRankType `form:"ranks,omitempty" json:"ranks,omitempty"`

	// PageSize The maximum number of taxids to return. Default is 20 and maximum is 1000. If the number of results exceeds the page size, `page_token` can be used to retrieve the remaining results.
	PageSize *int `form:"page_size,omitempty" json:"page_size,omitempty"`

	// PageToken A page token is returned from a `GetRelatedTaxids` call with more than `page_size` results. Use this token, along with the previous `TaxonomyRelatedIdRequest` parameters, to retrieve the next page of results. When `page_token` is empty, all results have been retrieved.
	PageToken *string `form:"page_token,omitempty" json:"page_token,omitempty"`
}

// TaxonomyMetadataParams defines parameters for TaxonomyMetadata.
type TaxonomyMetadataParams struct {
	// ReturnedContent Return either tax-ids alone, or entire taxononmy-metadata records
	ReturnedContent *V2TaxonomyMetadataRequestContentType `form:"returned_content,omitempty" json:"returned_content,omitempty"`

	// PageSize The maximum number of taxons to return. Default is 20 and maximum is 1000. If the number of results exceeds the page size, `page_token` can be used to retrieve the remaining results.
	PageSize *int `form:"page_size,omitempty" json:"page_size,omitempty"`

	// IncludeTabularHeader Whether this request for tabular data should include the header row
	IncludeTabularHeader *V2IncludeTabularHeader `form:"include_tabular_header,omitempty" json:"include_tabular_header,omitempty"`

	// PageToken A page token is returned from `GetTaxonomyDataReportFor` and `GetTaxonomyNamesDataReportFor` calls with more than `page_size` results. When `page_token` is empty, all results have been retrieved.
	PageToken   *string                               `form:"page_token,omitempty" json:"page_token,omitempty"`
	TableFormat *V2TaxonomyMetadataRequestTableFormat `form:"table_format,omitempty" json:"table_format,omitempty"`

	// Children Flag for tax explosion.
	Children *bool `form:"children,omitempty" json:"children,omitempty"`

	// Ranks Only include taxons of the provided ranks. If empty, return all ranks.
	Ranks *[]V2reportsRankType `form:"ranks,omitempty" json:"ranks,omitempty"`
}

// TaxonomyDataReportParams defines parameters for TaxonomyDataReport.
type TaxonomyDataReportParams struct {
	// ReturnedContent Return either tax-ids alone, or entire taxononmy-metadata records
	ReturnedContent *V2TaxonomyMetadataRequestContentType `form:"returned_content,omitempty" json:"returned_content,omitempty"`

	// PageSize The maximum number of taxons to return. Default is 20 and maximum is 1000. If the number of results exceeds the page size, `page_token` can be used to retrieve the remaining results.
	PageSize *int `form:"page_size,omitempty" json:"page_size,omitempty"`

	// IncludeTabularHeader Whether this request for tabular data should include the header row
	IncludeTabularHeader *V2IncludeTabularHeader `form:"include_tabular_header,omitempty" json:"include_tabular_header,omitempty"`

	// PageToken A page token is returned from `GetTaxonomyDataReportFor` and `GetTaxonomyNamesDataReportFor` calls with more than `page_size` results. When `page_token` is empty, all results have been retrieved.
	PageToken   *string                               `form:"page_token,omitempty" json:"page_token,omitempty"`
	TableFormat *V2TaxonomyMetadataRequestTableFormat `form:"table_format,omitempty" json:"table_format,omitempty"`

	// Children Flag for tax explosion.
	Children *bool `form:"children,omitempty" json:"children,omitempty"`

	// Ranks Only include taxons of the provided ranks. If empty, return all ranks.
	Ranks *[]V2reportsRankType `form:"ranks,omitempty" json:"ranks,omitempty"`
}

// TaxonomyFilteredSubtreeParams defines parameters for TaxonomyFilteredSubtree.
type TaxonomyFilteredSubtreeParams struct {
	// SpecifiedLimit Limit to specified species
	SpecifiedLimit *bool `form:"specified_limit,omitempty" json:"specified_limit,omitempty"`

	// RankLimits Limit to the provided ranks.  If empty, accept any rank.
	RankLimits *[]V2reportsRankType `form:"rank_limits,omitempty" json:"rank_limits,omitempty"`
}

// TaxonomyNamesParams defines parameters for TaxonomyNames.
type TaxonomyNamesParams struct {
	// ReturnedContent Return either tax-ids alone, or entire taxononmy-metadata records
	ReturnedContent *V2TaxonomyMetadataRequestContentType `form:"returned_content,omitempty" json:"returned_content,omitempty"`

	// PageSize The maximum number of taxons to return. Default is 20 and maximum is 1000. If the number of results exceeds the page size, `page_token` can be used to retrieve the remaining results.
	PageSize *int `form:"page_size,omitempty" json:"page_size,omitempty"`

	// IncludeTabularHeader Whether this request for tabular data should include the header row
	IncludeTabularHeader *V2IncludeTabularHeader `form:"include_tabular_header,omitempty" json:"include_tabular_header,omitempty"`

	// PageToken A page token is returned from `GetTaxonomyDataReportFor` and `GetTaxonomyNamesDataReportFor` calls with more than `page_size` results. When `page_token` is empty, all results have been retrieved.
	PageToken   *string                               `form:"page_token,omitempty" json:"page_token,omitempty"`
	TableFormat *V2TaxonomyMetadataRequestTableFormat `form:"table_format,omitempty" json:"table_format,omitempty"`

	// Children Flag for tax explosion.
	Children *bool `form:"children,omitempty" json:"children,omitempty"`

	// Ranks Only include taxons of the provided ranks. If empty, return all ranks.
	Ranks *[]V2reportsRankType `form:"ranks,omitempty" json:"ranks,omitempty"`
}

// TaxonomyImageParams defines parameters for TaxonomyImage.
type TaxonomyImageParams struct {
	ImageSize *V2ImageSize `form:"image_size,omitempty" json:"image_size,omitempty"`
}

// TaxNameQueryParams defines parameters for TaxNameQuery.
type TaxNameQueryParams struct {
	// TaxRankFilter Set the scope of searched tax ranks when filtering by gene or genome.  Not used for 'all'
	TaxRankFilter *V2OrganismQueryRequestTaxRankFilter `form:"tax_rank_filter,omitempty" json:"tax_rank_filter,omitempty"`

	// TaxonResourceFilter Limit results to those with gene or genome counts (no filter by default)
	TaxonResourceFilter *V2OrganismQueryRequestTaxonResourceFilter `form:"taxon_resource_filter,omitempty" json:"taxon_resource_filter,omitempty"`

	// ExactMatch If true, only return results that exactly match the provided name or tax-id
	ExactMatch *bool `form:"exact_match,omitempty" json:"exact_match,omitempty"`
}

// VirusAnnotationReportsByAcessionsParams defines parameters for VirusAnnotationReportsByAcessions.
type VirusAnnotationReportsByAcessionsParams struct {
	// FilterRefseqOnly If true, limit results to RefSeq genomes.
	FilterRefseqOnly *bool `form:"filter.refseq_only,omitempty" json:"filter.refseq_only,omitempty"`

	// FilterReleasedSince If set, limit results to viral genomes that have been released after a specified date (and optionally, time). April 1, 2020 midnight UTC should be formatted as '2020-04-01T00:00:00.000Z'
	FilterReleasedSince *time.Time `form:"filter.released_since,omitempty" json:"filter.released_since,omitempty"`
	FilterUpdatedSince  *time.Time `form:"filter.updated_since,omitempty" json:"filter.updated_since,omitempty"`

	// FilterHost If set, limit results to genomes extracted from this host (Taxonomy ID or name) All hosts by default
	FilterHost *string `form:"filter.host,omitempty" json:"filter.host,omitempty"`

	// FilterPangolinClassification If set, limit results to genomes classified to this lineage by the PangoLearn tool.
	FilterPangolinClassification *string `form:"filter.pangolin_classification,omitempty" json:"filter.pangolin_classification,omitempty"`

	// FilterGeoLocation Assemblies from this location (country and state, or continent)
	FilterGeoLocation *string `form:"filter.geo_location,omitempty" json:"filter.geo_location,omitempty"`

	// FilterCompleteOnly only include complete genomes.
	FilterCompleteOnly *bool `form:"filter.complete_only,omitempty" json:"filter.complete_only,omitempty"`

	// TableFields Specify which fields to include in the tabular report
	TableFields *[]string `form:"table_fields,omitempty" json:"table_fields,omitempty"`

	// PageSize The maximum number of virus data reports to return. Default is 20 and maximum is 1000. If the number of results exceeds the page size, `page_token` can be used to retrieve the remaining results.
	PageSize *int `form:"page_size,omitempty" json:"page_size,omitempty"`

	// PageToken A page token is returned from a `GetVirusDataReports` call with more than `page_size` results. Use this token, along with the previous `VirusDataReportRequest` parameters, to retrieve the next page of results. When `page_token` is empty, all results have been retrieved.
	PageToken *string `form:"page_token,omitempty" json:"page_token,omitempty"`
}

// VirusReportsByAcessionsParams defines parameters for VirusReportsByAcessions.
type VirusReportsByAcessionsParams struct {
	// FilterRefseqOnly If true, limit results to RefSeq genomes.
	FilterRefseqOnly *bool `form:"filter.refseq_only,omitempty" json:"filter.refseq_only,omitempty"`

	// FilterAnnotatedOnly If true, limit results to annotated genomes.
	FilterAnnotatedOnly *bool `form:"filter.annotated_only,omitempty" json:"filter.annotated_only,omitempty"`

	// FilterReleasedSince If set, limit results to viral genomes that have been released after a specified date (and optionally, time). April 1, 2020 midnight UTC should be formatted as '2020-04-01T00:00:00.000Z'
	FilterReleasedSince *time.Time `form:"filter.released_since,omitempty" json:"filter.released_since,omitempty"`
	FilterUpdatedSince  *time.Time `form:"filter.updated_since,omitempty" json:"filter.updated_since,omitempty"`

	// FilterHost If set, limit results to genomes extracted from this host (Taxonomy ID or name) All hosts by default
	FilterHost *string `form:"filter.host,omitempty" json:"filter.host,omitempty"`

	// FilterPangolinClassification If set, limit results to genomes classified to this lineage by the PangoLearn tool.
	FilterPangolinClassification *string `form:"filter.pangolin_classification,omitempty" json:"filter.pangolin_classification,omitempty"`

	// FilterGeoLocation Assemblies from this location (country and state, or continent)
	FilterGeoLocation *string `form:"filter.geo_location,omitempty" json:"filter.geo_location,omitempty"`

	// FilterCompleteOnly only include complete genomes.
	FilterCompleteOnly *bool `form:"filter.complete_only,omitempty" json:"filter.complete_only,omitempty"`

	// ReturnedContent Return either virus genome accessions, or complete virus metadata
	ReturnedContent *V2VirusDataReportRequestContentType `form:"returned_content,omitempty" json:"returned_content,omitempty"`

	// TableFields Specify which fields to include in the tabular report
	TableFields *[]string `form:"table_fields,omitempty" json:"table_fields,omitempty"`

	// PageSize The maximum number of virus data reports to return. Default is 20 and maximum is 1000. If the number of results exceeds the page size, `page_token` can be used to retrieve the remaining results.
	PageSize *int `form:"page_size,omitempty" json:"page_size,omitempty"`

	// PageToken A page token is returned from a `GetVirusDataReports` call with more than `page_size` results. Use this token, along with the previous `VirusDataReportRequest` parameters, to retrieve the next page of results. When `page_token` is empty, all results have been retrieved.
	PageToken *string `form:"page_token,omitempty" json:"page_token,omitempty"`
}

// VirusGenomeDownloadAccessionParams defines parameters for VirusGenomeDownloadAccession.
type VirusGenomeDownloadAccessionParams struct {
	// RefseqOnly If true, limit results to RefSeq genomes.
	RefseqOnly *bool `form:"refseq_only,omitempty" json:"refseq_only,omitempty"`

	// AnnotatedOnly If true, limit results to annotated genomes.
	AnnotatedOnly *bool `form:"annotated_only,omitempty" json:"annotated_only,omitempty"`

	// ReleasedSince If set, limit results to viral genomes that have been released after a specified date (and optionally, time). April 1, 2020 midnight UTC should be formatted as '2020-04-01T00:00:00.000Z'
	ReleasedSince *time.Time `form:"released_since,omitempty" json:"released_since,omitempty"`
	UpdatedSince  *time.Time `form:"updated_since,omitempty" json:"updated_since,omitempty"`

	// Host If set, limit results to genomes extracted from this host (Taxonomy ID or name) All hosts by default
	Host *string `form:"host,omitempty" json:"host,omitempty"`

	// PangolinClassification If set, limit results to genomes classified to this lineage by the PangoLearn tool.
	PangolinClassification *string `form:"pangolin_classification,omitempty" json:"pangolin_classification,omitempty"`

	// GeoLocation Assemblies from this location (country and state, or continent)
	GeoLocation *string `form:"geo_location,omitempty" json:"geo_location,omitempty"`

	// CompleteOnly only include complete genomes.
	CompleteOnly *bool `form:"complete_only,omitempty" json:"complete_only,omitempty"`

	// IncludeSequence specify which sequence files to include in the download
	IncludeSequence *[]V2ViralSequenceType `form:"include_sequence,omitempty" json:"include_sequence,omitempty"`

	// AuxReport list additional reports to include with download. Data report is included by default.
	AuxReport *[]V2VirusDatasetReportType `form:"aux_report,omitempty" json:"aux_report,omitempty"`

	// UsePsg Experimental approach to retrieving sequence data.
	UsePsg *bool `form:"use_psg,omitempty" json:"use_psg,omitempty"`

	// Filename Output file name.
	Filename *string `form:"filename,omitempty" json:"filename,omitempty"`
}

// VirusGenomeDownloadPostParams defines parameters for VirusGenomeDownloadPost.
type VirusGenomeDownloadPostParams struct {
	// Filename Output file name.
	Filename *string `form:"filename,omitempty" json:"filename,omitempty"`
}

// Sars2ProteinDownloadPostParams defines parameters for Sars2ProteinDownloadPost.
type Sars2ProteinDownloadPostParams struct {
	// Filename Output file name.
	Filename *string `form:"filename,omitempty" json:"filename,omitempty"`
}

// Sars2ProteinSummaryParams defines parameters for Sars2ProteinSummary.
type Sars2ProteinSummaryParams struct {
	// RefseqOnly If true, limit results to RefSeq genomes.
	RefseqOnly *bool `form:"refseq_only,omitempty" json:"refseq_only,omitempty"`

	// AnnotatedOnly If true, limit results to annotated genomes.
	AnnotatedOnly *bool `form:"annotated_only,omitempty" json:"annotated_only,omitempty"`

	// ReleasedSince If set, limit results to viral genomes that have been released after a specified date (and optionally, time). April 1, 2020 midnight UTC should be formatted as '2020-04-01T00:00:00.000Z'
	ReleasedSince *time.Time `form:"released_since,omitempty" json:"released_since,omitempty"`
	UpdatedSince  *time.Time `form:"updated_since,omitempty" json:"updated_since,omitempty"`

	// Host If set, limit results to genomes extracted from this host (Taxonomy ID or name) All hosts by default
	Host *string `form:"host,omitempty" json:"host,omitempty"`

	// GeoLocation Assemblies from this location (country and state, or continent)
	GeoLocation *string `form:"geo_location,omitempty" json:"geo_location,omitempty"`

	// CompleteOnly only include complete genomes.
	CompleteOnly *bool `form:"complete_only,omitempty" json:"complete_only,omitempty"`

	// IncludeSequence Specify which sequence files to include in the download
	IncludeSequence *[]V2ViralSequenceType `form:"include_sequence,omitempty" json:"include_sequence,omitempty"`

	// AuxReport List additional reports to include with download. Data report is included by default.
	AuxReport *[]V2VirusDatasetReportType `form:"aux_report,omitempty" json:"aux_report,omitempty"`
}

// Sars2ProteinDownloadParams defines parameters for Sars2ProteinDownload.
type Sars2ProteinDownloadParams struct {
	// RefseqOnly If true, limit results to RefSeq genomes.
	RefseqOnly *bool `form:"refseq_only,omitempty" json:"refseq_only,omitempty"`

	// AnnotatedOnly If true, limit results to annotated genomes.
	AnnotatedOnly *bool `form:"annotated_only,omitempty" json:"annotated_only,omitempty"`

	// ReleasedSince If set, limit results to viral genomes that have been released after a specified date (and optionally, time). April 1, 2020 midnight UTC should be formatted as '2020-04-01T00:00:00.000Z'
	ReleasedSince *time.Time `form:"released_since,omitempty" json:"released_since,omitempty"`
	UpdatedSince  *time.Time `form:"updated_since,omitempty" json:"updated_since,omitempty"`

	// Host If set, limit results to genomes extracted from this host (Taxonomy ID or name) All hosts by default
	Host *string `form:"host,omitempty" json:"host,omitempty"`

	// GeoLocation Assemblies from this location (country and state, or continent)
	GeoLocation *string `form:"geo_location,omitempty" json:"geo_location,omitempty"`

	// CompleteOnly only include complete genomes.
	CompleteOnly *bool `form:"complete_only,omitempty" json:"complete_only,omitempty"`

	// IncludeSequence Specify which sequence files to include in the download
	IncludeSequence *[]V2ViralSequenceType `form:"include_sequence,omitempty" json:"include_sequence,omitempty"`

	// AuxReport List additional reports to include with download. Data report is included by default.
	AuxReport *[]V2VirusDatasetReportType `form:"aux_report,omitempty" json:"aux_report,omitempty"`

	// Filename Output file name.
	Filename *string `form:"filename,omitempty" json:"filename,omitempty"`
}

// Sars2ProteinTableParams defines parameters for Sars2ProteinTable.
type Sars2ProteinTableParams struct {
	// RefseqOnly If true, limit results to RefSeq genomes.
	RefseqOnly *bool `form:"refseq_only,omitempty" json:"refseq_only,omitempty"`

	// AnnotatedOnly If true, limit results to annotated genomes.
	AnnotatedOnly *bool `form:"annotated_only,omitempty" json:"annotated_only,omitempty"`

	// ReleasedSince If set, limit results to viral genomes that have been released after a specified date (and optionally, time). April 1, 2020 midnight UTC should be formatted as '2020-04-01T00:00:00.000Z'
	ReleasedSince *time.Time `form:"released_since,omitempty" json:"released_since,omitempty"`
	UpdatedSince  *time.Time `form:"updated_since,omitempty" json:"updated_since,omitempty"`

	// Host If set, limit results to genomes extracted from this host (Taxonomy ID or name) All hosts by default
	Host *string `form:"host,omitempty" json:"host,omitempty"`

	// GeoLocation Assemblies from this location (country and state, or continent)
	GeoLocation *string `form:"geo_location,omitempty" json:"geo_location,omitempty"`

	// CompleteOnly only include complete genomes.
	CompleteOnly *bool `form:"complete_only,omitempty" json:"complete_only,omitempty"`

	// TableFields Specify which fields to include in the tabular report
	TableFields *[]V2VirusTableField `form:"table_fields,omitempty" json:"table_fields,omitempty"`

	// IncludeSequence Specify which sequence files to include in the download
	IncludeSequence *[]V2ViralSequenceType `form:"include_sequence,omitempty" json:"include_sequence,omitempty"`

	// AuxReport List additional reports to include with download. Data report is included by default.
	AuxReport *[]V2VirusDatasetReportType `form:"aux_report,omitempty" json:"aux_report,omitempty"`

	// Format Choose download format (tsv, csv or jsonl)
	Format *V2TableFormat `form:"format,omitempty" json:"format,omitempty"`
}

// VirusAnnotationReportsByTaxonParams defines parameters for VirusAnnotationReportsByTaxon.
type VirusAnnotationReportsByTaxonParams struct {
	// FilterRefseqOnly If true, limit results to RefSeq genomes.
	FilterRefseqOnly *bool `form:"filter.refseq_only,omitempty" json:"filter.refseq_only,omitempty"`

	// FilterReleasedSince If set, limit results to viral genomes that have been released after a specified date (and optionally, time). April 1, 2020 midnight UTC should be formatted as '2020-04-01T00:00:00.000Z'
	FilterReleasedSince *time.Time `form:"filter.released_since,omitempty" json:"filter.released_since,omitempty"`
	FilterUpdatedSince  *time.Time `form:"filter.updated_since,omitempty" json:"filter.updated_since,omitempty"`

	// FilterHost If set, limit results to genomes extracted from this host (Taxonomy ID or name) All hosts by default
	FilterHost *string `form:"filter.host,omitempty" json:"filter.host,omitempty"`

	// FilterPangolinClassification If set, limit results to genomes classified to this lineage by the PangoLearn tool.
	FilterPangolinClassification *string `form:"filter.pangolin_classification,omitempty" json:"filter.pangolin_classification,omitempty"`

	// FilterGeoLocation Assemblies from this location (country and state, or continent)
	FilterGeoLocation *string `form:"filter.geo_location,omitempty" json:"filter.geo_location,omitempty"`

	// FilterCompleteOnly only include complete genomes.
	FilterCompleteOnly *bool `form:"filter.complete_only,omitempty" json:"filter.complete_only,omitempty"`

	// TableFields Specify which fields to include in the tabular report
	TableFields *[]string `form:"table_fields,omitempty" json:"table_fields,omitempty"`

	// PageSize The maximum number of virus data reports to return. Default is 20 and maximum is 1000. If the number of results exceeds the page size, `page_token` can be used to retrieve the remaining results.
	PageSize *int `form:"page_size,omitempty" json:"page_size,omitempty"`

	// PageToken A page token is returned from a `GetVirusDataReports` call with more than `page_size` results. Use this token, along with the previous `VirusDataReportRequest` parameters, to retrieve the next page of results. When `page_token` is empty, all results have been retrieved.
	PageToken *string `form:"page_token,omitempty" json:"page_token,omitempty"`
}

// VirusReportsByTaxonParams defines parameters for VirusReportsByTaxon.
type VirusReportsByTaxonParams struct {
	// FilterRefseqOnly If true, limit results to RefSeq genomes.
	FilterRefseqOnly *bool `form:"filter.refseq_only,omitempty" json:"filter.refseq_only,omitempty"`

	// FilterAnnotatedOnly If true, limit results to annotated genomes.
	FilterAnnotatedOnly *bool `form:"filter.annotated_only,omitempty" json:"filter.annotated_only,omitempty"`

	// FilterReleasedSince If set, limit results to viral genomes that have been released after a specified date (and optionally, time). April 1, 2020 midnight UTC should be formatted as '2020-04-01T00:00:00.000Z'
	FilterReleasedSince *time.Time `form:"filter.released_since,omitempty" json:"filter.released_since,omitempty"`
	FilterUpdatedSince  *time.Time `form:"filter.updated_since,omitempty" json:"filter.updated_since,omitempty"`

	// FilterHost If set, limit results to genomes extracted from this host (Taxonomy ID or name) All hosts by default
	FilterHost *string `form:"filter.host,omitempty" json:"filter.host,omitempty"`

	// FilterPangolinClassification If set, limit results to genomes classified to this lineage by the PangoLearn tool.
	FilterPangolinClassification *string `form:"filter.pangolin_classification,omitempty" json:"filter.pangolin_classification,omitempty"`

	// FilterGeoLocation Assemblies from this location (country and state, or continent)
	FilterGeoLocation *string `form:"filter.geo_location,omitempty" json:"filter.geo_location,omitempty"`

	// FilterCompleteOnly only include complete genomes.
	FilterCompleteOnly *bool `form:"filter.complete_only,omitempty" json:"filter.complete_only,omitempty"`

	// ReturnedContent Return either virus genome accessions, or complete virus metadata
	ReturnedContent *V2VirusDataReportRequestContentType `form:"returned_content,omitempty" json:"returned_content,omitempty"`

	// TableFields Specify which fields to include in the tabular report
	TableFields *[]string `form:"table_fields,omitempty" json:"table_fields,omitempty"`

	// PageSize The maximum number of virus data reports to return. Default is 20 and maximum is 1000. If the number of results exceeds the page size, `page_token` can be used to retrieve the remaining results.
	PageSize *int `form:"page_size,omitempty" json:"page_size,omitempty"`

	// PageToken A page token is returned from a `GetVirusDataReports` call with more than `page_size` results. Use this token, along with the previous `VirusDataReportRequest` parameters, to retrieve the next page of results. When `page_token` is empty, all results have been retrieved.
	PageToken *string `form:"page_token,omitempty" json:"page_token,omitempty"`
}

// VirusGenomeSummaryParams defines parameters for VirusGenomeSummary.
type VirusGenomeSummaryParams struct {
	// Accessions genome sequence accessions
	Accessions *[]string `form:"accessions,omitempty" json:"accessions,omitempty"`

	// RefseqOnly If true, limit results to RefSeq genomes.
	RefseqOnly *bool `form:"refseq_only,omitempty" json:"refseq_only,omitempty"`

	// AnnotatedOnly If true, limit results to annotated genomes.
	AnnotatedOnly *bool `form:"annotated_only,omitempty" json:"annotated_only,omitempty"`

	// ReleasedSince If set, limit results to viral genomes that have been released after a specified date (and optionally, time). April 1, 2020 midnight UTC should be formatted as '2020-04-01T00:00:00.000Z'
	ReleasedSince *time.Time `form:"released_since,omitempty" json:"released_since,omitempty"`
	UpdatedSince  *time.Time `form:"updated_since,omitempty" json:"updated_since,omitempty"`

	// Host If set, limit results to genomes extracted from this host (Taxonomy ID or name) All hosts by default
	Host *string `form:"host,omitempty" json:"host,omitempty"`

	// PangolinClassification If set, limit results to genomes classified to this lineage by the PangoLearn tool.
	PangolinClassification *string `form:"pangolin_classification,omitempty" json:"pangolin_classification,omitempty"`

	// GeoLocation Assemblies from this location (country and state, or continent)
	GeoLocation *string `form:"geo_location,omitempty" json:"geo_location,omitempty"`

	// CompleteOnly only include complete genomes.
	CompleteOnly *bool `form:"complete_only,omitempty" json:"complete_only,omitempty"`

	// IncludeSequence specify which sequence files to include in the download
	IncludeSequence *[]V2ViralSequenceType `form:"include_sequence,omitempty" json:"include_sequence,omitempty"`

	// AuxReport list additional reports to include with download. Data report is included by default.
	AuxReport *[]V2VirusDatasetReportType `form:"aux_report,omitempty" json:"aux_report,omitempty"`
}

// VirusGenomeDownloadParams defines parameters for VirusGenomeDownload.
type VirusGenomeDownloadParams struct {
	// RefseqOnly If true, limit results to RefSeq genomes.
	RefseqOnly *bool `form:"refseq_only,omitempty" json:"refseq_only,omitempty"`

	// AnnotatedOnly If true, limit results to annotated genomes.
	AnnotatedOnly *bool `form:"annotated_only,omitempty" json:"annotated_only,omitempty"`

	// ReleasedSince If set, limit results to viral genomes that have been released after a specified date (and optionally, time). April 1, 2020 midnight UTC should be formatted as '2020-04-01T00:00:00.000Z'
	ReleasedSince *time.Time `form:"released_since,omitempty" json:"released_since,omitempty"`
	UpdatedSince  *time.Time `form:"updated_since,omitempty" json:"updated_since,omitempty"`

	// Host If set, limit results to genomes extracted from this host (Taxonomy ID or name) All hosts by default
	Host *string `form:"host,omitempty" json:"host,omitempty"`

	// PangolinClassification If set, limit results to genomes classified to this lineage by the PangoLearn tool.
	PangolinClassification *string `form:"pangolin_classification,omitempty" json:"pangolin_classification,omitempty"`

	// GeoLocation Assemblies from this location (country and state, or continent)
	GeoLocation *string `form:"geo_location,omitempty" json:"geo_location,omitempty"`

	// CompleteOnly only include complete genomes.
	CompleteOnly *bool `form:"complete_only,omitempty" json:"complete_only,omitempty"`

	// IncludeSequence specify which sequence files to include in the download
	IncludeSequence *[]V2ViralSequenceType `form:"include_sequence,omitempty" json:"include_sequence,omitempty"`

	// AuxReport list additional reports to include with download. Data report is included by default.
	AuxReport *[]V2VirusDatasetReportType `form:"aux_report,omitempty" json:"aux_report,omitempty"`

	// UsePsg Experimental approach to retrieving sequence data.
	UsePsg *bool `form:"use_psg,omitempty" json:"use_psg,omitempty"`

	// Filename Output file name.
	Filename *string `form:"filename,omitempty" json:"filename,omitempty"`
}

// VirusGenomeTableParams defines parameters for VirusGenomeTable.
type VirusGenomeTableParams struct {
	// Accessions genome sequence accessions
	Accessions *[]string `form:"accessions,omitempty" json:"accessions,omitempty"`

	// RefseqOnly If true, limit results to RefSeq genomes.
	RefseqOnly *bool `form:"refseq_only,omitempty" json:"refseq_only,omitempty"`

	// AnnotatedOnly If true, limit results to annotated genomes.
	AnnotatedOnly *bool `form:"annotated_only,omitempty" json:"annotated_only,omitempty"`

	// ReleasedSince If set, limit results to viral genomes that have been released after a specified date (and optionally, time). April 1, 2020 midnight UTC should be formatted as '2020-04-01T00:00:00.000Z'
	ReleasedSince *time.Time `form:"released_since,omitempty" json:"released_since,omitempty"`
	UpdatedSince  *time.Time `form:"updated_since,omitempty" json:"updated_since,omitempty"`

	// Host If set, limit results to genomes extracted from this host (Taxonomy ID or name) All hosts by default
	Host *string `form:"host,omitempty" json:"host,omitempty"`

	// PangolinClassification If set, limit results to genomes classified to this lineage by the PangoLearn tool.
	PangolinClassification *string `form:"pangolin_classification,omitempty" json:"pangolin_classification,omitempty"`

	// GeoLocation Assemblies from this location (country and state, or continent)
	GeoLocation *string `form:"geo_location,omitempty" json:"geo_location,omitempty"`

	// CompleteOnly only include complete genomes.
	CompleteOnly *bool `form:"complete_only,omitempty" json:"complete_only,omitempty"`

	// TableFields Specify which fields to include in the tabular report
	TableFields *[]V2VirusTableField `form:"table_fields,omitempty" json:"table_fields,omitempty"`

	// IncludeSequence specify which sequence files to include in the download
	IncludeSequence *[]V2ViralSequenceType `form:"include_sequence,omitempty" json:"include_sequence,omitempty"`

	// AuxReport list additional reports to include with download. Data report is included by default.
	AuxReport *[]V2VirusDatasetReportType `form:"aux_report,omitempty" json:"aux_report,omitempty"`

	// Format Choose download format (tsv, csv or jsonl)
	Format *V2TableFormat `form:"format,omitempty" json:"format,omitempty"`
}

// GeneMetadataByPostJSONRequestBody defines body for GeneMetadataByPost for application/json ContentType.
type GeneMetadataByPostJSONRequestBody = V2GeneDatasetReportsRequest

// DownloadGenePackagePostJSONRequestBody defines body for DownloadGenePackagePost for application/json ContentType.
type DownloadGenePackagePostJSONRequestBody = V2GeneDatasetRequest

// GeneDownloadSummaryByPostJSONRequestBody defines body for GeneDownloadSummaryByPost for application/json ContentType.
type GeneDownloadSummaryByPostJSONRequestBody = V2GeneDatasetRequest

// GeneLinksByIdByPostJSONRequestBody defines body for GeneLinksByIdByPost for application/json ContentType.
type GeneLinksByIdByPostJSONRequestBody = V2GeneLinksRequest

// GeneOrthologsByPostJSONRequestBody defines body for GeneOrthologsByPost for application/json ContentType.
type GeneOrthologsByPostJSONRequestBody = V2OrthologRequest

// GeneCountsForTaxonByPostJSONRequestBody defines body for GeneCountsForTaxonByPost for application/json ContentType.
type GeneCountsForTaxonByPostJSONRequestBody = V2GeneCountsByTaxonRequest

// GenomeAnnotationReportByPostJSONRequestBody defines body for GenomeAnnotationReportByPost for application/json ContentType.
type GenomeAnnotationReportByPostJSONRequestBody = V2GenomeAnnotationRequest

// DownloadGenomeAnnotationPackageByPostJSONRequestBody defines body for DownloadGenomeAnnotationPackageByPost for application/json ContentType.
type DownloadGenomeAnnotationPackageByPostJSONRequestBody = V2GenomeAnnotationRequest

// GenomeAnnotationDownloadSummaryByPostJSONRequestBody defines body for GenomeAnnotationDownloadSummaryByPost for application/json ContentType.
type GenomeAnnotationDownloadSummaryByPostJSONRequestBody = V2GenomeAnnotationRequest

// AnnotationReportFacetsByPostJSONRequestBody defines body for AnnotationReportFacetsByPost for application/json ContentType.
type AnnotationReportFacetsByPostJSONRequestBody = V2GenomeAnnotationRequest

// CheckAssemblyAvailabilityPostJSONRequestBody defines body for CheckAssemblyAvailabilityPost for application/json ContentType.
type CheckAssemblyAvailabilityPostJSONRequestBody = V2AssemblyDatasetRequest

// CheckmHistogramByTaxonByPostJSONRequestBody defines body for CheckmHistogramByTaxonByPost for application/json ContentType.
type CheckmHistogramByTaxonByPostJSONRequestBody = V2AssemblyCheckMHistogramRequest

// GenomeDatasetReportByPostJSONRequestBody defines body for GenomeDatasetReportByPost for application/json ContentType.
type GenomeDatasetReportByPostJSONRequestBody = V2AssemblyDatasetReportsRequest

// DownloadAssemblyPackagePostJSONRequestBody defines body for DownloadAssemblyPackagePost for application/json ContentType.
type DownloadAssemblyPackagePostJSONRequestBody = V2AssemblyDatasetRequest

// GenomeDownloadSummaryByPostJSONRequestBody defines body for GenomeDownloadSummaryByPost for application/json ContentType.
type GenomeDownloadSummaryByPostJSONRequestBody = V2AssemblyDatasetRequest

// GenomeLinksByAccessionByPostJSONRequestBody defines body for GenomeLinksByAccessionByPost for application/json ContentType.
type GenomeLinksByAccessionByPostJSONRequestBody = V2AssemblyLinksRequest

// AssemblyRevisionHistoryByPostJSONRequestBody defines body for AssemblyRevisionHistoryByPost for application/json ContentType.
type AssemblyRevisionHistoryByPostJSONRequestBody = V2AssemblyRevisionHistoryRequest

// AssemblyAccessionsForSequenceAccessionByPostJSONRequestBody defines body for AssemblyAccessionsForSequenceAccessionByPost for application/json ContentType.
type AssemblyAccessionsForSequenceAccessionByPostJSONRequestBody = V2SequenceAccessionRequest

// GenomeSequenceReportByPostJSONRequestBody defines body for GenomeSequenceReportByPost for application/json ContentType.
type GenomeSequenceReportByPostJSONRequestBody = V2AssemblySequenceReportsRequest

// OrganelleDatareportByPostJSONRequestBody defines body for OrganelleDatareportByPost for application/json ContentType.
type OrganelleDatareportByPostJSONRequestBody = V2OrganelleMetadataRequest

// DownloadOrganellePackageByPostJSONRequestBody defines body for DownloadOrganellePackageByPost for application/json ContentType.
type DownloadOrganellePackageByPostJSONRequestBody = V2OrganelleDownloadRequest

// DownloadProkaryoteGenePackagePostJSONRequestBody defines body for DownloadProkaryoteGenePackagePost for application/json ContentType.
type DownloadProkaryoteGenePackagePostJSONRequestBody = V2ProkaryoteGeneRequest

// TaxonomyMetadataPostJSONRequestBody defines body for TaxonomyMetadataPost for application/json ContentType.
type TaxonomyMetadataPostJSONRequestBody = V2TaxonomyMetadataRequest

// TaxonomyDataReportPostJSONRequestBody defines body for TaxonomyDataReportPost for application/json ContentType.
type TaxonomyDataReportPostJSONRequestBody = V2TaxonomyMetadataRequest

// DownloadTaxonomyPackageByPostJSONRequestBody defines body for DownloadTaxonomyPackageByPost for application/json ContentType.
type DownloadTaxonomyPackageByPostJSONRequestBody = V2TaxonomyDatasetRequest

// TaxonomyFilteredSubtreePostJSONRequestBody defines body for TaxonomyFilteredSubtreePost for application/json ContentType.
type TaxonomyFilteredSubtreePostJSONRequestBody = V2TaxonomyFilteredSubtreeRequest

// TaxonomyImagePostJSONRequestBody defines body for TaxonomyImagePost for application/json ContentType.
type TaxonomyImagePostJSONRequestBody = V2TaxonomyImageRequest

// TaxonomyImageMetadataPostJSONRequestBody defines body for TaxonomyImageMetadataPost for application/json ContentType.
type TaxonomyImageMetadataPostJSONRequestBody = V2TaxonomyImageMetadataRequest

// TaxonomyLinksByPostJSONRequestBody defines body for TaxonomyLinksByPost for application/json ContentType.
type TaxonomyLinksByPostJSONRequestBody = V2TaxonomyLinksRequest

// TaxonomyNamesPostJSONRequestBody defines body for TaxonomyNamesPost for application/json ContentType.
type TaxonomyNamesPostJSONRequestBody = V2TaxonomyMetadataRequest

// TaxonomyRelatedIdsPostJSONRequestBody defines body for TaxonomyRelatedIdsPost for application/json ContentType.
type TaxonomyRelatedIdsPostJSONRequestBody = V2TaxonomyRelatedIdRequest

// TaxNameQueryByPostJSONRequestBody defines body for TaxNameQueryByPost for application/json ContentType.
type TaxNameQueryByPostJSONRequestBody = V2OrganismQueryRequest

// VirusReportsByPostJSONRequestBody defines body for VirusReportsByPost for application/json ContentType.
type VirusReportsByPostJSONRequestBody = V2VirusDataReportRequest

// VirusAnnotationReportsByPostJSONRequestBody defines body for VirusAnnotationReportsByPost for application/json ContentType.
type VirusAnnotationReportsByPostJSONRequestBody = V2VirusAnnotationReportRequest

// VirusAccessionAvailabilityPostJSONRequestBody defines body for VirusAccessionAvailabilityPost for application/json ContentType.
type VirusAccessionAvailabilityPostJSONRequestBody = V2VirusAvailabilityRequest

// VirusGenomeSummaryByPostJSONRequestBody defines body for VirusGenomeSummaryByPost for application/json ContentType.
type VirusGenomeSummaryByPostJSONRequestBody = V2VirusDatasetRequest

// VirusGenomeDownloadPostJSONRequestBody defines body for VirusGenomeDownloadPost for application/json ContentType.
type VirusGenomeDownloadPostJSONRequestBody = V2VirusDatasetRequest

// Sars2ProteinSummaryByPostJSONRequestBody defines body for Sars2ProteinSummaryByPost for application/json ContentType.
type Sars2ProteinSummaryByPostJSONRequestBody = V2Sars2ProteinDatasetRequest

// Sars2ProteinDownloadPostJSONRequestBody defines body for Sars2ProteinDownloadPost for application/json ContentType.
type Sars2ProteinDownloadPostJSONRequestBody = V2Sars2ProteinDatasetRequest

// Getter for additional properties for V2TaxonomyFilteredSubtreeResponseEdgesEntry. Returns the specified
// element and whether it was found
func (a V2TaxonomyFilteredSubtreeResponseEdgesEntry) Get(fieldName string) (value V2TaxonomyFilteredSubtreeResponseEdge, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for V2TaxonomyFilteredSubtreeResponseEdgesEntry
func (a *V2TaxonomyFilteredSubtreeResponseEdgesEntry) Set(fieldName string, value V2TaxonomyFilteredSubtreeResponseEdge) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]V2TaxonomyFilteredSubtreeResponseEdge)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for V2TaxonomyFilteredSubtreeResponseEdgesEntry to handle AdditionalProperties
func (a *V2TaxonomyFilteredSubtreeResponseEdgesEntry) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["default"]; found {
		err = json.Unmarshal(raw, &a.Default)
		if err != nil {
			return fmt.Errorf("error reading 'default': %w", err)
		}
		delete(object, "default")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]V2TaxonomyFilteredSubtreeResponseEdge)
		for fieldName, fieldBuf := range object {
			var fieldVal V2TaxonomyFilteredSubtreeResponseEdge
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for V2TaxonomyFilteredSubtreeResponseEdgesEntry to handle AdditionalProperties
func (a V2TaxonomyFilteredSubtreeResponseEdgesEntry) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.Default != nil {
		object["default"], err = json.Marshal(a.Default)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'default': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// BioSampleDatasetReport request
	BioSampleDatasetReport(ctx context.Context, accessions []string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GeneMetadataByPostWithBody request with any body
	GeneMetadataByPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	GeneMetadataByPost(ctx context.Context, body GeneMetadataByPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GeneMetadataByAccession request
	GeneMetadataByAccession(ctx context.Context, accessions []string, params *GeneMetadataByAccessionParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DownloadGenePackagePostWithBody request with any body
	DownloadGenePackagePostWithBody(ctx context.Context, params *DownloadGenePackagePostParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DownloadGenePackagePost(ctx context.Context, params *DownloadGenePackagePostParams, body DownloadGenePackagePostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GeneDownloadSummaryByPostWithBody request with any body
	GeneDownloadSummaryByPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	GeneDownloadSummaryByPost(ctx context.Context, body GeneDownloadSummaryByPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GeneReportsById request
	GeneReportsById(ctx context.Context, geneIds []int, params *GeneReportsByIdParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DownloadGenePackage request
	DownloadGenePackage(ctx context.Context, geneIds []int, params *DownloadGenePackageParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GeneDownloadSummaryById request
	GeneDownloadSummaryById(ctx context.Context, geneIds []int, params *GeneDownloadSummaryByIdParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GeneLinksById request
	GeneLinksById(ctx context.Context, geneIds []int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GeneOrthologsById request
	GeneOrthologsById(ctx context.Context, geneId int, params *GeneOrthologsByIdParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GeneLinksByIdByPostWithBody request with any body
	GeneLinksByIdByPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	GeneLinksByIdByPost(ctx context.Context, body GeneLinksByIdByPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GeneOrthologsByPostWithBody request with any body
	GeneOrthologsByPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	GeneOrthologsByPost(ctx context.Context, body GeneOrthologsByPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GeneMetadataByTaxAndSymbol request
	GeneMetadataByTaxAndSymbol(ctx context.Context, symbols []string, taxon string, params *GeneMetadataByTaxAndSymbolParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GeneCountsForTaxonByPostWithBody request with any body
	GeneCountsForTaxonByPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	GeneCountsForTaxonByPost(ctx context.Context, body GeneCountsForTaxonByPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GeneReportsByTaxon request
	GeneReportsByTaxon(ctx context.Context, taxon string, params *GeneReportsByTaxonParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GeneChromosomeSummary request
	GeneChromosomeSummary(ctx context.Context, taxon string, annotationName string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GeneCountsForTaxon request
	GeneCountsForTaxon(ctx context.Context, taxon string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CheckAssemblyAvailability request
	CheckAssemblyAvailability(ctx context.Context, accessions []string, params *CheckAssemblyAvailabilityParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GenomeDatasetReport request
	GenomeDatasetReport(ctx context.Context, accessions []string, params *GenomeDatasetReportParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DownloadAssemblyPackage request
	DownloadAssemblyPackage(ctx context.Context, accessions []string, params *DownloadAssemblyPackageParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GenomeDownloadSummary request
	GenomeDownloadSummary(ctx context.Context, accessions []string, params *GenomeDownloadSummaryParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GenomeLinksByAccession request
	GenomeLinksByAccession(ctx context.Context, accessions []string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GenomeAnnotationReport request
	GenomeAnnotationReport(ctx context.Context, accession string, params *GenomeAnnotationReportParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DownloadGenomeAnnotationPackage request
	DownloadGenomeAnnotationPackage(ctx context.Context, accession string, params *DownloadGenomeAnnotationPackageParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GenomeAnnotationDownloadSummary request
	GenomeAnnotationDownloadSummary(ctx context.Context, accession string, params *GenomeAnnotationDownloadSummaryParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AnnotationReportFacets request
	AnnotationReportFacets(ctx context.Context, accession string, annotationIds []string, params *AnnotationReportFacetsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AssemblyRevisionHistoryByGet request
	AssemblyRevisionHistoryByGet(ctx context.Context, accession string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GenomeSequenceReport request
	GenomeSequenceReport(ctx context.Context, accession string, params *GenomeSequenceReportParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GenomeAnnotationReportByPostWithBody request with any body
	GenomeAnnotationReportByPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	GenomeAnnotationReportByPost(ctx context.Context, body GenomeAnnotationReportByPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DownloadGenomeAnnotationPackageByPostWithBody request with any body
	DownloadGenomeAnnotationPackageByPostWithBody(ctx context.Context, params *DownloadGenomeAnnotationPackageByPostParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DownloadGenomeAnnotationPackageByPost(ctx context.Context, params *DownloadGenomeAnnotationPackageByPostParams, body DownloadGenomeAnnotationPackageByPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GenomeAnnotationDownloadSummaryByPostWithBody request with any body
	GenomeAnnotationDownloadSummaryByPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	GenomeAnnotationDownloadSummaryByPost(ctx context.Context, body GenomeAnnotationDownloadSummaryByPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AnnotationReportFacetsByPostWithBody request with any body
	AnnotationReportFacetsByPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AnnotationReportFacetsByPost(ctx context.Context, body AnnotationReportFacetsByPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GenomeDatasetReportsByAssemblyName request
	GenomeDatasetReportsByAssemblyName(ctx context.Context, assemblyNames []string, params *GenomeDatasetReportsByAssemblyNameParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GenomeDatasetReportsByBioproject request
	GenomeDatasetReportsByBioproject(ctx context.Context, bioprojects []string, params *GenomeDatasetReportsByBioprojectParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GenomeDatasetReportsByBiosampleId request
	GenomeDatasetReportsByBiosampleId(ctx context.Context, biosampleIds []string, params *GenomeDatasetReportsByBiosampleIdParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CheckAssemblyAvailabilityPostWithBody request with any body
	CheckAssemblyAvailabilityPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CheckAssemblyAvailabilityPost(ctx context.Context, body CheckAssemblyAvailabilityPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CheckmHistogramByTaxonByPostWithBody request with any body
	CheckmHistogramByTaxonByPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CheckmHistogramByTaxonByPost(ctx context.Context, body CheckmHistogramByTaxonByPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GenomeDatasetReportByPostWithBody request with any body
	GenomeDatasetReportByPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	GenomeDatasetReportByPost(ctx context.Context, body GenomeDatasetReportByPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DownloadAssemblyPackagePostWithBody request with any body
	DownloadAssemblyPackagePostWithBody(ctx context.Context, params *DownloadAssemblyPackagePostParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DownloadAssemblyPackagePost(ctx context.Context, params *DownloadAssemblyPackagePostParams, body DownloadAssemblyPackagePostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GenomeDownloadSummaryByPostWithBody request with any body
	GenomeDownloadSummaryByPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	GenomeDownloadSummaryByPost(ctx context.Context, body GenomeDownloadSummaryByPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GenomeLinksByAccessionByPostWithBody request with any body
	GenomeLinksByAccessionByPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	GenomeLinksByAccessionByPost(ctx context.Context, body GenomeLinksByAccessionByPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AssemblyRevisionHistoryByPostWithBody request with any body
	AssemblyRevisionHistoryByPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AssemblyRevisionHistoryByPost(ctx context.Context, body AssemblyRevisionHistoryByPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AssemblyAccessionsForSequenceAccession request
	AssemblyAccessionsForSequenceAccession(ctx context.Context, accession string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AssemblyAccessionsForSequenceAccessionByPostWithBody request with any body
	AssemblyAccessionsForSequenceAccessionByPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AssemblyAccessionsForSequenceAccessionByPost(ctx context.Context, body AssemblyAccessionsForSequenceAccessionByPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GenomeSequenceReportByPostWithBody request with any body
	GenomeSequenceReportByPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	GenomeSequenceReportByPost(ctx context.Context, body GenomeSequenceReportByPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CheckmHistogramByTaxon request
	CheckmHistogramByTaxon(ctx context.Context, speciesTaxon string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GenomeDatasetReportsByTaxon request
	GenomeDatasetReportsByTaxon(ctx context.Context, taxons []string, params *GenomeDatasetReportsByTaxonParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GenomeDatasetReportsByWgs request
	GenomeDatasetReportsByWgs(ctx context.Context, wgsAccessions []string, params *GenomeDatasetReportsByWgsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DownloadOrganellePackage request
	DownloadOrganellePackage(ctx context.Context, accessions []string, params *DownloadOrganellePackageParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// OrganelleDatareportByAccession request
	OrganelleDatareportByAccession(ctx context.Context, accessions []string, params *OrganelleDatareportByAccessionParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// OrganelleDatareportByPostWithBody request with any body
	OrganelleDatareportByPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	OrganelleDatareportByPost(ctx context.Context, body OrganelleDatareportByPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DownloadOrganellePackageByPostWithBody request with any body
	DownloadOrganellePackageByPostWithBody(ctx context.Context, params *DownloadOrganellePackageByPostParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DownloadOrganellePackageByPost(ctx context.Context, params *DownloadOrganellePackageByPostParams, body DownloadOrganellePackageByPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// OrganelleDatareportByTaxon request
	OrganelleDatareportByTaxon(ctx context.Context, taxons []string, params *OrganelleDatareportByTaxonParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DownloadProkaryoteGenePackagePostWithBody request with any body
	DownloadProkaryoteGenePackagePostWithBody(ctx context.Context, params *DownloadProkaryoteGenePackagePostParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DownloadProkaryoteGenePackagePost(ctx context.Context, params *DownloadProkaryoteGenePackagePostParams, body DownloadProkaryoteGenePackagePostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DownloadProkaryoteGenePackage request
	DownloadProkaryoteGenePackage(ctx context.Context, accessions []string, params *DownloadProkaryoteGenePackageParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TaxonomyMetadataPostWithBody request with any body
	TaxonomyMetadataPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	TaxonomyMetadataPost(ctx context.Context, body TaxonomyMetadataPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TaxonomyDataReportPostWithBody request with any body
	TaxonomyDataReportPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	TaxonomyDataReportPost(ctx context.Context, body TaxonomyDataReportPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DownloadTaxonomyPackageByPostWithBody request with any body
	DownloadTaxonomyPackageByPostWithBody(ctx context.Context, params *DownloadTaxonomyPackageByPostParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DownloadTaxonomyPackageByPost(ctx context.Context, params *DownloadTaxonomyPackageByPostParams, body DownloadTaxonomyPackageByPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TaxonomyFilteredSubtreePostWithBody request with any body
	TaxonomyFilteredSubtreePostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	TaxonomyFilteredSubtreePost(ctx context.Context, body TaxonomyFilteredSubtreePostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TaxonomyImagePostWithBody request with any body
	TaxonomyImagePostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	TaxonomyImagePost(ctx context.Context, body TaxonomyImagePostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TaxonomyImageMetadataPostWithBody request with any body
	TaxonomyImageMetadataPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	TaxonomyImageMetadataPost(ctx context.Context, body TaxonomyImageMetadataPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TaxonomyLinksByPostWithBody request with any body
	TaxonomyLinksByPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	TaxonomyLinksByPost(ctx context.Context, body TaxonomyLinksByPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TaxonomyNamesPostWithBody request with any body
	TaxonomyNamesPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	TaxonomyNamesPost(ctx context.Context, body TaxonomyNamesPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TaxonomyRelatedIdsPostWithBody request with any body
	TaxonomyRelatedIdsPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	TaxonomyRelatedIdsPost(ctx context.Context, body TaxonomyRelatedIdsPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DownloadTaxonomyPackage request
	DownloadTaxonomyPackage(ctx context.Context, taxIds []int, params *DownloadTaxonomyPackageParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TaxonomyRelatedIds request
	TaxonomyRelatedIds(ctx context.Context, taxId int, params *TaxonomyRelatedIdsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TaxonomyMetadata request
	TaxonomyMetadata(ctx context.Context, taxons []string, params *TaxonomyMetadataParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TaxonomyDataReport request
	TaxonomyDataReport(ctx context.Context, taxons []string, params *TaxonomyDataReportParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TaxonomyFilteredSubtree request
	TaxonomyFilteredSubtree(ctx context.Context, taxons []string, params *TaxonomyFilteredSubtreeParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TaxonomyNames request
	TaxonomyNames(ctx context.Context, taxons []string, params *TaxonomyNamesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TaxonomyImage request
	TaxonomyImage(ctx context.Context, taxon string, params *TaxonomyImageParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TaxonomyImageMetadata request
	TaxonomyImageMetadata(ctx context.Context, taxon string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TaxonomyLinks request
	TaxonomyLinks(ctx context.Context, taxon string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TaxNameQueryByPostWithBody request with any body
	TaxNameQueryByPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	TaxNameQueryByPost(ctx context.Context, body TaxNameQueryByPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TaxNameQuery request
	TaxNameQuery(ctx context.Context, taxonQuery string, params *TaxNameQueryParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Version request
	Version(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// VirusReportsByPostWithBody request with any body
	VirusReportsByPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	VirusReportsByPost(ctx context.Context, body VirusReportsByPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// VirusAnnotationReportsByAcessions request
	VirusAnnotationReportsByAcessions(ctx context.Context, accessions []string, params *VirusAnnotationReportsByAcessionsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// VirusAccessionAvailability request
	VirusAccessionAvailability(ctx context.Context, accessions []string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// VirusReportsByAcessions request
	VirusReportsByAcessions(ctx context.Context, accessions []string, params *VirusReportsByAcessionsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// VirusGenomeDownloadAccession request
	VirusGenomeDownloadAccession(ctx context.Context, accessions []string, params *VirusGenomeDownloadAccessionParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// VirusAnnotationReportsByPostWithBody request with any body
	VirusAnnotationReportsByPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	VirusAnnotationReportsByPost(ctx context.Context, body VirusAnnotationReportsByPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// VirusAccessionAvailabilityPostWithBody request with any body
	VirusAccessionAvailabilityPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	VirusAccessionAvailabilityPost(ctx context.Context, body VirusAccessionAvailabilityPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// VirusGenomeSummaryByPostWithBody request with any body
	VirusGenomeSummaryByPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	VirusGenomeSummaryByPost(ctx context.Context, body VirusGenomeSummaryByPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// VirusGenomeDownloadPostWithBody request with any body
	VirusGenomeDownloadPostWithBody(ctx context.Context, params *VirusGenomeDownloadPostParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	VirusGenomeDownloadPost(ctx context.Context, params *VirusGenomeDownloadPostParams, body VirusGenomeDownloadPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Sars2ProteinSummaryByPostWithBody request with any body
	Sars2ProteinSummaryByPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	Sars2ProteinSummaryByPost(ctx context.Context, body Sars2ProteinSummaryByPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Sars2ProteinDownloadPostWithBody request with any body
	Sars2ProteinDownloadPostWithBody(ctx context.Context, params *Sars2ProteinDownloadPostParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	Sars2ProteinDownloadPost(ctx context.Context, params *Sars2ProteinDownloadPostParams, body Sars2ProteinDownloadPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Sars2ProteinSummary request
	Sars2ProteinSummary(ctx context.Context, proteins []string, params *Sars2ProteinSummaryParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Sars2ProteinDownload request
	Sars2ProteinDownload(ctx context.Context, proteins []string, params *Sars2ProteinDownloadParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Sars2ProteinTable request
	Sars2ProteinTable(ctx context.Context, proteins []string, params *Sars2ProteinTableParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// VirusAnnotationReportsByTaxon request
	VirusAnnotationReportsByTaxon(ctx context.Context, taxon string, params *VirusAnnotationReportsByTaxonParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// VirusReportsByTaxon request
	VirusReportsByTaxon(ctx context.Context, taxon string, params *VirusReportsByTaxonParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// VirusGenomeSummary request
	VirusGenomeSummary(ctx context.Context, taxon string, params *VirusGenomeSummaryParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// VirusGenomeDownload request
	VirusGenomeDownload(ctx context.Context, taxon string, params *VirusGenomeDownloadParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// VirusGenomeTable request
	VirusGenomeTable(ctx context.Context, taxon string, params *VirusGenomeTableParams, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) BioSampleDatasetReport(ctx context.Context, accessions []string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewBioSampleDatasetReportRequest(c.Server, accessions)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GeneMetadataByPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGeneMetadataByPostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GeneMetadataByPost(ctx context.Context, body GeneMetadataByPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGeneMetadataByPostRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GeneMetadataByAccession(ctx context.Context, accessions []string, params *GeneMetadataByAccessionParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGeneMetadataByAccessionRequest(c.Server, accessions, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DownloadGenePackagePostWithBody(ctx context.Context, params *DownloadGenePackagePostParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDownloadGenePackagePostRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DownloadGenePackagePost(ctx context.Context, params *DownloadGenePackagePostParams, body DownloadGenePackagePostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDownloadGenePackagePostRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GeneDownloadSummaryByPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGeneDownloadSummaryByPostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GeneDownloadSummaryByPost(ctx context.Context, body GeneDownloadSummaryByPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGeneDownloadSummaryByPostRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GeneReportsById(ctx context.Context, geneIds []int, params *GeneReportsByIdParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGeneReportsByIdRequest(c.Server, geneIds, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DownloadGenePackage(ctx context.Context, geneIds []int, params *DownloadGenePackageParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDownloadGenePackageRequest(c.Server, geneIds, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GeneDownloadSummaryById(ctx context.Context, geneIds []int, params *GeneDownloadSummaryByIdParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGeneDownloadSummaryByIdRequest(c.Server, geneIds, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GeneLinksById(ctx context.Context, geneIds []int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGeneLinksByIdRequest(c.Server, geneIds)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GeneOrthologsById(ctx context.Context, geneId int, params *GeneOrthologsByIdParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGeneOrthologsByIdRequest(c.Server, geneId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GeneLinksByIdByPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGeneLinksByIdByPostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GeneLinksByIdByPost(ctx context.Context, body GeneLinksByIdByPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGeneLinksByIdByPostRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GeneOrthologsByPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGeneOrthologsByPostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GeneOrthologsByPost(ctx context.Context, body GeneOrthologsByPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGeneOrthologsByPostRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GeneMetadataByTaxAndSymbol(ctx context.Context, symbols []string, taxon string, params *GeneMetadataByTaxAndSymbolParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGeneMetadataByTaxAndSymbolRequest(c.Server, symbols, taxon, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GeneCountsForTaxonByPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGeneCountsForTaxonByPostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GeneCountsForTaxonByPost(ctx context.Context, body GeneCountsForTaxonByPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGeneCountsForTaxonByPostRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GeneReportsByTaxon(ctx context.Context, taxon string, params *GeneReportsByTaxonParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGeneReportsByTaxonRequest(c.Server, taxon, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GeneChromosomeSummary(ctx context.Context, taxon string, annotationName string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGeneChromosomeSummaryRequest(c.Server, taxon, annotationName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GeneCountsForTaxon(ctx context.Context, taxon string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGeneCountsForTaxonRequest(c.Server, taxon)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CheckAssemblyAvailability(ctx context.Context, accessions []string, params *CheckAssemblyAvailabilityParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCheckAssemblyAvailabilityRequest(c.Server, accessions, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GenomeDatasetReport(ctx context.Context, accessions []string, params *GenomeDatasetReportParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGenomeDatasetReportRequest(c.Server, accessions, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DownloadAssemblyPackage(ctx context.Context, accessions []string, params *DownloadAssemblyPackageParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDownloadAssemblyPackageRequest(c.Server, accessions, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GenomeDownloadSummary(ctx context.Context, accessions []string, params *GenomeDownloadSummaryParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGenomeDownloadSummaryRequest(c.Server, accessions, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GenomeLinksByAccession(ctx context.Context, accessions []string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGenomeLinksByAccessionRequest(c.Server, accessions)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GenomeAnnotationReport(ctx context.Context, accession string, params *GenomeAnnotationReportParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGenomeAnnotationReportRequest(c.Server, accession, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DownloadGenomeAnnotationPackage(ctx context.Context, accession string, params *DownloadGenomeAnnotationPackageParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDownloadGenomeAnnotationPackageRequest(c.Server, accession, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GenomeAnnotationDownloadSummary(ctx context.Context, accession string, params *GenomeAnnotationDownloadSummaryParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGenomeAnnotationDownloadSummaryRequest(c.Server, accession, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AnnotationReportFacets(ctx context.Context, accession string, annotationIds []string, params *AnnotationReportFacetsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAnnotationReportFacetsRequest(c.Server, accession, annotationIds, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AssemblyRevisionHistoryByGet(ctx context.Context, accession string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAssemblyRevisionHistoryByGetRequest(c.Server, accession)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GenomeSequenceReport(ctx context.Context, accession string, params *GenomeSequenceReportParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGenomeSequenceReportRequest(c.Server, accession, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GenomeAnnotationReportByPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGenomeAnnotationReportByPostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GenomeAnnotationReportByPost(ctx context.Context, body GenomeAnnotationReportByPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGenomeAnnotationReportByPostRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DownloadGenomeAnnotationPackageByPostWithBody(ctx context.Context, params *DownloadGenomeAnnotationPackageByPostParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDownloadGenomeAnnotationPackageByPostRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DownloadGenomeAnnotationPackageByPost(ctx context.Context, params *DownloadGenomeAnnotationPackageByPostParams, body DownloadGenomeAnnotationPackageByPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDownloadGenomeAnnotationPackageByPostRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GenomeAnnotationDownloadSummaryByPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGenomeAnnotationDownloadSummaryByPostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GenomeAnnotationDownloadSummaryByPost(ctx context.Context, body GenomeAnnotationDownloadSummaryByPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGenomeAnnotationDownloadSummaryByPostRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AnnotationReportFacetsByPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAnnotationReportFacetsByPostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AnnotationReportFacetsByPost(ctx context.Context, body AnnotationReportFacetsByPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAnnotationReportFacetsByPostRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GenomeDatasetReportsByAssemblyName(ctx context.Context, assemblyNames []string, params *GenomeDatasetReportsByAssemblyNameParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGenomeDatasetReportsByAssemblyNameRequest(c.Server, assemblyNames, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GenomeDatasetReportsByBioproject(ctx context.Context, bioprojects []string, params *GenomeDatasetReportsByBioprojectParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGenomeDatasetReportsByBioprojectRequest(c.Server, bioprojects, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GenomeDatasetReportsByBiosampleId(ctx context.Context, biosampleIds []string, params *GenomeDatasetReportsByBiosampleIdParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGenomeDatasetReportsByBiosampleIdRequest(c.Server, biosampleIds, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CheckAssemblyAvailabilityPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCheckAssemblyAvailabilityPostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CheckAssemblyAvailabilityPost(ctx context.Context, body CheckAssemblyAvailabilityPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCheckAssemblyAvailabilityPostRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CheckmHistogramByTaxonByPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCheckmHistogramByTaxonByPostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CheckmHistogramByTaxonByPost(ctx context.Context, body CheckmHistogramByTaxonByPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCheckmHistogramByTaxonByPostRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GenomeDatasetReportByPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGenomeDatasetReportByPostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GenomeDatasetReportByPost(ctx context.Context, body GenomeDatasetReportByPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGenomeDatasetReportByPostRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DownloadAssemblyPackagePostWithBody(ctx context.Context, params *DownloadAssemblyPackagePostParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDownloadAssemblyPackagePostRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DownloadAssemblyPackagePost(ctx context.Context, params *DownloadAssemblyPackagePostParams, body DownloadAssemblyPackagePostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDownloadAssemblyPackagePostRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GenomeDownloadSummaryByPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGenomeDownloadSummaryByPostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GenomeDownloadSummaryByPost(ctx context.Context, body GenomeDownloadSummaryByPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGenomeDownloadSummaryByPostRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GenomeLinksByAccessionByPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGenomeLinksByAccessionByPostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GenomeLinksByAccessionByPost(ctx context.Context, body GenomeLinksByAccessionByPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGenomeLinksByAccessionByPostRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AssemblyRevisionHistoryByPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAssemblyRevisionHistoryByPostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AssemblyRevisionHistoryByPost(ctx context.Context, body AssemblyRevisionHistoryByPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAssemblyRevisionHistoryByPostRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AssemblyAccessionsForSequenceAccession(ctx context.Context, accession string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAssemblyAccessionsForSequenceAccessionRequest(c.Server, accession)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AssemblyAccessionsForSequenceAccessionByPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAssemblyAccessionsForSequenceAccessionByPostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AssemblyAccessionsForSequenceAccessionByPost(ctx context.Context, body AssemblyAccessionsForSequenceAccessionByPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAssemblyAccessionsForSequenceAccessionByPostRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GenomeSequenceReportByPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGenomeSequenceReportByPostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GenomeSequenceReportByPost(ctx context.Context, body GenomeSequenceReportByPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGenomeSequenceReportByPostRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CheckmHistogramByTaxon(ctx context.Context, speciesTaxon string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCheckmHistogramByTaxonRequest(c.Server, speciesTaxon)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GenomeDatasetReportsByTaxon(ctx context.Context, taxons []string, params *GenomeDatasetReportsByTaxonParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGenomeDatasetReportsByTaxonRequest(c.Server, taxons, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GenomeDatasetReportsByWgs(ctx context.Context, wgsAccessions []string, params *GenomeDatasetReportsByWgsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGenomeDatasetReportsByWgsRequest(c.Server, wgsAccessions, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DownloadOrganellePackage(ctx context.Context, accessions []string, params *DownloadOrganellePackageParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDownloadOrganellePackageRequest(c.Server, accessions, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) OrganelleDatareportByAccession(ctx context.Context, accessions []string, params *OrganelleDatareportByAccessionParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewOrganelleDatareportByAccessionRequest(c.Server, accessions, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) OrganelleDatareportByPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewOrganelleDatareportByPostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) OrganelleDatareportByPost(ctx context.Context, body OrganelleDatareportByPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewOrganelleDatareportByPostRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DownloadOrganellePackageByPostWithBody(ctx context.Context, params *DownloadOrganellePackageByPostParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDownloadOrganellePackageByPostRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DownloadOrganellePackageByPost(ctx context.Context, params *DownloadOrganellePackageByPostParams, body DownloadOrganellePackageByPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDownloadOrganellePackageByPostRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) OrganelleDatareportByTaxon(ctx context.Context, taxons []string, params *OrganelleDatareportByTaxonParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewOrganelleDatareportByTaxonRequest(c.Server, taxons, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DownloadProkaryoteGenePackagePostWithBody(ctx context.Context, params *DownloadProkaryoteGenePackagePostParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDownloadProkaryoteGenePackagePostRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DownloadProkaryoteGenePackagePost(ctx context.Context, params *DownloadProkaryoteGenePackagePostParams, body DownloadProkaryoteGenePackagePostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDownloadProkaryoteGenePackagePostRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DownloadProkaryoteGenePackage(ctx context.Context, accessions []string, params *DownloadProkaryoteGenePackageParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDownloadProkaryoteGenePackageRequest(c.Server, accessions, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TaxonomyMetadataPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTaxonomyMetadataPostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TaxonomyMetadataPost(ctx context.Context, body TaxonomyMetadataPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTaxonomyMetadataPostRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TaxonomyDataReportPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTaxonomyDataReportPostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TaxonomyDataReportPost(ctx context.Context, body TaxonomyDataReportPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTaxonomyDataReportPostRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DownloadTaxonomyPackageByPostWithBody(ctx context.Context, params *DownloadTaxonomyPackageByPostParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDownloadTaxonomyPackageByPostRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DownloadTaxonomyPackageByPost(ctx context.Context, params *DownloadTaxonomyPackageByPostParams, body DownloadTaxonomyPackageByPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDownloadTaxonomyPackageByPostRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TaxonomyFilteredSubtreePostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTaxonomyFilteredSubtreePostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TaxonomyFilteredSubtreePost(ctx context.Context, body TaxonomyFilteredSubtreePostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTaxonomyFilteredSubtreePostRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TaxonomyImagePostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTaxonomyImagePostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TaxonomyImagePost(ctx context.Context, body TaxonomyImagePostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTaxonomyImagePostRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TaxonomyImageMetadataPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTaxonomyImageMetadataPostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TaxonomyImageMetadataPost(ctx context.Context, body TaxonomyImageMetadataPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTaxonomyImageMetadataPostRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TaxonomyLinksByPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTaxonomyLinksByPostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TaxonomyLinksByPost(ctx context.Context, body TaxonomyLinksByPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTaxonomyLinksByPostRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TaxonomyNamesPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTaxonomyNamesPostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TaxonomyNamesPost(ctx context.Context, body TaxonomyNamesPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTaxonomyNamesPostRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TaxonomyRelatedIdsPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTaxonomyRelatedIdsPostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TaxonomyRelatedIdsPost(ctx context.Context, body TaxonomyRelatedIdsPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTaxonomyRelatedIdsPostRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DownloadTaxonomyPackage(ctx context.Context, taxIds []int, params *DownloadTaxonomyPackageParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDownloadTaxonomyPackageRequest(c.Server, taxIds, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TaxonomyRelatedIds(ctx context.Context, taxId int, params *TaxonomyRelatedIdsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTaxonomyRelatedIdsRequest(c.Server, taxId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TaxonomyMetadata(ctx context.Context, taxons []string, params *TaxonomyMetadataParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTaxonomyMetadataRequest(c.Server, taxons, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TaxonomyDataReport(ctx context.Context, taxons []string, params *TaxonomyDataReportParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTaxonomyDataReportRequest(c.Server, taxons, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TaxonomyFilteredSubtree(ctx context.Context, taxons []string, params *TaxonomyFilteredSubtreeParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTaxonomyFilteredSubtreeRequest(c.Server, taxons, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TaxonomyNames(ctx context.Context, taxons []string, params *TaxonomyNamesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTaxonomyNamesRequest(c.Server, taxons, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TaxonomyImage(ctx context.Context, taxon string, params *TaxonomyImageParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTaxonomyImageRequest(c.Server, taxon, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TaxonomyImageMetadata(ctx context.Context, taxon string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTaxonomyImageMetadataRequest(c.Server, taxon)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TaxonomyLinks(ctx context.Context, taxon string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTaxonomyLinksRequest(c.Server, taxon)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TaxNameQueryByPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTaxNameQueryByPostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TaxNameQueryByPost(ctx context.Context, body TaxNameQueryByPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTaxNameQueryByPostRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TaxNameQuery(ctx context.Context, taxonQuery string, params *TaxNameQueryParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTaxNameQueryRequest(c.Server, taxonQuery, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Version(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewVersionRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) VirusReportsByPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewVirusReportsByPostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) VirusReportsByPost(ctx context.Context, body VirusReportsByPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewVirusReportsByPostRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) VirusAnnotationReportsByAcessions(ctx context.Context, accessions []string, params *VirusAnnotationReportsByAcessionsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewVirusAnnotationReportsByAcessionsRequest(c.Server, accessions, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) VirusAccessionAvailability(ctx context.Context, accessions []string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewVirusAccessionAvailabilityRequest(c.Server, accessions)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) VirusReportsByAcessions(ctx context.Context, accessions []string, params *VirusReportsByAcessionsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewVirusReportsByAcessionsRequest(c.Server, accessions, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) VirusGenomeDownloadAccession(ctx context.Context, accessions []string, params *VirusGenomeDownloadAccessionParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewVirusGenomeDownloadAccessionRequest(c.Server, accessions, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) VirusAnnotationReportsByPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewVirusAnnotationReportsByPostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) VirusAnnotationReportsByPost(ctx context.Context, body VirusAnnotationReportsByPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewVirusAnnotationReportsByPostRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) VirusAccessionAvailabilityPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewVirusAccessionAvailabilityPostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) VirusAccessionAvailabilityPost(ctx context.Context, body VirusAccessionAvailabilityPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewVirusAccessionAvailabilityPostRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) VirusGenomeSummaryByPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewVirusGenomeSummaryByPostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) VirusGenomeSummaryByPost(ctx context.Context, body VirusGenomeSummaryByPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewVirusGenomeSummaryByPostRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) VirusGenomeDownloadPostWithBody(ctx context.Context, params *VirusGenomeDownloadPostParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewVirusGenomeDownloadPostRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) VirusGenomeDownloadPost(ctx context.Context, params *VirusGenomeDownloadPostParams, body VirusGenomeDownloadPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewVirusGenomeDownloadPostRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Sars2ProteinSummaryByPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSars2ProteinSummaryByPostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Sars2ProteinSummaryByPost(ctx context.Context, body Sars2ProteinSummaryByPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSars2ProteinSummaryByPostRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Sars2ProteinDownloadPostWithBody(ctx context.Context, params *Sars2ProteinDownloadPostParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSars2ProteinDownloadPostRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Sars2ProteinDownloadPost(ctx context.Context, params *Sars2ProteinDownloadPostParams, body Sars2ProteinDownloadPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSars2ProteinDownloadPostRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Sars2ProteinSummary(ctx context.Context, proteins []string, params *Sars2ProteinSummaryParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSars2ProteinSummaryRequest(c.Server, proteins, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Sars2ProteinDownload(ctx context.Context, proteins []string, params *Sars2ProteinDownloadParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSars2ProteinDownloadRequest(c.Server, proteins, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Sars2ProteinTable(ctx context.Context, proteins []string, params *Sars2ProteinTableParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSars2ProteinTableRequest(c.Server, proteins, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) VirusAnnotationReportsByTaxon(ctx context.Context, taxon string, params *VirusAnnotationReportsByTaxonParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewVirusAnnotationReportsByTaxonRequest(c.Server, taxon, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) VirusReportsByTaxon(ctx context.Context, taxon string, params *VirusReportsByTaxonParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewVirusReportsByTaxonRequest(c.Server, taxon, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) VirusGenomeSummary(ctx context.Context, taxon string, params *VirusGenomeSummaryParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewVirusGenomeSummaryRequest(c.Server, taxon, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) VirusGenomeDownload(ctx context.Context, taxon string, params *VirusGenomeDownloadParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewVirusGenomeDownloadRequest(c.Server, taxon, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) VirusGenomeTable(ctx context.Context, taxon string, params *VirusGenomeTableParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewVirusGenomeTableRequest(c.Server, taxon, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewBioSampleDatasetReportRequest generates requests for BioSampleDatasetReport
func NewBioSampleDatasetReportRequest(server string, accessions []string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "accessions", runtime.ParamLocationPath, accessions)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/biosample/accession/%s/biosample_report", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGeneMetadataByPostRequest calls the generic GeneMetadataByPost builder with application/json body
func NewGeneMetadataByPostRequest(server string, body GeneMetadataByPostJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewGeneMetadataByPostRequestWithBody(server, "application/json", bodyReader)
}

// NewGeneMetadataByPostRequestWithBody generates requests for GeneMetadataByPost with any type of body
func NewGeneMetadataByPostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/gene")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGeneMetadataByAccessionRequest generates requests for GeneMetadataByAccession
func NewGeneMetadataByAccessionRequest(server string, accessions []string, params *GeneMetadataByAccessionParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "accessions", runtime.ParamLocationPath, accessions)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/gene/accession/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ReturnedContent != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "returned_content", runtime.ParamLocationQuery, *params.ReturnedContent); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TableFields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "table_fields", runtime.ParamLocationQuery, *params.TableFields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IncludeTabularHeader != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include_tabular_header", runtime.ParamLocationQuery, *params.IncludeTabularHeader); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageSize != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page_size", runtime.ParamLocationQuery, *params.PageSize); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page_token", runtime.ParamLocationQuery, *params.PageToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDownloadGenePackagePostRequest calls the generic DownloadGenePackagePost builder with application/json body
func NewDownloadGenePackagePostRequest(server string, params *DownloadGenePackagePostParams, body DownloadGenePackagePostJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDownloadGenePackagePostRequestWithBody(server, params, "application/json", bodyReader)
}

// NewDownloadGenePackagePostRequestWithBody generates requests for DownloadGenePackagePost with any type of body
func NewDownloadGenePackagePostRequestWithBody(server string, params *DownloadGenePackagePostParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/gene/download")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Filename != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filename", runtime.ParamLocationQuery, *params.Filename); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGeneDownloadSummaryByPostRequest calls the generic GeneDownloadSummaryByPost builder with application/json body
func NewGeneDownloadSummaryByPostRequest(server string, body GeneDownloadSummaryByPostJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewGeneDownloadSummaryByPostRequestWithBody(server, "application/json", bodyReader)
}

// NewGeneDownloadSummaryByPostRequestWithBody generates requests for GeneDownloadSummaryByPost with any type of body
func NewGeneDownloadSummaryByPostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/gene/download_summary")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGeneReportsByIdRequest generates requests for GeneReportsById
func NewGeneReportsByIdRequest(server string, geneIds []int, params *GeneReportsByIdParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "gene_ids", runtime.ParamLocationPath, geneIds)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/gene/id/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ReturnedContent != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "returned_content", runtime.ParamLocationQuery, *params.ReturnedContent); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TableFields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "table_fields", runtime.ParamLocationQuery, *params.TableFields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IncludeTabularHeader != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include_tabular_header", runtime.ParamLocationQuery, *params.IncludeTabularHeader); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageSize != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page_size", runtime.ParamLocationQuery, *params.PageSize); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page_token", runtime.ParamLocationQuery, *params.PageToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDownloadGenePackageRequest generates requests for DownloadGenePackage
func NewDownloadGenePackageRequest(server string, geneIds []int, params *DownloadGenePackageParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "gene_ids", runtime.ParamLocationPath, geneIds)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/gene/id/%s/download", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.IncludeAnnotationType != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include_annotation_type", runtime.ParamLocationQuery, *params.IncludeAnnotationType); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FastaFilter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fasta_filter", runtime.ParamLocationQuery, *params.FastaFilter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AuxReport != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "aux_report", runtime.ParamLocationQuery, *params.AuxReport); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TableFields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "table_fields", runtime.ParamLocationQuery, *params.TableFields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TableReportType != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "table_report_type", runtime.ParamLocationQuery, *params.TableReportType); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filename != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filename", runtime.ParamLocationQuery, *params.Filename); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGeneDownloadSummaryByIdRequest generates requests for GeneDownloadSummaryById
func NewGeneDownloadSummaryByIdRequest(server string, geneIds []int, params *GeneDownloadSummaryByIdParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "gene_ids", runtime.ParamLocationPath, geneIds)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/gene/id/%s/download_summary", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.IncludeAnnotationType != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include_annotation_type", runtime.ParamLocationQuery, *params.IncludeAnnotationType); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ReturnedContent != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "returned_content", runtime.ParamLocationQuery, *params.ReturnedContent); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FastaFilter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fasta_filter", runtime.ParamLocationQuery, *params.FastaFilter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AuxReport != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "aux_report", runtime.ParamLocationQuery, *params.AuxReport); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TableFields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "table_fields", runtime.ParamLocationQuery, *params.TableFields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TableReportType != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "table_report_type", runtime.ParamLocationQuery, *params.TableReportType); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGeneLinksByIdRequest generates requests for GeneLinksById
func NewGeneLinksByIdRequest(server string, geneIds []int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "gene_ids", runtime.ParamLocationPath, geneIds)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/gene/id/%s/links", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGeneOrthologsByIdRequest generates requests for GeneOrthologsById
func NewGeneOrthologsByIdRequest(server string, geneId int, params *GeneOrthologsByIdParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "gene_id", runtime.ParamLocationPath, geneId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/gene/id/%s/orthologs", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ReturnedContent != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "returned_content", runtime.ParamLocationQuery, *params.ReturnedContent); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TaxonFilter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "taxon_filter", runtime.ParamLocationQuery, *params.TaxonFilter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageSize != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page_size", runtime.ParamLocationQuery, *params.PageSize); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page_token", runtime.ParamLocationQuery, *params.PageToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGeneLinksByIdByPostRequest calls the generic GeneLinksByIdByPost builder with application/json body
func NewGeneLinksByIdByPostRequest(server string, body GeneLinksByIdByPostJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewGeneLinksByIdByPostRequestWithBody(server, "application/json", bodyReader)
}

// NewGeneLinksByIdByPostRequestWithBody generates requests for GeneLinksByIdByPost with any type of body
func NewGeneLinksByIdByPostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/gene/links")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGeneOrthologsByPostRequest calls the generic GeneOrthologsByPost builder with application/json body
func NewGeneOrthologsByPostRequest(server string, body GeneOrthologsByPostJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewGeneOrthologsByPostRequestWithBody(server, "application/json", bodyReader)
}

// NewGeneOrthologsByPostRequestWithBody generates requests for GeneOrthologsByPost with any type of body
func NewGeneOrthologsByPostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/gene/orthologs")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGeneMetadataByTaxAndSymbolRequest generates requests for GeneMetadataByTaxAndSymbol
func NewGeneMetadataByTaxAndSymbolRequest(server string, symbols []string, taxon string, params *GeneMetadataByTaxAndSymbolParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "symbols", runtime.ParamLocationPath, symbols)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "taxon", runtime.ParamLocationPath, taxon)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/gene/symbol/%s/taxon/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ReturnedContent != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "returned_content", runtime.ParamLocationQuery, *params.ReturnedContent); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TableFields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "table_fields", runtime.ParamLocationQuery, *params.TableFields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IncludeTabularHeader != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include_tabular_header", runtime.ParamLocationQuery, *params.IncludeTabularHeader); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageSize != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page_size", runtime.ParamLocationQuery, *params.PageSize); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page_token", runtime.ParamLocationQuery, *params.PageToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGeneCountsForTaxonByPostRequest calls the generic GeneCountsForTaxonByPost builder with application/json body
func NewGeneCountsForTaxonByPostRequest(server string, body GeneCountsForTaxonByPostJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewGeneCountsForTaxonByPostRequestWithBody(server, "application/json", bodyReader)
}

// NewGeneCountsForTaxonByPostRequestWithBody generates requests for GeneCountsForTaxonByPost with any type of body
func NewGeneCountsForTaxonByPostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/gene/taxon/counts")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGeneReportsByTaxonRequest generates requests for GeneReportsByTaxon
func NewGeneReportsByTaxonRequest(server string, taxon string, params *GeneReportsByTaxonParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "taxon", runtime.ParamLocationPath, taxon)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/gene/taxon/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ReturnedContent != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "returned_content", runtime.ParamLocationQuery, *params.ReturnedContent); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TableFields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "table_fields", runtime.ParamLocationQuery, *params.TableFields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IncludeTabularHeader != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include_tabular_header", runtime.ParamLocationQuery, *params.IncludeTabularHeader); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageSize != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page_size", runtime.ParamLocationQuery, *params.PageSize); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page_token", runtime.ParamLocationQuery, *params.PageToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Query != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "query", runtime.ParamLocationQuery, *params.Query); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Types != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "types", runtime.ParamLocationQuery, *params.Types); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGeneChromosomeSummaryRequest generates requests for GeneChromosomeSummary
func NewGeneChromosomeSummaryRequest(server string, taxon string, annotationName string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "taxon", runtime.ParamLocationPath, taxon)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "annotation_name", runtime.ParamLocationPath, annotationName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/gene/taxon/%s/annotation/%s/chromosome_summary", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGeneCountsForTaxonRequest generates requests for GeneCountsForTaxon
func NewGeneCountsForTaxonRequest(server string, taxon string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "taxon", runtime.ParamLocationPath, taxon)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/gene/taxon/%s/counts", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCheckAssemblyAvailabilityRequest generates requests for CheckAssemblyAvailability
func NewCheckAssemblyAvailabilityRequest(server string, accessions []string, params *CheckAssemblyAvailabilityParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "accessions", runtime.ParamLocationPath, accessions)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/genome/accession/%s/check", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ExpDebugValues != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "_exp_debug_values", runtime.ParamLocationQuery, *params.ExpDebugValues); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGenomeDatasetReportRequest generates requests for GenomeDatasetReport
func NewGenomeDatasetReportRequest(server string, accessions []string, params *GenomeDatasetReportParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "accessions", runtime.ParamLocationPath, accessions)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/genome/accession/%s/dataset_report", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.FiltersReferenceOnly != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filters.reference_only", runtime.ParamLocationQuery, *params.FiltersReferenceOnly); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FiltersAssemblySource != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filters.assembly_source", runtime.ParamLocationQuery, *params.FiltersAssemblySource); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FiltersHasAnnotation != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filters.has_annotation", runtime.ParamLocationQuery, *params.FiltersHasAnnotation); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FiltersExcludePairedReports != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filters.exclude_paired_reports", runtime.ParamLocationQuery, *params.FiltersExcludePairedReports); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FiltersExcludeAtypical != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filters.exclude_atypical", runtime.ParamLocationQuery, *params.FiltersExcludeAtypical); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FiltersAssemblyVersion != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filters.assembly_version", runtime.ParamLocationQuery, *params.FiltersAssemblyVersion); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FiltersAssemblyLevel != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filters.assembly_level", runtime.ParamLocationQuery, *params.FiltersAssemblyLevel); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FiltersFirstReleaseDate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filters.first_release_date", runtime.ParamLocationQuery, *params.FiltersFirstReleaseDate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FiltersLastReleaseDate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filters.last_release_date", runtime.ParamLocationQuery, *params.FiltersLastReleaseDate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FiltersSearchText != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filters.search_text", runtime.ParamLocationQuery, *params.FiltersSearchText); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FiltersIsMetagenomeDerived != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filters.is_metagenome_derived", runtime.ParamLocationQuery, *params.FiltersIsMetagenomeDerived); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FiltersIsTypeMaterial != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filters.is_type_material", runtime.ParamLocationQuery, *params.FiltersIsTypeMaterial); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FiltersIsIctvExemplar != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filters.is_ictv_exemplar", runtime.ParamLocationQuery, *params.FiltersIsIctvExemplar); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FiltersExcludeMultiIsolate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filters.exclude_multi_isolate", runtime.ParamLocationQuery, *params.FiltersExcludeMultiIsolate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FiltersTypeMaterialCategory != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filters.type_material_category", runtime.ParamLocationQuery, *params.FiltersTypeMaterialCategory); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TaxExactMatch != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tax_exact_match", runtime.ParamLocationQuery, *params.TaxExactMatch); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TableFields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "table_fields", runtime.ParamLocationQuery, *params.TableFields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ReturnedContent != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "returned_content", runtime.ParamLocationQuery, *params.ReturnedContent); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageSize != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page_size", runtime.ParamLocationQuery, *params.PageSize); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page_token", runtime.ParamLocationQuery, *params.PageToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortField != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort.field", runtime.ParamLocationQuery, *params.SortField); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortDirection != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort.direction", runtime.ParamLocationQuery, *params.SortDirection); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IncludeTabularHeader != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include_tabular_header", runtime.ParamLocationQuery, *params.IncludeTabularHeader); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDownloadAssemblyPackageRequest generates requests for DownloadAssemblyPackage
func NewDownloadAssemblyPackageRequest(server string, accessions []string, params *DownloadAssemblyPackageParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "accessions", runtime.ParamLocationPath, accessions)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/genome/accession/%s/download", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Chromosomes != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "chromosomes", runtime.ParamLocationQuery, *params.Chromosomes); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IncludeAnnotationType != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include_annotation_type", runtime.ParamLocationQuery, *params.IncludeAnnotationType); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Hydrated != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "hydrated", runtime.ParamLocationQuery, *params.Hydrated); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ExpDebugValues != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "_exp_debug_values", runtime.ParamLocationQuery, *params.ExpDebugValues); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filename != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filename", runtime.ParamLocationQuery, *params.Filename); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGenomeDownloadSummaryRequest generates requests for GenomeDownloadSummary
func NewGenomeDownloadSummaryRequest(server string, accessions []string, params *GenomeDownloadSummaryParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "accessions", runtime.ParamLocationPath, accessions)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/genome/accession/%s/download_summary", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Chromosomes != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "chromosomes", runtime.ParamLocationQuery, *params.Chromosomes); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IncludeAnnotationType != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include_annotation_type", runtime.ParamLocationQuery, *params.IncludeAnnotationType); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ExpDebugValues != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "_exp_debug_values", runtime.ParamLocationQuery, *params.ExpDebugValues); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGenomeLinksByAccessionRequest generates requests for GenomeLinksByAccession
func NewGenomeLinksByAccessionRequest(server string, accessions []string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "accessions", runtime.ParamLocationPath, accessions)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/genome/accession/%s/links", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGenomeAnnotationReportRequest generates requests for GenomeAnnotationReport
func NewGenomeAnnotationReportRequest(server string, accession string, params *GenomeAnnotationReportParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "accession", runtime.ParamLocationPath, accession)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/genome/accession/%s/annotation_report", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.AnnotationIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "annotation_ids", runtime.ParamLocationQuery, *params.AnnotationIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Symbols != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "symbols", runtime.ParamLocationQuery, *params.Symbols); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Locations != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "locations", runtime.ParamLocationQuery, *params.Locations); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.GeneTypes != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "gene_types", runtime.ParamLocationQuery, *params.GeneTypes); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SearchText != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "search_text", runtime.ParamLocationQuery, *params.SearchText); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortField != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort.field", runtime.ParamLocationQuery, *params.SortField); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortDirection != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort.direction", runtime.ParamLocationQuery, *params.SortDirection); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageSize != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page_size", runtime.ParamLocationQuery, *params.PageSize); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TableFields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "table_fields", runtime.ParamLocationQuery, *params.TableFields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TableFormat != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "table_format", runtime.ParamLocationQuery, *params.TableFormat); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IncludeTabularHeader != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include_tabular_header", runtime.ParamLocationQuery, *params.IncludeTabularHeader); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page_token", runtime.ParamLocationQuery, *params.PageToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDownloadGenomeAnnotationPackageRequest generates requests for DownloadGenomeAnnotationPackage
func NewDownloadGenomeAnnotationPackageRequest(server string, accession string, params *DownloadGenomeAnnotationPackageParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "accession", runtime.ParamLocationPath, accession)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/genome/accession/%s/annotation_report/download", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.AnnotationIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "annotation_ids", runtime.ParamLocationQuery, *params.AnnotationIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Symbols != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "symbols", runtime.ParamLocationQuery, *params.Symbols); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Locations != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "locations", runtime.ParamLocationQuery, *params.Locations); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.GeneTypes != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "gene_types", runtime.ParamLocationQuery, *params.GeneTypes); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SearchText != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "search_text", runtime.ParamLocationQuery, *params.SearchText); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortField != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort.field", runtime.ParamLocationQuery, *params.SortField); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortDirection != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort.direction", runtime.ParamLocationQuery, *params.SortDirection); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IncludeAnnotationType != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include_annotation_type", runtime.ParamLocationQuery, *params.IncludeAnnotationType); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageSize != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page_size", runtime.ParamLocationQuery, *params.PageSize); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TableFields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "table_fields", runtime.ParamLocationQuery, *params.TableFields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TableFormat != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "table_format", runtime.ParamLocationQuery, *params.TableFormat); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IncludeTabularHeader != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include_tabular_header", runtime.ParamLocationQuery, *params.IncludeTabularHeader); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page_token", runtime.ParamLocationQuery, *params.PageToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filename != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filename", runtime.ParamLocationQuery, *params.Filename); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGenomeAnnotationDownloadSummaryRequest generates requests for GenomeAnnotationDownloadSummary
func NewGenomeAnnotationDownloadSummaryRequest(server string, accession string, params *GenomeAnnotationDownloadSummaryParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "accession", runtime.ParamLocationPath, accession)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/genome/accession/%s/annotation_report/download_summary", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.AnnotationIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "annotation_ids", runtime.ParamLocationQuery, *params.AnnotationIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Symbols != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "symbols", runtime.ParamLocationQuery, *params.Symbols); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Locations != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "locations", runtime.ParamLocationQuery, *params.Locations); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.GeneTypes != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "gene_types", runtime.ParamLocationQuery, *params.GeneTypes); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SearchText != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "search_text", runtime.ParamLocationQuery, *params.SearchText); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortField != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort.field", runtime.ParamLocationQuery, *params.SortField); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortDirection != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort.direction", runtime.ParamLocationQuery, *params.SortDirection); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IncludeAnnotationType != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include_annotation_type", runtime.ParamLocationQuery, *params.IncludeAnnotationType); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TableFields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "table_fields", runtime.ParamLocationQuery, *params.TableFields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TableFormat != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "table_format", runtime.ParamLocationQuery, *params.TableFormat); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IncludeTabularHeader != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include_tabular_header", runtime.ParamLocationQuery, *params.IncludeTabularHeader); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAnnotationReportFacetsRequest generates requests for AnnotationReportFacets
func NewAnnotationReportFacetsRequest(server string, accession string, annotationIds []string, params *AnnotationReportFacetsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "accession", runtime.ParamLocationPath, accession)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "annotation_ids", runtime.ParamLocationPath, annotationIds)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/genome/accession/%s/id/%s/annotation_summary", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.SortField != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort.field", runtime.ParamLocationQuery, *params.SortField); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortDirection != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort.direction", runtime.ParamLocationQuery, *params.SortDirection); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAssemblyRevisionHistoryByGetRequest generates requests for AssemblyRevisionHistoryByGet
func NewAssemblyRevisionHistoryByGetRequest(server string, accession string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "accession", runtime.ParamLocationPath, accession)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/genome/accession/%s/revision_history", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGenomeSequenceReportRequest generates requests for GenomeSequenceReport
func NewGenomeSequenceReportRequest(server string, accession string, params *GenomeSequenceReportParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "accession", runtime.ParamLocationPath, accession)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/genome/accession/%s/sequence_reports", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Chromosomes != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "chromosomes", runtime.ParamLocationQuery, *params.Chromosomes); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.RoleFilters != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "role_filters", runtime.ParamLocationQuery, *params.RoleFilters); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TableFields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "table_fields", runtime.ParamLocationQuery, *params.TableFields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CountAssemblyUnplaced != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "count_assembly_unplaced", runtime.ParamLocationQuery, *params.CountAssemblyUnplaced); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageSize != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page_size", runtime.ParamLocationQuery, *params.PageSize); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page_token", runtime.ParamLocationQuery, *params.PageToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IncludeTabularHeader != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include_tabular_header", runtime.ParamLocationQuery, *params.IncludeTabularHeader); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGenomeAnnotationReportByPostRequest calls the generic GenomeAnnotationReportByPost builder with application/json body
func NewGenomeAnnotationReportByPostRequest(server string, body GenomeAnnotationReportByPostJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewGenomeAnnotationReportByPostRequestWithBody(server, "application/json", bodyReader)
}

// NewGenomeAnnotationReportByPostRequestWithBody generates requests for GenomeAnnotationReportByPost with any type of body
func NewGenomeAnnotationReportByPostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/genome/annotation_report")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDownloadGenomeAnnotationPackageByPostRequest calls the generic DownloadGenomeAnnotationPackageByPost builder with application/json body
func NewDownloadGenomeAnnotationPackageByPostRequest(server string, params *DownloadGenomeAnnotationPackageByPostParams, body DownloadGenomeAnnotationPackageByPostJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDownloadGenomeAnnotationPackageByPostRequestWithBody(server, params, "application/json", bodyReader)
}

// NewDownloadGenomeAnnotationPackageByPostRequestWithBody generates requests for DownloadGenomeAnnotationPackageByPost with any type of body
func NewDownloadGenomeAnnotationPackageByPostRequestWithBody(server string, params *DownloadGenomeAnnotationPackageByPostParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/genome/annotation_report/download")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Filename != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filename", runtime.ParamLocationQuery, *params.Filename); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGenomeAnnotationDownloadSummaryByPostRequest calls the generic GenomeAnnotationDownloadSummaryByPost builder with application/json body
func NewGenomeAnnotationDownloadSummaryByPostRequest(server string, body GenomeAnnotationDownloadSummaryByPostJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewGenomeAnnotationDownloadSummaryByPostRequestWithBody(server, "application/json", bodyReader)
}

// NewGenomeAnnotationDownloadSummaryByPostRequestWithBody generates requests for GenomeAnnotationDownloadSummaryByPost with any type of body
func NewGenomeAnnotationDownloadSummaryByPostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/genome/annotation_report/download_summary")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewAnnotationReportFacetsByPostRequest calls the generic AnnotationReportFacetsByPost builder with application/json body
func NewAnnotationReportFacetsByPostRequest(server string, body AnnotationReportFacetsByPostJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAnnotationReportFacetsByPostRequestWithBody(server, "application/json", bodyReader)
}

// NewAnnotationReportFacetsByPostRequestWithBody generates requests for AnnotationReportFacetsByPost with any type of body
func NewAnnotationReportFacetsByPostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/genome/annotation_summary")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGenomeDatasetReportsByAssemblyNameRequest generates requests for GenomeDatasetReportsByAssemblyName
func NewGenomeDatasetReportsByAssemblyNameRequest(server string, assemblyNames []string, params *GenomeDatasetReportsByAssemblyNameParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "assembly_names", runtime.ParamLocationPath, assemblyNames)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/genome/assembly_name/%s/dataset_report", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.FiltersReferenceOnly != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filters.reference_only", runtime.ParamLocationQuery, *params.FiltersReferenceOnly); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FiltersAssemblySource != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filters.assembly_source", runtime.ParamLocationQuery, *params.FiltersAssemblySource); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FiltersHasAnnotation != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filters.has_annotation", runtime.ParamLocationQuery, *params.FiltersHasAnnotation); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FiltersExcludePairedReports != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filters.exclude_paired_reports", runtime.ParamLocationQuery, *params.FiltersExcludePairedReports); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FiltersExcludeAtypical != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filters.exclude_atypical", runtime.ParamLocationQuery, *params.FiltersExcludeAtypical); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FiltersAssemblyVersion != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filters.assembly_version", runtime.ParamLocationQuery, *params.FiltersAssemblyVersion); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FiltersAssemblyLevel != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filters.assembly_level", runtime.ParamLocationQuery, *params.FiltersAssemblyLevel); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FiltersFirstReleaseDate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filters.first_release_date", runtime.ParamLocationQuery, *params.FiltersFirstReleaseDate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FiltersLastReleaseDate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filters.last_release_date", runtime.ParamLocationQuery, *params.FiltersLastReleaseDate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FiltersSearchText != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filters.search_text", runtime.ParamLocationQuery, *params.FiltersSearchText); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FiltersIsMetagenomeDerived != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filters.is_metagenome_derived", runtime.ParamLocationQuery, *params.FiltersIsMetagenomeDerived); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FiltersIsTypeMaterial != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filters.is_type_material", runtime.ParamLocationQuery, *params.FiltersIsTypeMaterial); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FiltersIsIctvExemplar != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filters.is_ictv_exemplar", runtime.ParamLocationQuery, *params.FiltersIsIctvExemplar); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FiltersExcludeMultiIsolate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filters.exclude_multi_isolate", runtime.ParamLocationQuery, *params.FiltersExcludeMultiIsolate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FiltersTypeMaterialCategory != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filters.type_material_category", runtime.ParamLocationQuery, *params.FiltersTypeMaterialCategory); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TaxExactMatch != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tax_exact_match", runtime.ParamLocationQuery, *params.TaxExactMatch); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TableFields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "table_fields", runtime.ParamLocationQuery, *params.TableFields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ReturnedContent != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "returned_content", runtime.ParamLocationQuery, *params.ReturnedContent); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageSize != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page_size", runtime.ParamLocationQuery, *params.PageSize); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page_token", runtime.ParamLocationQuery, *params.PageToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortField != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort.field", runtime.ParamLocationQuery, *params.SortField); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortDirection != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort.direction", runtime.ParamLocationQuery, *params.SortDirection); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IncludeTabularHeader != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include_tabular_header", runtime.ParamLocationQuery, *params.IncludeTabularHeader); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGenomeDatasetReportsByBioprojectRequest generates requests for GenomeDatasetReportsByBioproject
func NewGenomeDatasetReportsByBioprojectRequest(server string, bioprojects []string, params *GenomeDatasetReportsByBioprojectParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "bioprojects", runtime.ParamLocationPath, bioprojects)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/genome/bioproject/%s/dataset_report", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.FiltersReferenceOnly != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filters.reference_only", runtime.ParamLocationQuery, *params.FiltersReferenceOnly); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FiltersAssemblySource != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filters.assembly_source", runtime.ParamLocationQuery, *params.FiltersAssemblySource); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FiltersHasAnnotation != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filters.has_annotation", runtime.ParamLocationQuery, *params.FiltersHasAnnotation); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FiltersExcludePairedReports != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filters.exclude_paired_reports", runtime.ParamLocationQuery, *params.FiltersExcludePairedReports); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FiltersExcludeAtypical != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filters.exclude_atypical", runtime.ParamLocationQuery, *params.FiltersExcludeAtypical); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FiltersAssemblyVersion != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filters.assembly_version", runtime.ParamLocationQuery, *params.FiltersAssemblyVersion); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FiltersAssemblyLevel != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filters.assembly_level", runtime.ParamLocationQuery, *params.FiltersAssemblyLevel); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FiltersFirstReleaseDate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filters.first_release_date", runtime.ParamLocationQuery, *params.FiltersFirstReleaseDate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FiltersLastReleaseDate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filters.last_release_date", runtime.ParamLocationQuery, *params.FiltersLastReleaseDate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FiltersSearchText != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filters.search_text", runtime.ParamLocationQuery, *params.FiltersSearchText); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FiltersIsMetagenomeDerived != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filters.is_metagenome_derived", runtime.ParamLocationQuery, *params.FiltersIsMetagenomeDerived); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FiltersIsTypeMaterial != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filters.is_type_material", runtime.ParamLocationQuery, *params.FiltersIsTypeMaterial); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FiltersIsIctvExemplar != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filters.is_ictv_exemplar", runtime.ParamLocationQuery, *params.FiltersIsIctvExemplar); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FiltersExcludeMultiIsolate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filters.exclude_multi_isolate", runtime.ParamLocationQuery, *params.FiltersExcludeMultiIsolate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FiltersTypeMaterialCategory != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filters.type_material_category", runtime.ParamLocationQuery, *params.FiltersTypeMaterialCategory); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TaxExactMatch != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tax_exact_match", runtime.ParamLocationQuery, *params.TaxExactMatch); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TableFields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "table_fields", runtime.ParamLocationQuery, *params.TableFields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ReturnedContent != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "returned_content", runtime.ParamLocationQuery, *params.ReturnedContent); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageSize != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page_size", runtime.ParamLocationQuery, *params.PageSize); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page_token", runtime.ParamLocationQuery, *params.PageToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortField != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort.field", runtime.ParamLocationQuery, *params.SortField); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortDirection != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort.direction", runtime.ParamLocationQuery, *params.SortDirection); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IncludeTabularHeader != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include_tabular_header", runtime.ParamLocationQuery, *params.IncludeTabularHeader); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGenomeDatasetReportsByBiosampleIdRequest generates requests for GenomeDatasetReportsByBiosampleId
func NewGenomeDatasetReportsByBiosampleIdRequest(server string, biosampleIds []string, params *GenomeDatasetReportsByBiosampleIdParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "biosample_ids", runtime.ParamLocationPath, biosampleIds)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/genome/biosample/%s/dataset_report", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.FiltersReferenceOnly != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filters.reference_only", runtime.ParamLocationQuery, *params.FiltersReferenceOnly); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FiltersAssemblySource != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filters.assembly_source", runtime.ParamLocationQuery, *params.FiltersAssemblySource); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FiltersHasAnnotation != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filters.has_annotation", runtime.ParamLocationQuery, *params.FiltersHasAnnotation); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FiltersExcludePairedReports != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filters.exclude_paired_reports", runtime.ParamLocationQuery, *params.FiltersExcludePairedReports); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FiltersExcludeAtypical != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filters.exclude_atypical", runtime.ParamLocationQuery, *params.FiltersExcludeAtypical); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FiltersAssemblyVersion != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filters.assembly_version", runtime.ParamLocationQuery, *params.FiltersAssemblyVersion); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FiltersAssemblyLevel != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filters.assembly_level", runtime.ParamLocationQuery, *params.FiltersAssemblyLevel); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FiltersFirstReleaseDate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filters.first_release_date", runtime.ParamLocationQuery, *params.FiltersFirstReleaseDate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FiltersLastReleaseDate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filters.last_release_date", runtime.ParamLocationQuery, *params.FiltersLastReleaseDate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FiltersSearchText != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filters.search_text", runtime.ParamLocationQuery, *params.FiltersSearchText); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FiltersIsMetagenomeDerived != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filters.is_metagenome_derived", runtime.ParamLocationQuery, *params.FiltersIsMetagenomeDerived); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FiltersIsTypeMaterial != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filters.is_type_material", runtime.ParamLocationQuery, *params.FiltersIsTypeMaterial); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FiltersIsIctvExemplar != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filters.is_ictv_exemplar", runtime.ParamLocationQuery, *params.FiltersIsIctvExemplar); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FiltersExcludeMultiIsolate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filters.exclude_multi_isolate", runtime.ParamLocationQuery, *params.FiltersExcludeMultiIsolate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FiltersTypeMaterialCategory != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filters.type_material_category", runtime.ParamLocationQuery, *params.FiltersTypeMaterialCategory); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TaxExactMatch != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tax_exact_match", runtime.ParamLocationQuery, *params.TaxExactMatch); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TableFields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "table_fields", runtime.ParamLocationQuery, *params.TableFields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ReturnedContent != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "returned_content", runtime.ParamLocationQuery, *params.ReturnedContent); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageSize != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page_size", runtime.ParamLocationQuery, *params.PageSize); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page_token", runtime.ParamLocationQuery, *params.PageToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortField != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort.field", runtime.ParamLocationQuery, *params.SortField); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortDirection != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort.direction", runtime.ParamLocationQuery, *params.SortDirection); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IncludeTabularHeader != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include_tabular_header", runtime.ParamLocationQuery, *params.IncludeTabularHeader); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCheckAssemblyAvailabilityPostRequest calls the generic CheckAssemblyAvailabilityPost builder with application/json body
func NewCheckAssemblyAvailabilityPostRequest(server string, body CheckAssemblyAvailabilityPostJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCheckAssemblyAvailabilityPostRequestWithBody(server, "application/json", bodyReader)
}

// NewCheckAssemblyAvailabilityPostRequestWithBody generates requests for CheckAssemblyAvailabilityPost with any type of body
func NewCheckAssemblyAvailabilityPostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/genome/check")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCheckmHistogramByTaxonByPostRequest calls the generic CheckmHistogramByTaxonByPost builder with application/json body
func NewCheckmHistogramByTaxonByPostRequest(server string, body CheckmHistogramByTaxonByPostJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCheckmHistogramByTaxonByPostRequestWithBody(server, "application/json", bodyReader)
}

// NewCheckmHistogramByTaxonByPostRequestWithBody generates requests for CheckmHistogramByTaxonByPost with any type of body
func NewCheckmHistogramByTaxonByPostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/genome/checkm_histogram")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGenomeDatasetReportByPostRequest calls the generic GenomeDatasetReportByPost builder with application/json body
func NewGenomeDatasetReportByPostRequest(server string, body GenomeDatasetReportByPostJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewGenomeDatasetReportByPostRequestWithBody(server, "application/json", bodyReader)
}

// NewGenomeDatasetReportByPostRequestWithBody generates requests for GenomeDatasetReportByPost with any type of body
func NewGenomeDatasetReportByPostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/genome/dataset_report")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDownloadAssemblyPackagePostRequest calls the generic DownloadAssemblyPackagePost builder with application/json body
func NewDownloadAssemblyPackagePostRequest(server string, params *DownloadAssemblyPackagePostParams, body DownloadAssemblyPackagePostJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDownloadAssemblyPackagePostRequestWithBody(server, params, "application/json", bodyReader)
}

// NewDownloadAssemblyPackagePostRequestWithBody generates requests for DownloadAssemblyPackagePost with any type of body
func NewDownloadAssemblyPackagePostRequestWithBody(server string, params *DownloadAssemblyPackagePostParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/genome/download")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Filename != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filename", runtime.ParamLocationQuery, *params.Filename); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGenomeDownloadSummaryByPostRequest calls the generic GenomeDownloadSummaryByPost builder with application/json body
func NewGenomeDownloadSummaryByPostRequest(server string, body GenomeDownloadSummaryByPostJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewGenomeDownloadSummaryByPostRequestWithBody(server, "application/json", bodyReader)
}

// NewGenomeDownloadSummaryByPostRequestWithBody generates requests for GenomeDownloadSummaryByPost with any type of body
func NewGenomeDownloadSummaryByPostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/genome/download_summary")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGenomeLinksByAccessionByPostRequest calls the generic GenomeLinksByAccessionByPost builder with application/json body
func NewGenomeLinksByAccessionByPostRequest(server string, body GenomeLinksByAccessionByPostJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewGenomeLinksByAccessionByPostRequestWithBody(server, "application/json", bodyReader)
}

// NewGenomeLinksByAccessionByPostRequestWithBody generates requests for GenomeLinksByAccessionByPost with any type of body
func NewGenomeLinksByAccessionByPostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/genome/links")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewAssemblyRevisionHistoryByPostRequest calls the generic AssemblyRevisionHistoryByPost builder with application/json body
func NewAssemblyRevisionHistoryByPostRequest(server string, body AssemblyRevisionHistoryByPostJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAssemblyRevisionHistoryByPostRequestWithBody(server, "application/json", bodyReader)
}

// NewAssemblyRevisionHistoryByPostRequestWithBody generates requests for AssemblyRevisionHistoryByPost with any type of body
func NewAssemblyRevisionHistoryByPostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/genome/revision_history")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewAssemblyAccessionsForSequenceAccessionRequest generates requests for AssemblyAccessionsForSequenceAccession
func NewAssemblyAccessionsForSequenceAccessionRequest(server string, accession string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "accession", runtime.ParamLocationPath, accession)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/genome/sequence_accession/%s/sequence_assemblies", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAssemblyAccessionsForSequenceAccessionByPostRequest calls the generic AssemblyAccessionsForSequenceAccessionByPost builder with application/json body
func NewAssemblyAccessionsForSequenceAccessionByPostRequest(server string, body AssemblyAccessionsForSequenceAccessionByPostJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAssemblyAccessionsForSequenceAccessionByPostRequestWithBody(server, "application/json", bodyReader)
}

// NewAssemblyAccessionsForSequenceAccessionByPostRequestWithBody generates requests for AssemblyAccessionsForSequenceAccessionByPost with any type of body
func NewAssemblyAccessionsForSequenceAccessionByPostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/genome/sequence_assemblies")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGenomeSequenceReportByPostRequest calls the generic GenomeSequenceReportByPost builder with application/json body
func NewGenomeSequenceReportByPostRequest(server string, body GenomeSequenceReportByPostJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewGenomeSequenceReportByPostRequestWithBody(server, "application/json", bodyReader)
}

// NewGenomeSequenceReportByPostRequestWithBody generates requests for GenomeSequenceReportByPost with any type of body
func NewGenomeSequenceReportByPostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/genome/sequence_reports")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCheckmHistogramByTaxonRequest generates requests for CheckmHistogramByTaxon
func NewCheckmHistogramByTaxonRequest(server string, speciesTaxon string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "species_taxon", runtime.ParamLocationPath, speciesTaxon)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/genome/taxon/%s/checkm_histogram", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGenomeDatasetReportsByTaxonRequest generates requests for GenomeDatasetReportsByTaxon
func NewGenomeDatasetReportsByTaxonRequest(server string, taxons []string, params *GenomeDatasetReportsByTaxonParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "taxons", runtime.ParamLocationPath, taxons)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/genome/taxon/%s/dataset_report", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.FiltersReferenceOnly != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filters.reference_only", runtime.ParamLocationQuery, *params.FiltersReferenceOnly); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FiltersAssemblySource != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filters.assembly_source", runtime.ParamLocationQuery, *params.FiltersAssemblySource); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FiltersHasAnnotation != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filters.has_annotation", runtime.ParamLocationQuery, *params.FiltersHasAnnotation); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FiltersExcludePairedReports != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filters.exclude_paired_reports", runtime.ParamLocationQuery, *params.FiltersExcludePairedReports); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FiltersExcludeAtypical != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filters.exclude_atypical", runtime.ParamLocationQuery, *params.FiltersExcludeAtypical); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FiltersAssemblyVersion != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filters.assembly_version", runtime.ParamLocationQuery, *params.FiltersAssemblyVersion); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FiltersAssemblyLevel != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filters.assembly_level", runtime.ParamLocationQuery, *params.FiltersAssemblyLevel); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FiltersFirstReleaseDate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filters.first_release_date", runtime.ParamLocationQuery, *params.FiltersFirstReleaseDate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FiltersLastReleaseDate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filters.last_release_date", runtime.ParamLocationQuery, *params.FiltersLastReleaseDate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FiltersSearchText != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filters.search_text", runtime.ParamLocationQuery, *params.FiltersSearchText); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FiltersIsMetagenomeDerived != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filters.is_metagenome_derived", runtime.ParamLocationQuery, *params.FiltersIsMetagenomeDerived); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FiltersIsTypeMaterial != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filters.is_type_material", runtime.ParamLocationQuery, *params.FiltersIsTypeMaterial); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FiltersIsIctvExemplar != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filters.is_ictv_exemplar", runtime.ParamLocationQuery, *params.FiltersIsIctvExemplar); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FiltersExcludeMultiIsolate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filters.exclude_multi_isolate", runtime.ParamLocationQuery, *params.FiltersExcludeMultiIsolate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FiltersTypeMaterialCategory != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filters.type_material_category", runtime.ParamLocationQuery, *params.FiltersTypeMaterialCategory); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TaxExactMatch != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tax_exact_match", runtime.ParamLocationQuery, *params.TaxExactMatch); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TableFields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "table_fields", runtime.ParamLocationQuery, *params.TableFields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ReturnedContent != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "returned_content", runtime.ParamLocationQuery, *params.ReturnedContent); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageSize != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page_size", runtime.ParamLocationQuery, *params.PageSize); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page_token", runtime.ParamLocationQuery, *params.PageToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortField != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort.field", runtime.ParamLocationQuery, *params.SortField); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortDirection != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort.direction", runtime.ParamLocationQuery, *params.SortDirection); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IncludeTabularHeader != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include_tabular_header", runtime.ParamLocationQuery, *params.IncludeTabularHeader); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGenomeDatasetReportsByWgsRequest generates requests for GenomeDatasetReportsByWgs
func NewGenomeDatasetReportsByWgsRequest(server string, wgsAccessions []string, params *GenomeDatasetReportsByWgsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "wgs_accessions", runtime.ParamLocationPath, wgsAccessions)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/genome/wgs/%s/dataset_report", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.FiltersReferenceOnly != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filters.reference_only", runtime.ParamLocationQuery, *params.FiltersReferenceOnly); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FiltersAssemblySource != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filters.assembly_source", runtime.ParamLocationQuery, *params.FiltersAssemblySource); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FiltersHasAnnotation != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filters.has_annotation", runtime.ParamLocationQuery, *params.FiltersHasAnnotation); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FiltersExcludePairedReports != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filters.exclude_paired_reports", runtime.ParamLocationQuery, *params.FiltersExcludePairedReports); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FiltersExcludeAtypical != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filters.exclude_atypical", runtime.ParamLocationQuery, *params.FiltersExcludeAtypical); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FiltersAssemblyVersion != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filters.assembly_version", runtime.ParamLocationQuery, *params.FiltersAssemblyVersion); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FiltersAssemblyLevel != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filters.assembly_level", runtime.ParamLocationQuery, *params.FiltersAssemblyLevel); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FiltersFirstReleaseDate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filters.first_release_date", runtime.ParamLocationQuery, *params.FiltersFirstReleaseDate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FiltersLastReleaseDate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filters.last_release_date", runtime.ParamLocationQuery, *params.FiltersLastReleaseDate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FiltersSearchText != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filters.search_text", runtime.ParamLocationQuery, *params.FiltersSearchText); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FiltersIsMetagenomeDerived != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filters.is_metagenome_derived", runtime.ParamLocationQuery, *params.FiltersIsMetagenomeDerived); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FiltersIsTypeMaterial != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filters.is_type_material", runtime.ParamLocationQuery, *params.FiltersIsTypeMaterial); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FiltersIsIctvExemplar != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filters.is_ictv_exemplar", runtime.ParamLocationQuery, *params.FiltersIsIctvExemplar); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FiltersExcludeMultiIsolate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filters.exclude_multi_isolate", runtime.ParamLocationQuery, *params.FiltersExcludeMultiIsolate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FiltersTypeMaterialCategory != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filters.type_material_category", runtime.ParamLocationQuery, *params.FiltersTypeMaterialCategory); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TaxExactMatch != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tax_exact_match", runtime.ParamLocationQuery, *params.TaxExactMatch); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TableFields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "table_fields", runtime.ParamLocationQuery, *params.TableFields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ReturnedContent != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "returned_content", runtime.ParamLocationQuery, *params.ReturnedContent); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageSize != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page_size", runtime.ParamLocationQuery, *params.PageSize); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page_token", runtime.ParamLocationQuery, *params.PageToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortField != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort.field", runtime.ParamLocationQuery, *params.SortField); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortDirection != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort.direction", runtime.ParamLocationQuery, *params.SortDirection); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IncludeTabularHeader != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include_tabular_header", runtime.ParamLocationQuery, *params.IncludeTabularHeader); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDownloadOrganellePackageRequest generates requests for DownloadOrganellePackage
func NewDownloadOrganellePackageRequest(server string, accessions []string, params *DownloadOrganellePackageParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "accessions", runtime.ParamLocationPath, accessions)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/organelle/accession/%s/download", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ExcludeSequence != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "exclude_sequence", runtime.ParamLocationQuery, *params.ExcludeSequence); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IncludeAnnotationType != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include_annotation_type", runtime.ParamLocationQuery, *params.IncludeAnnotationType); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filename != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filename", runtime.ParamLocationQuery, *params.Filename); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewOrganelleDatareportByAccessionRequest generates requests for OrganelleDatareportByAccession
func NewOrganelleDatareportByAccessionRequest(server string, accessions []string, params *OrganelleDatareportByAccessionParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "accessions", runtime.ParamLocationPath, accessions)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/organelle/accessions/%s/dataset_report", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Taxons != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "taxons", runtime.ParamLocationQuery, *params.Taxons); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OrganelleTypes != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "organelle_types", runtime.ParamLocationQuery, *params.OrganelleTypes); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FirstReleaseDate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "first_release_date", runtime.ParamLocationQuery, *params.FirstReleaseDate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LastReleaseDate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "last_release_date", runtime.ParamLocationQuery, *params.LastReleaseDate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TaxExactMatch != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tax_exact_match", runtime.ParamLocationQuery, *params.TaxExactMatch); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortField != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort.field", runtime.ParamLocationQuery, *params.SortField); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortDirection != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort.direction", runtime.ParamLocationQuery, *params.SortDirection); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ReturnedContent != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "returned_content", runtime.ParamLocationQuery, *params.ReturnedContent); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TableFormat != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "table_format", runtime.ParamLocationQuery, *params.TableFormat); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IncludeTabularHeader != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include_tabular_header", runtime.ParamLocationQuery, *params.IncludeTabularHeader); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewOrganelleDatareportByPostRequest calls the generic OrganelleDatareportByPost builder with application/json body
func NewOrganelleDatareportByPostRequest(server string, body OrganelleDatareportByPostJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewOrganelleDatareportByPostRequestWithBody(server, "application/json", bodyReader)
}

// NewOrganelleDatareportByPostRequestWithBody generates requests for OrganelleDatareportByPost with any type of body
func NewOrganelleDatareportByPostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/organelle/dataset_report")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDownloadOrganellePackageByPostRequest calls the generic DownloadOrganellePackageByPost builder with application/json body
func NewDownloadOrganellePackageByPostRequest(server string, params *DownloadOrganellePackageByPostParams, body DownloadOrganellePackageByPostJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDownloadOrganellePackageByPostRequestWithBody(server, params, "application/json", bodyReader)
}

// NewDownloadOrganellePackageByPostRequestWithBody generates requests for DownloadOrganellePackageByPost with any type of body
func NewDownloadOrganellePackageByPostRequestWithBody(server string, params *DownloadOrganellePackageByPostParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/organelle/download")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Filename != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filename", runtime.ParamLocationQuery, *params.Filename); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewOrganelleDatareportByTaxonRequest generates requests for OrganelleDatareportByTaxon
func NewOrganelleDatareportByTaxonRequest(server string, taxons []string, params *OrganelleDatareportByTaxonParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "taxons", runtime.ParamLocationPath, taxons)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/organelle/taxon/%s/dataset_report", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.OrganelleTypes != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "organelle_types", runtime.ParamLocationQuery, *params.OrganelleTypes); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FirstReleaseDate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "first_release_date", runtime.ParamLocationQuery, *params.FirstReleaseDate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LastReleaseDate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "last_release_date", runtime.ParamLocationQuery, *params.LastReleaseDate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TaxExactMatch != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tax_exact_match", runtime.ParamLocationQuery, *params.TaxExactMatch); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortField != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort.field", runtime.ParamLocationQuery, *params.SortField); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortDirection != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort.direction", runtime.ParamLocationQuery, *params.SortDirection); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ReturnedContent != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "returned_content", runtime.ParamLocationQuery, *params.ReturnedContent); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageSize != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page_size", runtime.ParamLocationQuery, *params.PageSize); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page_token", runtime.ParamLocationQuery, *params.PageToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TableFormat != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "table_format", runtime.ParamLocationQuery, *params.TableFormat); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IncludeTabularHeader != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include_tabular_header", runtime.ParamLocationQuery, *params.IncludeTabularHeader); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDownloadProkaryoteGenePackagePostRequest calls the generic DownloadProkaryoteGenePackagePost builder with application/json body
func NewDownloadProkaryoteGenePackagePostRequest(server string, params *DownloadProkaryoteGenePackagePostParams, body DownloadProkaryoteGenePackagePostJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDownloadProkaryoteGenePackagePostRequestWithBody(server, params, "application/json", bodyReader)
}

// NewDownloadProkaryoteGenePackagePostRequestWithBody generates requests for DownloadProkaryoteGenePackagePost with any type of body
func NewDownloadProkaryoteGenePackagePostRequestWithBody(server string, params *DownloadProkaryoteGenePackagePostParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/protein/accession/download")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Filename != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filename", runtime.ParamLocationQuery, *params.Filename); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDownloadProkaryoteGenePackageRequest generates requests for DownloadProkaryoteGenePackage
func NewDownloadProkaryoteGenePackageRequest(server string, accessions []string, params *DownloadProkaryoteGenePackageParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "accessions", runtime.ParamLocationPath, accessions)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/protein/accession/%s/download", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.IncludeAnnotationType != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include_annotation_type", runtime.ParamLocationQuery, *params.IncludeAnnotationType); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.GeneFlankConfigLength != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "gene_flank_config.length", runtime.ParamLocationQuery, *params.GeneFlankConfigLength); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Taxon != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "taxon", runtime.ParamLocationQuery, *params.Taxon); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filename != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filename", runtime.ParamLocationQuery, *params.Filename); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewTaxonomyMetadataPostRequest calls the generic TaxonomyMetadataPost builder with application/json body
func NewTaxonomyMetadataPostRequest(server string, body TaxonomyMetadataPostJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewTaxonomyMetadataPostRequestWithBody(server, "application/json", bodyReader)
}

// NewTaxonomyMetadataPostRequestWithBody generates requests for TaxonomyMetadataPost with any type of body
func NewTaxonomyMetadataPostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/taxonomy")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewTaxonomyDataReportPostRequest calls the generic TaxonomyDataReportPost builder with application/json body
func NewTaxonomyDataReportPostRequest(server string, body TaxonomyDataReportPostJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewTaxonomyDataReportPostRequestWithBody(server, "application/json", bodyReader)
}

// NewTaxonomyDataReportPostRequestWithBody generates requests for TaxonomyDataReportPost with any type of body
func NewTaxonomyDataReportPostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/taxonomy/dataset_report")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDownloadTaxonomyPackageByPostRequest calls the generic DownloadTaxonomyPackageByPost builder with application/json body
func NewDownloadTaxonomyPackageByPostRequest(server string, params *DownloadTaxonomyPackageByPostParams, body DownloadTaxonomyPackageByPostJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDownloadTaxonomyPackageByPostRequestWithBody(server, params, "application/json", bodyReader)
}

// NewDownloadTaxonomyPackageByPostRequestWithBody generates requests for DownloadTaxonomyPackageByPost with any type of body
func NewDownloadTaxonomyPackageByPostRequestWithBody(server string, params *DownloadTaxonomyPackageByPostParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/taxonomy/download")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Filename != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filename", runtime.ParamLocationQuery, *params.Filename); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewTaxonomyFilteredSubtreePostRequest calls the generic TaxonomyFilteredSubtreePost builder with application/json body
func NewTaxonomyFilteredSubtreePostRequest(server string, body TaxonomyFilteredSubtreePostJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewTaxonomyFilteredSubtreePostRequestWithBody(server, "application/json", bodyReader)
}

// NewTaxonomyFilteredSubtreePostRequestWithBody generates requests for TaxonomyFilteredSubtreePost with any type of body
func NewTaxonomyFilteredSubtreePostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/taxonomy/filtered_subtree")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewTaxonomyImagePostRequest calls the generic TaxonomyImagePost builder with application/json body
func NewTaxonomyImagePostRequest(server string, body TaxonomyImagePostJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewTaxonomyImagePostRequestWithBody(server, "application/json", bodyReader)
}

// NewTaxonomyImagePostRequestWithBody generates requests for TaxonomyImagePost with any type of body
func NewTaxonomyImagePostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/taxonomy/image")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewTaxonomyImageMetadataPostRequest calls the generic TaxonomyImageMetadataPost builder with application/json body
func NewTaxonomyImageMetadataPostRequest(server string, body TaxonomyImageMetadataPostJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewTaxonomyImageMetadataPostRequestWithBody(server, "application/json", bodyReader)
}

// NewTaxonomyImageMetadataPostRequestWithBody generates requests for TaxonomyImageMetadataPost with any type of body
func NewTaxonomyImageMetadataPostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/taxonomy/image/metadata")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewTaxonomyLinksByPostRequest calls the generic TaxonomyLinksByPost builder with application/json body
func NewTaxonomyLinksByPostRequest(server string, body TaxonomyLinksByPostJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewTaxonomyLinksByPostRequestWithBody(server, "application/json", bodyReader)
}

// NewTaxonomyLinksByPostRequestWithBody generates requests for TaxonomyLinksByPost with any type of body
func NewTaxonomyLinksByPostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/taxonomy/links")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewTaxonomyNamesPostRequest calls the generic TaxonomyNamesPost builder with application/json body
func NewTaxonomyNamesPostRequest(server string, body TaxonomyNamesPostJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewTaxonomyNamesPostRequestWithBody(server, "application/json", bodyReader)
}

// NewTaxonomyNamesPostRequestWithBody generates requests for TaxonomyNamesPost with any type of body
func NewTaxonomyNamesPostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/taxonomy/name_report")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewTaxonomyRelatedIdsPostRequest calls the generic TaxonomyRelatedIdsPost builder with application/json body
func NewTaxonomyRelatedIdsPostRequest(server string, body TaxonomyRelatedIdsPostJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewTaxonomyRelatedIdsPostRequestWithBody(server, "application/json", bodyReader)
}

// NewTaxonomyRelatedIdsPostRequestWithBody generates requests for TaxonomyRelatedIdsPost with any type of body
func NewTaxonomyRelatedIdsPostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/taxonomy/related_ids")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDownloadTaxonomyPackageRequest generates requests for DownloadTaxonomyPackage
func NewDownloadTaxonomyPackageRequest(server string, taxIds []int, params *DownloadTaxonomyPackageParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tax_ids", runtime.ParamLocationPath, taxIds)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/taxonomy/taxon/%s/download", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.AuxReports != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "aux_reports", runtime.ParamLocationQuery, *params.AuxReports); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filename != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filename", runtime.ParamLocationQuery, *params.Filename); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewTaxonomyRelatedIdsRequest generates requests for TaxonomyRelatedIds
func NewTaxonomyRelatedIdsRequest(server string, taxId int, params *TaxonomyRelatedIdsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tax_id", runtime.ParamLocationPath, taxId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/taxonomy/taxon/%s/related_ids", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.IncludeLineage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include_lineage", runtime.ParamLocationQuery, *params.IncludeLineage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IncludeSubtree != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include_subtree", runtime.ParamLocationQuery, *params.IncludeSubtree); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Ranks != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ranks", runtime.ParamLocationQuery, *params.Ranks); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageSize != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page_size", runtime.ParamLocationQuery, *params.PageSize); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page_token", runtime.ParamLocationQuery, *params.PageToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewTaxonomyMetadataRequest generates requests for TaxonomyMetadata
func NewTaxonomyMetadataRequest(server string, taxons []string, params *TaxonomyMetadataParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "taxons", runtime.ParamLocationPath, taxons)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/taxonomy/taxon/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ReturnedContent != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "returned_content", runtime.ParamLocationQuery, *params.ReturnedContent); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageSize != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page_size", runtime.ParamLocationQuery, *params.PageSize); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IncludeTabularHeader != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include_tabular_header", runtime.ParamLocationQuery, *params.IncludeTabularHeader); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page_token", runtime.ParamLocationQuery, *params.PageToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TableFormat != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "table_format", runtime.ParamLocationQuery, *params.TableFormat); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Children != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "children", runtime.ParamLocationQuery, *params.Children); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Ranks != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ranks", runtime.ParamLocationQuery, *params.Ranks); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewTaxonomyDataReportRequest generates requests for TaxonomyDataReport
func NewTaxonomyDataReportRequest(server string, taxons []string, params *TaxonomyDataReportParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "taxons", runtime.ParamLocationPath, taxons)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/taxonomy/taxon/%s/dataset_report", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ReturnedContent != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "returned_content", runtime.ParamLocationQuery, *params.ReturnedContent); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageSize != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page_size", runtime.ParamLocationQuery, *params.PageSize); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IncludeTabularHeader != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include_tabular_header", runtime.ParamLocationQuery, *params.IncludeTabularHeader); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page_token", runtime.ParamLocationQuery, *params.PageToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TableFormat != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "table_format", runtime.ParamLocationQuery, *params.TableFormat); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Children != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "children", runtime.ParamLocationQuery, *params.Children); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Ranks != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ranks", runtime.ParamLocationQuery, *params.Ranks); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewTaxonomyFilteredSubtreeRequest generates requests for TaxonomyFilteredSubtree
func NewTaxonomyFilteredSubtreeRequest(server string, taxons []string, params *TaxonomyFilteredSubtreeParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "taxons", runtime.ParamLocationPath, taxons)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/taxonomy/taxon/%s/filtered_subtree", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.SpecifiedLimit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "specified_limit", runtime.ParamLocationQuery, *params.SpecifiedLimit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.RankLimits != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "rank_limits", runtime.ParamLocationQuery, *params.RankLimits); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewTaxonomyNamesRequest generates requests for TaxonomyNames
func NewTaxonomyNamesRequest(server string, taxons []string, params *TaxonomyNamesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "taxons", runtime.ParamLocationPath, taxons)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/taxonomy/taxon/%s/name_report", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ReturnedContent != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "returned_content", runtime.ParamLocationQuery, *params.ReturnedContent); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageSize != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page_size", runtime.ParamLocationQuery, *params.PageSize); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IncludeTabularHeader != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include_tabular_header", runtime.ParamLocationQuery, *params.IncludeTabularHeader); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page_token", runtime.ParamLocationQuery, *params.PageToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TableFormat != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "table_format", runtime.ParamLocationQuery, *params.TableFormat); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Children != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "children", runtime.ParamLocationQuery, *params.Children); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Ranks != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ranks", runtime.ParamLocationQuery, *params.Ranks); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewTaxonomyImageRequest generates requests for TaxonomyImage
func NewTaxonomyImageRequest(server string, taxon string, params *TaxonomyImageParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "taxon", runtime.ParamLocationPath, taxon)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/taxonomy/taxon/%s/image", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ImageSize != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "image_size", runtime.ParamLocationQuery, *params.ImageSize); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewTaxonomyImageMetadataRequest generates requests for TaxonomyImageMetadata
func NewTaxonomyImageMetadataRequest(server string, taxon string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "taxon", runtime.ParamLocationPath, taxon)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/taxonomy/taxon/%s/image/metadata", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewTaxonomyLinksRequest generates requests for TaxonomyLinks
func NewTaxonomyLinksRequest(server string, taxon string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "taxon", runtime.ParamLocationPath, taxon)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/taxonomy/taxon/%s/links", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewTaxNameQueryByPostRequest calls the generic TaxNameQueryByPost builder with application/json body
func NewTaxNameQueryByPostRequest(server string, body TaxNameQueryByPostJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewTaxNameQueryByPostRequestWithBody(server, "application/json", bodyReader)
}

// NewTaxNameQueryByPostRequestWithBody generates requests for TaxNameQueryByPost with any type of body
func NewTaxNameQueryByPostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/taxonomy/taxon_suggest")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewTaxNameQueryRequest generates requests for TaxNameQuery
func NewTaxNameQueryRequest(server string, taxonQuery string, params *TaxNameQueryParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "taxon_query", runtime.ParamLocationPath, taxonQuery)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/taxonomy/taxon_suggest/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TaxRankFilter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tax_rank_filter", runtime.ParamLocationQuery, *params.TaxRankFilter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TaxonResourceFilter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "taxon_resource_filter", runtime.ParamLocationQuery, *params.TaxonResourceFilter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ExactMatch != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "exact_match", runtime.ParamLocationQuery, *params.ExactMatch); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewVersionRequest generates requests for Version
func NewVersionRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/version")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewVirusReportsByPostRequest calls the generic VirusReportsByPost builder with application/json body
func NewVirusReportsByPostRequest(server string, body VirusReportsByPostJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewVirusReportsByPostRequestWithBody(server, "application/json", bodyReader)
}

// NewVirusReportsByPostRequestWithBody generates requests for VirusReportsByPost with any type of body
func NewVirusReportsByPostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/virus")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewVirusAnnotationReportsByAcessionsRequest generates requests for VirusAnnotationReportsByAcessions
func NewVirusAnnotationReportsByAcessionsRequest(server string, accessions []string, params *VirusAnnotationReportsByAcessionsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "accessions", runtime.ParamLocationPath, accessions)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/virus/accession/%s/annotation_report", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.FilterRefseqOnly != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter.refseq_only", runtime.ParamLocationQuery, *params.FilterRefseqOnly); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FilterReleasedSince != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter.released_since", runtime.ParamLocationQuery, *params.FilterReleasedSince); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FilterUpdatedSince != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter.updated_since", runtime.ParamLocationQuery, *params.FilterUpdatedSince); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FilterHost != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter.host", runtime.ParamLocationQuery, *params.FilterHost); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FilterPangolinClassification != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter.pangolin_classification", runtime.ParamLocationQuery, *params.FilterPangolinClassification); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FilterGeoLocation != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter.geo_location", runtime.ParamLocationQuery, *params.FilterGeoLocation); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FilterCompleteOnly != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter.complete_only", runtime.ParamLocationQuery, *params.FilterCompleteOnly); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TableFields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "table_fields", runtime.ParamLocationQuery, *params.TableFields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageSize != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page_size", runtime.ParamLocationQuery, *params.PageSize); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page_token", runtime.ParamLocationQuery, *params.PageToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewVirusAccessionAvailabilityRequest generates requests for VirusAccessionAvailability
func NewVirusAccessionAvailabilityRequest(server string, accessions []string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "accessions", runtime.ParamLocationPath, accessions)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/virus/accession/%s/check", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewVirusReportsByAcessionsRequest generates requests for VirusReportsByAcessions
func NewVirusReportsByAcessionsRequest(server string, accessions []string, params *VirusReportsByAcessionsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "accessions", runtime.ParamLocationPath, accessions)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/virus/accession/%s/dataset_report", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.FilterRefseqOnly != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter.refseq_only", runtime.ParamLocationQuery, *params.FilterRefseqOnly); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FilterAnnotatedOnly != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter.annotated_only", runtime.ParamLocationQuery, *params.FilterAnnotatedOnly); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FilterReleasedSince != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter.released_since", runtime.ParamLocationQuery, *params.FilterReleasedSince); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FilterUpdatedSince != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter.updated_since", runtime.ParamLocationQuery, *params.FilterUpdatedSince); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FilterHost != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter.host", runtime.ParamLocationQuery, *params.FilterHost); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FilterPangolinClassification != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter.pangolin_classification", runtime.ParamLocationQuery, *params.FilterPangolinClassification); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FilterGeoLocation != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter.geo_location", runtime.ParamLocationQuery, *params.FilterGeoLocation); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FilterCompleteOnly != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter.complete_only", runtime.ParamLocationQuery, *params.FilterCompleteOnly); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ReturnedContent != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "returned_content", runtime.ParamLocationQuery, *params.ReturnedContent); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TableFields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "table_fields", runtime.ParamLocationQuery, *params.TableFields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageSize != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page_size", runtime.ParamLocationQuery, *params.PageSize); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page_token", runtime.ParamLocationQuery, *params.PageToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewVirusGenomeDownloadAccessionRequest generates requests for VirusGenomeDownloadAccession
func NewVirusGenomeDownloadAccessionRequest(server string, accessions []string, params *VirusGenomeDownloadAccessionParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "accessions", runtime.ParamLocationPath, accessions)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/virus/accession/%s/genome/download", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.RefseqOnly != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "refseq_only", runtime.ParamLocationQuery, *params.RefseqOnly); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AnnotatedOnly != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "annotated_only", runtime.ParamLocationQuery, *params.AnnotatedOnly); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ReleasedSince != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "released_since", runtime.ParamLocationQuery, *params.ReleasedSince); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UpdatedSince != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "updated_since", runtime.ParamLocationQuery, *params.UpdatedSince); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Host != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "host", runtime.ParamLocationQuery, *params.Host); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PangolinClassification != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pangolin_classification", runtime.ParamLocationQuery, *params.PangolinClassification); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.GeoLocation != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "geo_location", runtime.ParamLocationQuery, *params.GeoLocation); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CompleteOnly != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "complete_only", runtime.ParamLocationQuery, *params.CompleteOnly); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IncludeSequence != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include_sequence", runtime.ParamLocationQuery, *params.IncludeSequence); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AuxReport != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "aux_report", runtime.ParamLocationQuery, *params.AuxReport); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UsePsg != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "use_psg", runtime.ParamLocationQuery, *params.UsePsg); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filename != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filename", runtime.ParamLocationQuery, *params.Filename); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewVirusAnnotationReportsByPostRequest calls the generic VirusAnnotationReportsByPost builder with application/json body
func NewVirusAnnotationReportsByPostRequest(server string, body VirusAnnotationReportsByPostJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewVirusAnnotationReportsByPostRequestWithBody(server, "application/json", bodyReader)
}

// NewVirusAnnotationReportsByPostRequestWithBody generates requests for VirusAnnotationReportsByPost with any type of body
func NewVirusAnnotationReportsByPostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/virus/annotation_report")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewVirusAccessionAvailabilityPostRequest calls the generic VirusAccessionAvailabilityPost builder with application/json body
func NewVirusAccessionAvailabilityPostRequest(server string, body VirusAccessionAvailabilityPostJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewVirusAccessionAvailabilityPostRequestWithBody(server, "application/json", bodyReader)
}

// NewVirusAccessionAvailabilityPostRequestWithBody generates requests for VirusAccessionAvailabilityPost with any type of body
func NewVirusAccessionAvailabilityPostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/virus/check")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewVirusGenomeSummaryByPostRequest calls the generic VirusGenomeSummaryByPost builder with application/json body
func NewVirusGenomeSummaryByPostRequest(server string, body VirusGenomeSummaryByPostJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewVirusGenomeSummaryByPostRequestWithBody(server, "application/json", bodyReader)
}

// NewVirusGenomeSummaryByPostRequestWithBody generates requests for VirusGenomeSummaryByPost with any type of body
func NewVirusGenomeSummaryByPostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/virus/genome")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewVirusGenomeDownloadPostRequest calls the generic VirusGenomeDownloadPost builder with application/json body
func NewVirusGenomeDownloadPostRequest(server string, params *VirusGenomeDownloadPostParams, body VirusGenomeDownloadPostJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewVirusGenomeDownloadPostRequestWithBody(server, params, "application/json", bodyReader)
}

// NewVirusGenomeDownloadPostRequestWithBody generates requests for VirusGenomeDownloadPost with any type of body
func NewVirusGenomeDownloadPostRequestWithBody(server string, params *VirusGenomeDownloadPostParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/virus/genome/download")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Filename != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filename", runtime.ParamLocationQuery, *params.Filename); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSars2ProteinSummaryByPostRequest calls the generic Sars2ProteinSummaryByPost builder with application/json body
func NewSars2ProteinSummaryByPostRequest(server string, body Sars2ProteinSummaryByPostJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSars2ProteinSummaryByPostRequestWithBody(server, "application/json", bodyReader)
}

// NewSars2ProteinSummaryByPostRequestWithBody generates requests for Sars2ProteinSummaryByPost with any type of body
func NewSars2ProteinSummaryByPostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/virus/taxon/sars2/protein")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSars2ProteinDownloadPostRequest calls the generic Sars2ProteinDownloadPost builder with application/json body
func NewSars2ProteinDownloadPostRequest(server string, params *Sars2ProteinDownloadPostParams, body Sars2ProteinDownloadPostJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSars2ProteinDownloadPostRequestWithBody(server, params, "application/json", bodyReader)
}

// NewSars2ProteinDownloadPostRequestWithBody generates requests for Sars2ProteinDownloadPost with any type of body
func NewSars2ProteinDownloadPostRequestWithBody(server string, params *Sars2ProteinDownloadPostParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/virus/taxon/sars2/protein/download")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Filename != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filename", runtime.ParamLocationQuery, *params.Filename); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSars2ProteinSummaryRequest generates requests for Sars2ProteinSummary
func NewSars2ProteinSummaryRequest(server string, proteins []string, params *Sars2ProteinSummaryParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "proteins", runtime.ParamLocationPath, proteins)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/virus/taxon/sars2/protein/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.RefseqOnly != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "refseq_only", runtime.ParamLocationQuery, *params.RefseqOnly); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AnnotatedOnly != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "annotated_only", runtime.ParamLocationQuery, *params.AnnotatedOnly); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ReleasedSince != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "released_since", runtime.ParamLocationQuery, *params.ReleasedSince); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UpdatedSince != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "updated_since", runtime.ParamLocationQuery, *params.UpdatedSince); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Host != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "host", runtime.ParamLocationQuery, *params.Host); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.GeoLocation != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "geo_location", runtime.ParamLocationQuery, *params.GeoLocation); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CompleteOnly != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "complete_only", runtime.ParamLocationQuery, *params.CompleteOnly); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IncludeSequence != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include_sequence", runtime.ParamLocationQuery, *params.IncludeSequence); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AuxReport != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "aux_report", runtime.ParamLocationQuery, *params.AuxReport); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSars2ProteinDownloadRequest generates requests for Sars2ProteinDownload
func NewSars2ProteinDownloadRequest(server string, proteins []string, params *Sars2ProteinDownloadParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "proteins", runtime.ParamLocationPath, proteins)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/virus/taxon/sars2/protein/%s/download", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.RefseqOnly != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "refseq_only", runtime.ParamLocationQuery, *params.RefseqOnly); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AnnotatedOnly != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "annotated_only", runtime.ParamLocationQuery, *params.AnnotatedOnly); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ReleasedSince != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "released_since", runtime.ParamLocationQuery, *params.ReleasedSince); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UpdatedSince != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "updated_since", runtime.ParamLocationQuery, *params.UpdatedSince); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Host != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "host", runtime.ParamLocationQuery, *params.Host); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.GeoLocation != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "geo_location", runtime.ParamLocationQuery, *params.GeoLocation); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CompleteOnly != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "complete_only", runtime.ParamLocationQuery, *params.CompleteOnly); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IncludeSequence != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include_sequence", runtime.ParamLocationQuery, *params.IncludeSequence); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AuxReport != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "aux_report", runtime.ParamLocationQuery, *params.AuxReport); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filename != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filename", runtime.ParamLocationQuery, *params.Filename); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSars2ProteinTableRequest generates requests for Sars2ProteinTable
func NewSars2ProteinTableRequest(server string, proteins []string, params *Sars2ProteinTableParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "proteins", runtime.ParamLocationPath, proteins)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/virus/taxon/sars2/protein/%s/table", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.RefseqOnly != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "refseq_only", runtime.ParamLocationQuery, *params.RefseqOnly); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AnnotatedOnly != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "annotated_only", runtime.ParamLocationQuery, *params.AnnotatedOnly); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ReleasedSince != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "released_since", runtime.ParamLocationQuery, *params.ReleasedSince); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UpdatedSince != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "updated_since", runtime.ParamLocationQuery, *params.UpdatedSince); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Host != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "host", runtime.ParamLocationQuery, *params.Host); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.GeoLocation != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "geo_location", runtime.ParamLocationQuery, *params.GeoLocation); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CompleteOnly != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "complete_only", runtime.ParamLocationQuery, *params.CompleteOnly); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TableFields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "table_fields", runtime.ParamLocationQuery, *params.TableFields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IncludeSequence != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include_sequence", runtime.ParamLocationQuery, *params.IncludeSequence); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AuxReport != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "aux_report", runtime.ParamLocationQuery, *params.AuxReport); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Format != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "format", runtime.ParamLocationQuery, *params.Format); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewVirusAnnotationReportsByTaxonRequest generates requests for VirusAnnotationReportsByTaxon
func NewVirusAnnotationReportsByTaxonRequest(server string, taxon string, params *VirusAnnotationReportsByTaxonParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "taxon", runtime.ParamLocationPath, taxon)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/virus/taxon/%s/annotation_report", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.FilterRefseqOnly != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter.refseq_only", runtime.ParamLocationQuery, *params.FilterRefseqOnly); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FilterReleasedSince != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter.released_since", runtime.ParamLocationQuery, *params.FilterReleasedSince); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FilterUpdatedSince != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter.updated_since", runtime.ParamLocationQuery, *params.FilterUpdatedSince); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FilterHost != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter.host", runtime.ParamLocationQuery, *params.FilterHost); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FilterPangolinClassification != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter.pangolin_classification", runtime.ParamLocationQuery, *params.FilterPangolinClassification); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FilterGeoLocation != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter.geo_location", runtime.ParamLocationQuery, *params.FilterGeoLocation); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FilterCompleteOnly != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter.complete_only", runtime.ParamLocationQuery, *params.FilterCompleteOnly); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TableFields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "table_fields", runtime.ParamLocationQuery, *params.TableFields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageSize != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page_size", runtime.ParamLocationQuery, *params.PageSize); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page_token", runtime.ParamLocationQuery, *params.PageToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewVirusReportsByTaxonRequest generates requests for VirusReportsByTaxon
func NewVirusReportsByTaxonRequest(server string, taxon string, params *VirusReportsByTaxonParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "taxon", runtime.ParamLocationPath, taxon)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/virus/taxon/%s/dataset_report", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.FilterRefseqOnly != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter.refseq_only", runtime.ParamLocationQuery, *params.FilterRefseqOnly); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FilterAnnotatedOnly != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter.annotated_only", runtime.ParamLocationQuery, *params.FilterAnnotatedOnly); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FilterReleasedSince != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter.released_since", runtime.ParamLocationQuery, *params.FilterReleasedSince); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FilterUpdatedSince != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter.updated_since", runtime.ParamLocationQuery, *params.FilterUpdatedSince); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FilterHost != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter.host", runtime.ParamLocationQuery, *params.FilterHost); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FilterPangolinClassification != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter.pangolin_classification", runtime.ParamLocationQuery, *params.FilterPangolinClassification); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FilterGeoLocation != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter.geo_location", runtime.ParamLocationQuery, *params.FilterGeoLocation); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FilterCompleteOnly != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter.complete_only", runtime.ParamLocationQuery, *params.FilterCompleteOnly); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ReturnedContent != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "returned_content", runtime.ParamLocationQuery, *params.ReturnedContent); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TableFields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "table_fields", runtime.ParamLocationQuery, *params.TableFields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageSize != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page_size", runtime.ParamLocationQuery, *params.PageSize); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page_token", runtime.ParamLocationQuery, *params.PageToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewVirusGenomeSummaryRequest generates requests for VirusGenomeSummary
func NewVirusGenomeSummaryRequest(server string, taxon string, params *VirusGenomeSummaryParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "taxon", runtime.ParamLocationPath, taxon)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/virus/taxon/%s/genome", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Accessions != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "accessions", runtime.ParamLocationQuery, *params.Accessions); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.RefseqOnly != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "refseq_only", runtime.ParamLocationQuery, *params.RefseqOnly); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AnnotatedOnly != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "annotated_only", runtime.ParamLocationQuery, *params.AnnotatedOnly); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ReleasedSince != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "released_since", runtime.ParamLocationQuery, *params.ReleasedSince); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UpdatedSince != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "updated_since", runtime.ParamLocationQuery, *params.UpdatedSince); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Host != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "host", runtime.ParamLocationQuery, *params.Host); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PangolinClassification != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pangolin_classification", runtime.ParamLocationQuery, *params.PangolinClassification); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.GeoLocation != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "geo_location", runtime.ParamLocationQuery, *params.GeoLocation); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CompleteOnly != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "complete_only", runtime.ParamLocationQuery, *params.CompleteOnly); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IncludeSequence != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include_sequence", runtime.ParamLocationQuery, *params.IncludeSequence); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AuxReport != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "aux_report", runtime.ParamLocationQuery, *params.AuxReport); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewVirusGenomeDownloadRequest generates requests for VirusGenomeDownload
func NewVirusGenomeDownloadRequest(server string, taxon string, params *VirusGenomeDownloadParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "taxon", runtime.ParamLocationPath, taxon)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/virus/taxon/%s/genome/download", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.RefseqOnly != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "refseq_only", runtime.ParamLocationQuery, *params.RefseqOnly); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AnnotatedOnly != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "annotated_only", runtime.ParamLocationQuery, *params.AnnotatedOnly); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ReleasedSince != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "released_since", runtime.ParamLocationQuery, *params.ReleasedSince); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UpdatedSince != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "updated_since", runtime.ParamLocationQuery, *params.UpdatedSince); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Host != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "host", runtime.ParamLocationQuery, *params.Host); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PangolinClassification != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pangolin_classification", runtime.ParamLocationQuery, *params.PangolinClassification); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.GeoLocation != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "geo_location", runtime.ParamLocationQuery, *params.GeoLocation); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CompleteOnly != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "complete_only", runtime.ParamLocationQuery, *params.CompleteOnly); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IncludeSequence != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include_sequence", runtime.ParamLocationQuery, *params.IncludeSequence); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AuxReport != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "aux_report", runtime.ParamLocationQuery, *params.AuxReport); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UsePsg != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "use_psg", runtime.ParamLocationQuery, *params.UsePsg); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filename != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filename", runtime.ParamLocationQuery, *params.Filename); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewVirusGenomeTableRequest generates requests for VirusGenomeTable
func NewVirusGenomeTableRequest(server string, taxon string, params *VirusGenomeTableParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "taxon", runtime.ParamLocationPath, taxon)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/virus/taxon/%s/genome/table", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Accessions != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "accessions", runtime.ParamLocationQuery, *params.Accessions); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.RefseqOnly != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "refseq_only", runtime.ParamLocationQuery, *params.RefseqOnly); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AnnotatedOnly != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "annotated_only", runtime.ParamLocationQuery, *params.AnnotatedOnly); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ReleasedSince != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "released_since", runtime.ParamLocationQuery, *params.ReleasedSince); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UpdatedSince != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "updated_since", runtime.ParamLocationQuery, *params.UpdatedSince); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Host != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "host", runtime.ParamLocationQuery, *params.Host); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PangolinClassification != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pangolin_classification", runtime.ParamLocationQuery, *params.PangolinClassification); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.GeoLocation != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "geo_location", runtime.ParamLocationQuery, *params.GeoLocation); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CompleteOnly != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "complete_only", runtime.ParamLocationQuery, *params.CompleteOnly); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TableFields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "table_fields", runtime.ParamLocationQuery, *params.TableFields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IncludeSequence != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include_sequence", runtime.ParamLocationQuery, *params.IncludeSequence); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AuxReport != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "aux_report", runtime.ParamLocationQuery, *params.AuxReport); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Format != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "format", runtime.ParamLocationQuery, *params.Format); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// BioSampleDatasetReportWithResponse request
	BioSampleDatasetReportWithResponse(ctx context.Context, accessions []string, reqEditors ...RequestEditorFn) (*BioSampleDatasetReportResponse, error)

	// GeneMetadataByPostWithBodyWithResponse request with any body
	GeneMetadataByPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GeneMetadataByPostResponse, error)

	GeneMetadataByPostWithResponse(ctx context.Context, body GeneMetadataByPostJSONRequestBody, reqEditors ...RequestEditorFn) (*GeneMetadataByPostResponse, error)

	// GeneMetadataByAccessionWithResponse request
	GeneMetadataByAccessionWithResponse(ctx context.Context, accessions []string, params *GeneMetadataByAccessionParams, reqEditors ...RequestEditorFn) (*GeneMetadataByAccessionResponse, error)

	// DownloadGenePackagePostWithBodyWithResponse request with any body
	DownloadGenePackagePostWithBodyWithResponse(ctx context.Context, params *DownloadGenePackagePostParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DownloadGenePackagePostResponse, error)

	DownloadGenePackagePostWithResponse(ctx context.Context, params *DownloadGenePackagePostParams, body DownloadGenePackagePostJSONRequestBody, reqEditors ...RequestEditorFn) (*DownloadGenePackagePostResponse, error)

	// GeneDownloadSummaryByPostWithBodyWithResponse request with any body
	GeneDownloadSummaryByPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GeneDownloadSummaryByPostResponse, error)

	GeneDownloadSummaryByPostWithResponse(ctx context.Context, body GeneDownloadSummaryByPostJSONRequestBody, reqEditors ...RequestEditorFn) (*GeneDownloadSummaryByPostResponse, error)

	// GeneReportsByIdWithResponse request
	GeneReportsByIdWithResponse(ctx context.Context, geneIds []int, params *GeneReportsByIdParams, reqEditors ...RequestEditorFn) (*GeneReportsByIdResponse, error)

	// DownloadGenePackageWithResponse request
	DownloadGenePackageWithResponse(ctx context.Context, geneIds []int, params *DownloadGenePackageParams, reqEditors ...RequestEditorFn) (*DownloadGenePackageResponse, error)

	// GeneDownloadSummaryByIdWithResponse request
	GeneDownloadSummaryByIdWithResponse(ctx context.Context, geneIds []int, params *GeneDownloadSummaryByIdParams, reqEditors ...RequestEditorFn) (*GeneDownloadSummaryByIdResponse, error)

	// GeneLinksByIdWithResponse request
	GeneLinksByIdWithResponse(ctx context.Context, geneIds []int, reqEditors ...RequestEditorFn) (*GeneLinksByIdResponse, error)

	// GeneOrthologsByIdWithResponse request
	GeneOrthologsByIdWithResponse(ctx context.Context, geneId int, params *GeneOrthologsByIdParams, reqEditors ...RequestEditorFn) (*GeneOrthologsByIdResponse, error)

	// GeneLinksByIdByPostWithBodyWithResponse request with any body
	GeneLinksByIdByPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GeneLinksByIdByPostResponse, error)

	GeneLinksByIdByPostWithResponse(ctx context.Context, body GeneLinksByIdByPostJSONRequestBody, reqEditors ...RequestEditorFn) (*GeneLinksByIdByPostResponse, error)

	// GeneOrthologsByPostWithBodyWithResponse request with any body
	GeneOrthologsByPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GeneOrthologsByPostResponse, error)

	GeneOrthologsByPostWithResponse(ctx context.Context, body GeneOrthologsByPostJSONRequestBody, reqEditors ...RequestEditorFn) (*GeneOrthologsByPostResponse, error)

	// GeneMetadataByTaxAndSymbolWithResponse request
	GeneMetadataByTaxAndSymbolWithResponse(ctx context.Context, symbols []string, taxon string, params *GeneMetadataByTaxAndSymbolParams, reqEditors ...RequestEditorFn) (*GeneMetadataByTaxAndSymbolResponse, error)

	// GeneCountsForTaxonByPostWithBodyWithResponse request with any body
	GeneCountsForTaxonByPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GeneCountsForTaxonByPostResponse, error)

	GeneCountsForTaxonByPostWithResponse(ctx context.Context, body GeneCountsForTaxonByPostJSONRequestBody, reqEditors ...RequestEditorFn) (*GeneCountsForTaxonByPostResponse, error)

	// GeneReportsByTaxonWithResponse request
	GeneReportsByTaxonWithResponse(ctx context.Context, taxon string, params *GeneReportsByTaxonParams, reqEditors ...RequestEditorFn) (*GeneReportsByTaxonResponse, error)

	// GeneChromosomeSummaryWithResponse request
	GeneChromosomeSummaryWithResponse(ctx context.Context, taxon string, annotationName string, reqEditors ...RequestEditorFn) (*GeneChromosomeSummaryResponse, error)

	// GeneCountsForTaxonWithResponse request
	GeneCountsForTaxonWithResponse(ctx context.Context, taxon string, reqEditors ...RequestEditorFn) (*GeneCountsForTaxonResponse, error)

	// CheckAssemblyAvailabilityWithResponse request
	CheckAssemblyAvailabilityWithResponse(ctx context.Context, accessions []string, params *CheckAssemblyAvailabilityParams, reqEditors ...RequestEditorFn) (*CheckAssemblyAvailabilityResponse, error)

	// GenomeDatasetReportWithResponse request
	GenomeDatasetReportWithResponse(ctx context.Context, accessions []string, params *GenomeDatasetReportParams, reqEditors ...RequestEditorFn) (*GenomeDatasetReportResponse, error)

	// DownloadAssemblyPackageWithResponse request
	DownloadAssemblyPackageWithResponse(ctx context.Context, accessions []string, params *DownloadAssemblyPackageParams, reqEditors ...RequestEditorFn) (*DownloadAssemblyPackageResponse, error)

	// GenomeDownloadSummaryWithResponse request
	GenomeDownloadSummaryWithResponse(ctx context.Context, accessions []string, params *GenomeDownloadSummaryParams, reqEditors ...RequestEditorFn) (*GenomeDownloadSummaryResponse, error)

	// GenomeLinksByAccessionWithResponse request
	GenomeLinksByAccessionWithResponse(ctx context.Context, accessions []string, reqEditors ...RequestEditorFn) (*GenomeLinksByAccessionResponse, error)

	// GenomeAnnotationReportWithResponse request
	GenomeAnnotationReportWithResponse(ctx context.Context, accession string, params *GenomeAnnotationReportParams, reqEditors ...RequestEditorFn) (*GenomeAnnotationReportResponse, error)

	// DownloadGenomeAnnotationPackageWithResponse request
	DownloadGenomeAnnotationPackageWithResponse(ctx context.Context, accession string, params *DownloadGenomeAnnotationPackageParams, reqEditors ...RequestEditorFn) (*DownloadGenomeAnnotationPackageResponse, error)

	// GenomeAnnotationDownloadSummaryWithResponse request
	GenomeAnnotationDownloadSummaryWithResponse(ctx context.Context, accession string, params *GenomeAnnotationDownloadSummaryParams, reqEditors ...RequestEditorFn) (*GenomeAnnotationDownloadSummaryResponse, error)

	// AnnotationReportFacetsWithResponse request
	AnnotationReportFacetsWithResponse(ctx context.Context, accession string, annotationIds []string, params *AnnotationReportFacetsParams, reqEditors ...RequestEditorFn) (*AnnotationReportFacetsResponse, error)

	// AssemblyRevisionHistoryByGetWithResponse request
	AssemblyRevisionHistoryByGetWithResponse(ctx context.Context, accession string, reqEditors ...RequestEditorFn) (*AssemblyRevisionHistoryByGetResponse, error)

	// GenomeSequenceReportWithResponse request
	GenomeSequenceReportWithResponse(ctx context.Context, accession string, params *GenomeSequenceReportParams, reqEditors ...RequestEditorFn) (*GenomeSequenceReportResponse, error)

	// GenomeAnnotationReportByPostWithBodyWithResponse request with any body
	GenomeAnnotationReportByPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GenomeAnnotationReportByPostResponse, error)

	GenomeAnnotationReportByPostWithResponse(ctx context.Context, body GenomeAnnotationReportByPostJSONRequestBody, reqEditors ...RequestEditorFn) (*GenomeAnnotationReportByPostResponse, error)

	// DownloadGenomeAnnotationPackageByPostWithBodyWithResponse request with any body
	DownloadGenomeAnnotationPackageByPostWithBodyWithResponse(ctx context.Context, params *DownloadGenomeAnnotationPackageByPostParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DownloadGenomeAnnotationPackageByPostResponse, error)

	DownloadGenomeAnnotationPackageByPostWithResponse(ctx context.Context, params *DownloadGenomeAnnotationPackageByPostParams, body DownloadGenomeAnnotationPackageByPostJSONRequestBody, reqEditors ...RequestEditorFn) (*DownloadGenomeAnnotationPackageByPostResponse, error)

	// GenomeAnnotationDownloadSummaryByPostWithBodyWithResponse request with any body
	GenomeAnnotationDownloadSummaryByPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GenomeAnnotationDownloadSummaryByPostResponse, error)

	GenomeAnnotationDownloadSummaryByPostWithResponse(ctx context.Context, body GenomeAnnotationDownloadSummaryByPostJSONRequestBody, reqEditors ...RequestEditorFn) (*GenomeAnnotationDownloadSummaryByPostResponse, error)

	// AnnotationReportFacetsByPostWithBodyWithResponse request with any body
	AnnotationReportFacetsByPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AnnotationReportFacetsByPostResponse, error)

	AnnotationReportFacetsByPostWithResponse(ctx context.Context, body AnnotationReportFacetsByPostJSONRequestBody, reqEditors ...RequestEditorFn) (*AnnotationReportFacetsByPostResponse, error)

	// GenomeDatasetReportsByAssemblyNameWithResponse request
	GenomeDatasetReportsByAssemblyNameWithResponse(ctx context.Context, assemblyNames []string, params *GenomeDatasetReportsByAssemblyNameParams, reqEditors ...RequestEditorFn) (*GenomeDatasetReportsByAssemblyNameResponse, error)

	// GenomeDatasetReportsByBioprojectWithResponse request
	GenomeDatasetReportsByBioprojectWithResponse(ctx context.Context, bioprojects []string, params *GenomeDatasetReportsByBioprojectParams, reqEditors ...RequestEditorFn) (*GenomeDatasetReportsByBioprojectResponse, error)

	// GenomeDatasetReportsByBiosampleIdWithResponse request
	GenomeDatasetReportsByBiosampleIdWithResponse(ctx context.Context, biosampleIds []string, params *GenomeDatasetReportsByBiosampleIdParams, reqEditors ...RequestEditorFn) (*GenomeDatasetReportsByBiosampleIdResponse, error)

	// CheckAssemblyAvailabilityPostWithBodyWithResponse request with any body
	CheckAssemblyAvailabilityPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CheckAssemblyAvailabilityPostResponse, error)

	CheckAssemblyAvailabilityPostWithResponse(ctx context.Context, body CheckAssemblyAvailabilityPostJSONRequestBody, reqEditors ...RequestEditorFn) (*CheckAssemblyAvailabilityPostResponse, error)

	// CheckmHistogramByTaxonByPostWithBodyWithResponse request with any body
	CheckmHistogramByTaxonByPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CheckmHistogramByTaxonByPostResponse, error)

	CheckmHistogramByTaxonByPostWithResponse(ctx context.Context, body CheckmHistogramByTaxonByPostJSONRequestBody, reqEditors ...RequestEditorFn) (*CheckmHistogramByTaxonByPostResponse, error)

	// GenomeDatasetReportByPostWithBodyWithResponse request with any body
	GenomeDatasetReportByPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GenomeDatasetReportByPostResponse, error)

	GenomeDatasetReportByPostWithResponse(ctx context.Context, body GenomeDatasetReportByPostJSONRequestBody, reqEditors ...RequestEditorFn) (*GenomeDatasetReportByPostResponse, error)

	// DownloadAssemblyPackagePostWithBodyWithResponse request with any body
	DownloadAssemblyPackagePostWithBodyWithResponse(ctx context.Context, params *DownloadAssemblyPackagePostParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DownloadAssemblyPackagePostResponse, error)

	DownloadAssemblyPackagePostWithResponse(ctx context.Context, params *DownloadAssemblyPackagePostParams, body DownloadAssemblyPackagePostJSONRequestBody, reqEditors ...RequestEditorFn) (*DownloadAssemblyPackagePostResponse, error)

	// GenomeDownloadSummaryByPostWithBodyWithResponse request with any body
	GenomeDownloadSummaryByPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GenomeDownloadSummaryByPostResponse, error)

	GenomeDownloadSummaryByPostWithResponse(ctx context.Context, body GenomeDownloadSummaryByPostJSONRequestBody, reqEditors ...RequestEditorFn) (*GenomeDownloadSummaryByPostResponse, error)

	// GenomeLinksByAccessionByPostWithBodyWithResponse request with any body
	GenomeLinksByAccessionByPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GenomeLinksByAccessionByPostResponse, error)

	GenomeLinksByAccessionByPostWithResponse(ctx context.Context, body GenomeLinksByAccessionByPostJSONRequestBody, reqEditors ...RequestEditorFn) (*GenomeLinksByAccessionByPostResponse, error)

	// AssemblyRevisionHistoryByPostWithBodyWithResponse request with any body
	AssemblyRevisionHistoryByPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AssemblyRevisionHistoryByPostResponse, error)

	AssemblyRevisionHistoryByPostWithResponse(ctx context.Context, body AssemblyRevisionHistoryByPostJSONRequestBody, reqEditors ...RequestEditorFn) (*AssemblyRevisionHistoryByPostResponse, error)

	// AssemblyAccessionsForSequenceAccessionWithResponse request
	AssemblyAccessionsForSequenceAccessionWithResponse(ctx context.Context, accession string, reqEditors ...RequestEditorFn) (*AssemblyAccessionsForSequenceAccessionResponse, error)

	// AssemblyAccessionsForSequenceAccessionByPostWithBodyWithResponse request with any body
	AssemblyAccessionsForSequenceAccessionByPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AssemblyAccessionsForSequenceAccessionByPostResponse, error)

	AssemblyAccessionsForSequenceAccessionByPostWithResponse(ctx context.Context, body AssemblyAccessionsForSequenceAccessionByPostJSONRequestBody, reqEditors ...RequestEditorFn) (*AssemblyAccessionsForSequenceAccessionByPostResponse, error)

	// GenomeSequenceReportByPostWithBodyWithResponse request with any body
	GenomeSequenceReportByPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GenomeSequenceReportByPostResponse, error)

	GenomeSequenceReportByPostWithResponse(ctx context.Context, body GenomeSequenceReportByPostJSONRequestBody, reqEditors ...RequestEditorFn) (*GenomeSequenceReportByPostResponse, error)

	// CheckmHistogramByTaxonWithResponse request
	CheckmHistogramByTaxonWithResponse(ctx context.Context, speciesTaxon string, reqEditors ...RequestEditorFn) (*CheckmHistogramByTaxonResponse, error)

	// GenomeDatasetReportsByTaxonWithResponse request
	GenomeDatasetReportsByTaxonWithResponse(ctx context.Context, taxons []string, params *GenomeDatasetReportsByTaxonParams, reqEditors ...RequestEditorFn) (*GenomeDatasetReportsByTaxonResponse, error)

	// GenomeDatasetReportsByWgsWithResponse request
	GenomeDatasetReportsByWgsWithResponse(ctx context.Context, wgsAccessions []string, params *GenomeDatasetReportsByWgsParams, reqEditors ...RequestEditorFn) (*GenomeDatasetReportsByWgsResponse, error)

	// DownloadOrganellePackageWithResponse request
	DownloadOrganellePackageWithResponse(ctx context.Context, accessions []string, params *DownloadOrganellePackageParams, reqEditors ...RequestEditorFn) (*DownloadOrganellePackageResponse, error)

	// OrganelleDatareportByAccessionWithResponse request
	OrganelleDatareportByAccessionWithResponse(ctx context.Context, accessions []string, params *OrganelleDatareportByAccessionParams, reqEditors ...RequestEditorFn) (*OrganelleDatareportByAccessionResponse, error)

	// OrganelleDatareportByPostWithBodyWithResponse request with any body
	OrganelleDatareportByPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*OrganelleDatareportByPostResponse, error)

	OrganelleDatareportByPostWithResponse(ctx context.Context, body OrganelleDatareportByPostJSONRequestBody, reqEditors ...RequestEditorFn) (*OrganelleDatareportByPostResponse, error)

	// DownloadOrganellePackageByPostWithBodyWithResponse request with any body
	DownloadOrganellePackageByPostWithBodyWithResponse(ctx context.Context, params *DownloadOrganellePackageByPostParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DownloadOrganellePackageByPostResponse, error)

	DownloadOrganellePackageByPostWithResponse(ctx context.Context, params *DownloadOrganellePackageByPostParams, body DownloadOrganellePackageByPostJSONRequestBody, reqEditors ...RequestEditorFn) (*DownloadOrganellePackageByPostResponse, error)

	// OrganelleDatareportByTaxonWithResponse request
	OrganelleDatareportByTaxonWithResponse(ctx context.Context, taxons []string, params *OrganelleDatareportByTaxonParams, reqEditors ...RequestEditorFn) (*OrganelleDatareportByTaxonResponse, error)

	// DownloadProkaryoteGenePackagePostWithBodyWithResponse request with any body
	DownloadProkaryoteGenePackagePostWithBodyWithResponse(ctx context.Context, params *DownloadProkaryoteGenePackagePostParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DownloadProkaryoteGenePackagePostResponse, error)

	DownloadProkaryoteGenePackagePostWithResponse(ctx context.Context, params *DownloadProkaryoteGenePackagePostParams, body DownloadProkaryoteGenePackagePostJSONRequestBody, reqEditors ...RequestEditorFn) (*DownloadProkaryoteGenePackagePostResponse, error)

	// DownloadProkaryoteGenePackageWithResponse request
	DownloadProkaryoteGenePackageWithResponse(ctx context.Context, accessions []string, params *DownloadProkaryoteGenePackageParams, reqEditors ...RequestEditorFn) (*DownloadProkaryoteGenePackageResponse, error)

	// TaxonomyMetadataPostWithBodyWithResponse request with any body
	TaxonomyMetadataPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TaxonomyMetadataPostResponse, error)

	TaxonomyMetadataPostWithResponse(ctx context.Context, body TaxonomyMetadataPostJSONRequestBody, reqEditors ...RequestEditorFn) (*TaxonomyMetadataPostResponse, error)

	// TaxonomyDataReportPostWithBodyWithResponse request with any body
	TaxonomyDataReportPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TaxonomyDataReportPostResponse, error)

	TaxonomyDataReportPostWithResponse(ctx context.Context, body TaxonomyDataReportPostJSONRequestBody, reqEditors ...RequestEditorFn) (*TaxonomyDataReportPostResponse, error)

	// DownloadTaxonomyPackageByPostWithBodyWithResponse request with any body
	DownloadTaxonomyPackageByPostWithBodyWithResponse(ctx context.Context, params *DownloadTaxonomyPackageByPostParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DownloadTaxonomyPackageByPostResponse, error)

	DownloadTaxonomyPackageByPostWithResponse(ctx context.Context, params *DownloadTaxonomyPackageByPostParams, body DownloadTaxonomyPackageByPostJSONRequestBody, reqEditors ...RequestEditorFn) (*DownloadTaxonomyPackageByPostResponse, error)

	// TaxonomyFilteredSubtreePostWithBodyWithResponse request with any body
	TaxonomyFilteredSubtreePostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TaxonomyFilteredSubtreePostResponse, error)

	TaxonomyFilteredSubtreePostWithResponse(ctx context.Context, body TaxonomyFilteredSubtreePostJSONRequestBody, reqEditors ...RequestEditorFn) (*TaxonomyFilteredSubtreePostResponse, error)

	// TaxonomyImagePostWithBodyWithResponse request with any body
	TaxonomyImagePostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TaxonomyImagePostResponse, error)

	TaxonomyImagePostWithResponse(ctx context.Context, body TaxonomyImagePostJSONRequestBody, reqEditors ...RequestEditorFn) (*TaxonomyImagePostResponse, error)

	// TaxonomyImageMetadataPostWithBodyWithResponse request with any body
	TaxonomyImageMetadataPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TaxonomyImageMetadataPostResponse, error)

	TaxonomyImageMetadataPostWithResponse(ctx context.Context, body TaxonomyImageMetadataPostJSONRequestBody, reqEditors ...RequestEditorFn) (*TaxonomyImageMetadataPostResponse, error)

	// TaxonomyLinksByPostWithBodyWithResponse request with any body
	TaxonomyLinksByPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TaxonomyLinksByPostResponse, error)

	TaxonomyLinksByPostWithResponse(ctx context.Context, body TaxonomyLinksByPostJSONRequestBody, reqEditors ...RequestEditorFn) (*TaxonomyLinksByPostResponse, error)

	// TaxonomyNamesPostWithBodyWithResponse request with any body
	TaxonomyNamesPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TaxonomyNamesPostResponse, error)

	TaxonomyNamesPostWithResponse(ctx context.Context, body TaxonomyNamesPostJSONRequestBody, reqEditors ...RequestEditorFn) (*TaxonomyNamesPostResponse, error)

	// TaxonomyRelatedIdsPostWithBodyWithResponse request with any body
	TaxonomyRelatedIdsPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TaxonomyRelatedIdsPostResponse, error)

	TaxonomyRelatedIdsPostWithResponse(ctx context.Context, body TaxonomyRelatedIdsPostJSONRequestBody, reqEditors ...RequestEditorFn) (*TaxonomyRelatedIdsPostResponse, error)

	// DownloadTaxonomyPackageWithResponse request
	DownloadTaxonomyPackageWithResponse(ctx context.Context, taxIds []int, params *DownloadTaxonomyPackageParams, reqEditors ...RequestEditorFn) (*DownloadTaxonomyPackageResponse, error)

	// TaxonomyRelatedIdsWithResponse request
	TaxonomyRelatedIdsWithResponse(ctx context.Context, taxId int, params *TaxonomyRelatedIdsParams, reqEditors ...RequestEditorFn) (*TaxonomyRelatedIdsResponse, error)

	// TaxonomyMetadataWithResponse request
	TaxonomyMetadataWithResponse(ctx context.Context, taxons []string, params *TaxonomyMetadataParams, reqEditors ...RequestEditorFn) (*TaxonomyMetadataResponse, error)

	// TaxonomyDataReportWithResponse request
	TaxonomyDataReportWithResponse(ctx context.Context, taxons []string, params *TaxonomyDataReportParams, reqEditors ...RequestEditorFn) (*TaxonomyDataReportResponse, error)

	// TaxonomyFilteredSubtreeWithResponse request
	TaxonomyFilteredSubtreeWithResponse(ctx context.Context, taxons []string, params *TaxonomyFilteredSubtreeParams, reqEditors ...RequestEditorFn) (*TaxonomyFilteredSubtreeResponse, error)

	// TaxonomyNamesWithResponse request
	TaxonomyNamesWithResponse(ctx context.Context, taxons []string, params *TaxonomyNamesParams, reqEditors ...RequestEditorFn) (*TaxonomyNamesResponse, error)

	// TaxonomyImageWithResponse request
	TaxonomyImageWithResponse(ctx context.Context, taxon string, params *TaxonomyImageParams, reqEditors ...RequestEditorFn) (*TaxonomyImageResponse, error)

	// TaxonomyImageMetadataWithResponse request
	TaxonomyImageMetadataWithResponse(ctx context.Context, taxon string, reqEditors ...RequestEditorFn) (*TaxonomyImageMetadataResponse, error)

	// TaxonomyLinksWithResponse request
	TaxonomyLinksWithResponse(ctx context.Context, taxon string, reqEditors ...RequestEditorFn) (*TaxonomyLinksResponse, error)

	// TaxNameQueryByPostWithBodyWithResponse request with any body
	TaxNameQueryByPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TaxNameQueryByPostResponse, error)

	TaxNameQueryByPostWithResponse(ctx context.Context, body TaxNameQueryByPostJSONRequestBody, reqEditors ...RequestEditorFn) (*TaxNameQueryByPostResponse, error)

	// TaxNameQueryWithResponse request
	TaxNameQueryWithResponse(ctx context.Context, taxonQuery string, params *TaxNameQueryParams, reqEditors ...RequestEditorFn) (*TaxNameQueryResponse, error)

	// VersionWithResponse request
	VersionWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*VersionResponse, error)

	// VirusReportsByPostWithBodyWithResponse request with any body
	VirusReportsByPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*VirusReportsByPostResponse, error)

	VirusReportsByPostWithResponse(ctx context.Context, body VirusReportsByPostJSONRequestBody, reqEditors ...RequestEditorFn) (*VirusReportsByPostResponse, error)

	// VirusAnnotationReportsByAcessionsWithResponse request
	VirusAnnotationReportsByAcessionsWithResponse(ctx context.Context, accessions []string, params *VirusAnnotationReportsByAcessionsParams, reqEditors ...RequestEditorFn) (*VirusAnnotationReportsByAcessionsResponse, error)

	// VirusAccessionAvailabilityWithResponse request
	VirusAccessionAvailabilityWithResponse(ctx context.Context, accessions []string, reqEditors ...RequestEditorFn) (*VirusAccessionAvailabilityResponse, error)

	// VirusReportsByAcessionsWithResponse request
	VirusReportsByAcessionsWithResponse(ctx context.Context, accessions []string, params *VirusReportsByAcessionsParams, reqEditors ...RequestEditorFn) (*VirusReportsByAcessionsResponse, error)

	// VirusGenomeDownloadAccessionWithResponse request
	VirusGenomeDownloadAccessionWithResponse(ctx context.Context, accessions []string, params *VirusGenomeDownloadAccessionParams, reqEditors ...RequestEditorFn) (*VirusGenomeDownloadAccessionResponse, error)

	// VirusAnnotationReportsByPostWithBodyWithResponse request with any body
	VirusAnnotationReportsByPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*VirusAnnotationReportsByPostResponse, error)

	VirusAnnotationReportsByPostWithResponse(ctx context.Context, body VirusAnnotationReportsByPostJSONRequestBody, reqEditors ...RequestEditorFn) (*VirusAnnotationReportsByPostResponse, error)

	// VirusAccessionAvailabilityPostWithBodyWithResponse request with any body
	VirusAccessionAvailabilityPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*VirusAccessionAvailabilityPostResponse, error)

	VirusAccessionAvailabilityPostWithResponse(ctx context.Context, body VirusAccessionAvailabilityPostJSONRequestBody, reqEditors ...RequestEditorFn) (*VirusAccessionAvailabilityPostResponse, error)

	// VirusGenomeSummaryByPostWithBodyWithResponse request with any body
	VirusGenomeSummaryByPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*VirusGenomeSummaryByPostResponse, error)

	VirusGenomeSummaryByPostWithResponse(ctx context.Context, body VirusGenomeSummaryByPostJSONRequestBody, reqEditors ...RequestEditorFn) (*VirusGenomeSummaryByPostResponse, error)

	// VirusGenomeDownloadPostWithBodyWithResponse request with any body
	VirusGenomeDownloadPostWithBodyWithResponse(ctx context.Context, params *VirusGenomeDownloadPostParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*VirusGenomeDownloadPostResponse, error)

	VirusGenomeDownloadPostWithResponse(ctx context.Context, params *VirusGenomeDownloadPostParams, body VirusGenomeDownloadPostJSONRequestBody, reqEditors ...RequestEditorFn) (*VirusGenomeDownloadPostResponse, error)

	// Sars2ProteinSummaryByPostWithBodyWithResponse request with any body
	Sars2ProteinSummaryByPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*Sars2ProteinSummaryByPostResponse, error)

	Sars2ProteinSummaryByPostWithResponse(ctx context.Context, body Sars2ProteinSummaryByPostJSONRequestBody, reqEditors ...RequestEditorFn) (*Sars2ProteinSummaryByPostResponse, error)

	// Sars2ProteinDownloadPostWithBodyWithResponse request with any body
	Sars2ProteinDownloadPostWithBodyWithResponse(ctx context.Context, params *Sars2ProteinDownloadPostParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*Sars2ProteinDownloadPostResponse, error)

	Sars2ProteinDownloadPostWithResponse(ctx context.Context, params *Sars2ProteinDownloadPostParams, body Sars2ProteinDownloadPostJSONRequestBody, reqEditors ...RequestEditorFn) (*Sars2ProteinDownloadPostResponse, error)

	// Sars2ProteinSummaryWithResponse request
	Sars2ProteinSummaryWithResponse(ctx context.Context, proteins []string, params *Sars2ProteinSummaryParams, reqEditors ...RequestEditorFn) (*Sars2ProteinSummaryResponse, error)

	// Sars2ProteinDownloadWithResponse request
	Sars2ProteinDownloadWithResponse(ctx context.Context, proteins []string, params *Sars2ProteinDownloadParams, reqEditors ...RequestEditorFn) (*Sars2ProteinDownloadResponse, error)

	// Sars2ProteinTableWithResponse request
	Sars2ProteinTableWithResponse(ctx context.Context, proteins []string, params *Sars2ProteinTableParams, reqEditors ...RequestEditorFn) (*Sars2ProteinTableResponse, error)

	// VirusAnnotationReportsByTaxonWithResponse request
	VirusAnnotationReportsByTaxonWithResponse(ctx context.Context, taxon string, params *VirusAnnotationReportsByTaxonParams, reqEditors ...RequestEditorFn) (*VirusAnnotationReportsByTaxonResponse, error)

	// VirusReportsByTaxonWithResponse request
	VirusReportsByTaxonWithResponse(ctx context.Context, taxon string, params *VirusReportsByTaxonParams, reqEditors ...RequestEditorFn) (*VirusReportsByTaxonResponse, error)

	// VirusGenomeSummaryWithResponse request
	VirusGenomeSummaryWithResponse(ctx context.Context, taxon string, params *VirusGenomeSummaryParams, reqEditors ...RequestEditorFn) (*VirusGenomeSummaryResponse, error)

	// VirusGenomeDownloadWithResponse request
	VirusGenomeDownloadWithResponse(ctx context.Context, taxon string, params *VirusGenomeDownloadParams, reqEditors ...RequestEditorFn) (*VirusGenomeDownloadResponse, error)

	// VirusGenomeTableWithResponse request
	VirusGenomeTableWithResponse(ctx context.Context, taxon string, params *VirusGenomeTableParams, reqEditors ...RequestEditorFn) (*VirusGenomeTableResponse, error)
}

type BioSampleDatasetReportResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V2reportsBioSampleDataReportPage
}

// Status returns HTTPResponse.Status
func (r BioSampleDatasetReportResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r BioSampleDatasetReportResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GeneMetadataByPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V2reportsGeneDataReportPage
}

// Status returns HTTPResponse.Status
func (r GeneMetadataByPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GeneMetadataByPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GeneMetadataByAccessionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V2reportsGeneDataReportPage
}

// Status returns HTTPResponse.Status
func (r GeneMetadataByAccessionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GeneMetadataByAccessionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DownloadGenePackagePostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DownloadGenePackagePostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DownloadGenePackagePostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GeneDownloadSummaryByPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V2DownloadSummary
}

// Status returns HTTPResponse.Status
func (r GeneDownloadSummaryByPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GeneDownloadSummaryByPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GeneReportsByIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V2reportsGeneDataReportPage
}

// Status returns HTTPResponse.Status
func (r GeneReportsByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GeneReportsByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DownloadGenePackageResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DownloadGenePackageResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DownloadGenePackageResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GeneDownloadSummaryByIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V2DownloadSummary
}

// Status returns HTTPResponse.Status
func (r GeneDownloadSummaryByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GeneDownloadSummaryByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GeneLinksByIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V2GeneLinksReply
}

// Status returns HTTPResponse.Status
func (r GeneLinksByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GeneLinksByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GeneOrthologsByIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V2reportsGeneDataReportPage
}

// Status returns HTTPResponse.Status
func (r GeneOrthologsByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GeneOrthologsByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GeneLinksByIdByPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V2GeneLinksReply
}

// Status returns HTTPResponse.Status
func (r GeneLinksByIdByPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GeneLinksByIdByPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GeneOrthologsByPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V2reportsGeneDataReportPage
}

// Status returns HTTPResponse.Status
func (r GeneOrthologsByPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GeneOrthologsByPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GeneMetadataByTaxAndSymbolResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V2reportsGeneDataReportPage
}

// Status returns HTTPResponse.Status
func (r GeneMetadataByTaxAndSymbolResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GeneMetadataByTaxAndSymbolResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GeneCountsForTaxonByPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V2GeneCountsByTaxonReply
}

// Status returns HTTPResponse.Status
func (r GeneCountsForTaxonByPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GeneCountsForTaxonByPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GeneReportsByTaxonResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V2reportsGeneDataReportPage
}

// Status returns HTTPResponse.Status
func (r GeneReportsByTaxonResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GeneReportsByTaxonResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GeneChromosomeSummaryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V2GeneChromosomeSummaryReply
}

// Status returns HTTPResponse.Status
func (r GeneChromosomeSummaryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GeneChromosomeSummaryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GeneCountsForTaxonResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V2GeneCountsByTaxonReply
}

// Status returns HTTPResponse.Status
func (r GeneCountsForTaxonResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GeneCountsForTaxonResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CheckAssemblyAvailabilityResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V2AssemblyDatasetAvailability
}

// Status returns HTTPResponse.Status
func (r CheckAssemblyAvailabilityResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CheckAssemblyAvailabilityResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GenomeDatasetReportResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V2reportsAssemblyDataReportPage
}

// Status returns HTTPResponse.Status
func (r GenomeDatasetReportResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GenomeDatasetReportResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DownloadAssemblyPackageResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DownloadAssemblyPackageResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DownloadAssemblyPackageResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GenomeDownloadSummaryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V2DownloadSummary
}

// Status returns HTTPResponse.Status
func (r GenomeDownloadSummaryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GenomeDownloadSummaryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GenomeLinksByAccessionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V2AssemblyLinksReply
}

// Status returns HTTPResponse.Status
func (r GenomeLinksByAccessionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GenomeLinksByAccessionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GenomeAnnotationReportResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V2reportsGenomeAnnotationReportPage
}

// Status returns HTTPResponse.Status
func (r GenomeAnnotationReportResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GenomeAnnotationReportResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DownloadGenomeAnnotationPackageResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DownloadGenomeAnnotationPackageResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DownloadGenomeAnnotationPackageResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GenomeAnnotationDownloadSummaryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V2DownloadSummary
}

// Status returns HTTPResponse.Status
func (r GenomeAnnotationDownloadSummaryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GenomeAnnotationDownloadSummaryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AnnotationReportFacetsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V2GenomeAnnotationTableSummaryReply
}

// Status returns HTTPResponse.Status
func (r AnnotationReportFacetsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AnnotationReportFacetsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AssemblyRevisionHistoryByGetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V2AssemblyRevisionHistory
}

// Status returns HTTPResponse.Status
func (r AssemblyRevisionHistoryByGetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AssemblyRevisionHistoryByGetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GenomeSequenceReportResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V2SequenceReportPage
}

// Status returns HTTPResponse.Status
func (r GenomeSequenceReportResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GenomeSequenceReportResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GenomeAnnotationReportByPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V2reportsGenomeAnnotationReportPage
}

// Status returns HTTPResponse.Status
func (r GenomeAnnotationReportByPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GenomeAnnotationReportByPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DownloadGenomeAnnotationPackageByPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DownloadGenomeAnnotationPackageByPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DownloadGenomeAnnotationPackageByPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GenomeAnnotationDownloadSummaryByPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V2DownloadSummary
}

// Status returns HTTPResponse.Status
func (r GenomeAnnotationDownloadSummaryByPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GenomeAnnotationDownloadSummaryByPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AnnotationReportFacetsByPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V2GenomeAnnotationTableSummaryReply
}

// Status returns HTTPResponse.Status
func (r AnnotationReportFacetsByPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AnnotationReportFacetsByPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GenomeDatasetReportsByAssemblyNameResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V2reportsAssemblyDataReportPage
}

// Status returns HTTPResponse.Status
func (r GenomeDatasetReportsByAssemblyNameResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GenomeDatasetReportsByAssemblyNameResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GenomeDatasetReportsByBioprojectResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V2reportsAssemblyDataReportPage
}

// Status returns HTTPResponse.Status
func (r GenomeDatasetReportsByBioprojectResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GenomeDatasetReportsByBioprojectResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GenomeDatasetReportsByBiosampleIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V2reportsAssemblyDataReportPage
}

// Status returns HTTPResponse.Status
func (r GenomeDatasetReportsByBiosampleIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GenomeDatasetReportsByBiosampleIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CheckAssemblyAvailabilityPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V2AssemblyDatasetAvailability
}

// Status returns HTTPResponse.Status
func (r CheckAssemblyAvailabilityPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CheckAssemblyAvailabilityPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CheckmHistogramByTaxonByPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V2AssemblyCheckMHistogramReply
}

// Status returns HTTPResponse.Status
func (r CheckmHistogramByTaxonByPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CheckmHistogramByTaxonByPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GenomeDatasetReportByPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V2reportsAssemblyDataReportPage
}

// Status returns HTTPResponse.Status
func (r GenomeDatasetReportByPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GenomeDatasetReportByPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DownloadAssemblyPackagePostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DownloadAssemblyPackagePostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DownloadAssemblyPackagePostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GenomeDownloadSummaryByPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V2DownloadSummary
}

// Status returns HTTPResponse.Status
func (r GenomeDownloadSummaryByPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GenomeDownloadSummaryByPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GenomeLinksByAccessionByPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V2AssemblyLinksReply
}

// Status returns HTTPResponse.Status
func (r GenomeLinksByAccessionByPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GenomeLinksByAccessionByPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AssemblyRevisionHistoryByPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V2AssemblyRevisionHistory
}

// Status returns HTTPResponse.Status
func (r AssemblyRevisionHistoryByPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AssemblyRevisionHistoryByPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AssemblyAccessionsForSequenceAccessionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V2AssemblyAccessions
}

// Status returns HTTPResponse.Status
func (r AssemblyAccessionsForSequenceAccessionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AssemblyAccessionsForSequenceAccessionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AssemblyAccessionsForSequenceAccessionByPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V2AssemblyAccessions
}

// Status returns HTTPResponse.Status
func (r AssemblyAccessionsForSequenceAccessionByPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AssemblyAccessionsForSequenceAccessionByPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GenomeSequenceReportByPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V2SequenceReportPage
}

// Status returns HTTPResponse.Status
func (r GenomeSequenceReportByPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GenomeSequenceReportByPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CheckmHistogramByTaxonResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V2AssemblyCheckMHistogramReply
}

// Status returns HTTPResponse.Status
func (r CheckmHistogramByTaxonResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CheckmHistogramByTaxonResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GenomeDatasetReportsByTaxonResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V2reportsAssemblyDataReportPage
}

// Status returns HTTPResponse.Status
func (r GenomeDatasetReportsByTaxonResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GenomeDatasetReportsByTaxonResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GenomeDatasetReportsByWgsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V2reportsAssemblyDataReportPage
}

// Status returns HTTPResponse.Status
func (r GenomeDatasetReportsByWgsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GenomeDatasetReportsByWgsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DownloadOrganellePackageResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DownloadOrganellePackageResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DownloadOrganellePackageResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type OrganelleDatareportByAccessionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V2reportsOrganelleDataReports
}

// Status returns HTTPResponse.Status
func (r OrganelleDatareportByAccessionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r OrganelleDatareportByAccessionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type OrganelleDatareportByPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V2reportsOrganelleDataReports
}

// Status returns HTTPResponse.Status
func (r OrganelleDatareportByPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r OrganelleDatareportByPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DownloadOrganellePackageByPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DownloadOrganellePackageByPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DownloadOrganellePackageByPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type OrganelleDatareportByTaxonResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V2reportsOrganelleDataReports
}

// Status returns HTTPResponse.Status
func (r OrganelleDatareportByTaxonResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r OrganelleDatareportByTaxonResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DownloadProkaryoteGenePackagePostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DownloadProkaryoteGenePackagePostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DownloadProkaryoteGenePackagePostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DownloadProkaryoteGenePackageResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DownloadProkaryoteGenePackageResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DownloadProkaryoteGenePackageResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TaxonomyMetadataPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V2TaxonomyMetadataResponse
}

// Status returns HTTPResponse.Status
func (r TaxonomyMetadataPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TaxonomyMetadataPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TaxonomyDataReportPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V2reportsTaxonomyDataReportPage
}

// Status returns HTTPResponse.Status
func (r TaxonomyDataReportPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TaxonomyDataReportPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DownloadTaxonomyPackageByPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DownloadTaxonomyPackageByPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DownloadTaxonomyPackageByPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TaxonomyFilteredSubtreePostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V2TaxonomyFilteredSubtreeResponse
}

// Status returns HTTPResponse.Status
func (r TaxonomyFilteredSubtreePostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TaxonomyFilteredSubtreePostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TaxonomyImagePostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r TaxonomyImagePostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TaxonomyImagePostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TaxonomyImageMetadataPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V2TaxonomyImageMetadataResponse
}

// Status returns HTTPResponse.Status
func (r TaxonomyImageMetadataPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TaxonomyImageMetadataPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TaxonomyLinksByPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V2TaxonomyLinksResponse
}

// Status returns HTTPResponse.Status
func (r TaxonomyLinksByPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TaxonomyLinksByPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TaxonomyNamesPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V2reportsTaxonomyNamesDataReportPage
}

// Status returns HTTPResponse.Status
func (r TaxonomyNamesPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TaxonomyNamesPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TaxonomyRelatedIdsPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V2TaxonomyTaxIdsPage
}

// Status returns HTTPResponse.Status
func (r TaxonomyRelatedIdsPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TaxonomyRelatedIdsPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DownloadTaxonomyPackageResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DownloadTaxonomyPackageResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DownloadTaxonomyPackageResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TaxonomyRelatedIdsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V2TaxonomyTaxIdsPage
}

// Status returns HTTPResponse.Status
func (r TaxonomyRelatedIdsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TaxonomyRelatedIdsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TaxonomyMetadataResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V2TaxonomyMetadataResponse
}

// Status returns HTTPResponse.Status
func (r TaxonomyMetadataResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TaxonomyMetadataResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TaxonomyDataReportResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V2reportsTaxonomyDataReportPage
}

// Status returns HTTPResponse.Status
func (r TaxonomyDataReportResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TaxonomyDataReportResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TaxonomyFilteredSubtreeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V2TaxonomyFilteredSubtreeResponse
}

// Status returns HTTPResponse.Status
func (r TaxonomyFilteredSubtreeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TaxonomyFilteredSubtreeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TaxonomyNamesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V2reportsTaxonomyNamesDataReportPage
}

// Status returns HTTPResponse.Status
func (r TaxonomyNamesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TaxonomyNamesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TaxonomyImageResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r TaxonomyImageResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TaxonomyImageResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TaxonomyImageMetadataResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V2TaxonomyImageMetadataResponse
}

// Status returns HTTPResponse.Status
func (r TaxonomyImageMetadataResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TaxonomyImageMetadataResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TaxonomyLinksResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V2TaxonomyLinksResponse
}

// Status returns HTTPResponse.Status
func (r TaxonomyLinksResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TaxonomyLinksResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TaxNameQueryByPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V2SciNameAndIds
}

// Status returns HTTPResponse.Status
func (r TaxNameQueryByPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TaxNameQueryByPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TaxNameQueryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V2SciNameAndIds
}

// Status returns HTTPResponse.Status
func (r TaxNameQueryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TaxNameQueryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type VersionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V2VersionReply
}

// Status returns HTTPResponse.Status
func (r VersionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r VersionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type VirusReportsByPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V2reportsVirusDataReportPage
}

// Status returns HTTPResponse.Status
func (r VirusReportsByPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r VirusReportsByPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type VirusAnnotationReportsByAcessionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V2reportsVirusAnnotationReportPage
}

// Status returns HTTPResponse.Status
func (r VirusAnnotationReportsByAcessionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r VirusAnnotationReportsByAcessionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type VirusAccessionAvailabilityResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V2VirusAvailability
}

// Status returns HTTPResponse.Status
func (r VirusAccessionAvailabilityResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r VirusAccessionAvailabilityResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type VirusReportsByAcessionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V2reportsVirusDataReportPage
}

// Status returns HTTPResponse.Status
func (r VirusReportsByAcessionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r VirusReportsByAcessionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type VirusGenomeDownloadAccessionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r VirusGenomeDownloadAccessionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r VirusGenomeDownloadAccessionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type VirusAnnotationReportsByPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V2reportsVirusAnnotationReportPage
}

// Status returns HTTPResponse.Status
func (r VirusAnnotationReportsByPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r VirusAnnotationReportsByPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type VirusAccessionAvailabilityPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V2VirusAvailability
}

// Status returns HTTPResponse.Status
func (r VirusAccessionAvailabilityPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r VirusAccessionAvailabilityPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type VirusGenomeSummaryByPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V2DownloadSummary
}

// Status returns HTTPResponse.Status
func (r VirusGenomeSummaryByPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r VirusGenomeSummaryByPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type VirusGenomeDownloadPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r VirusGenomeDownloadPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r VirusGenomeDownloadPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type Sars2ProteinSummaryByPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V2DownloadSummary
}

// Status returns HTTPResponse.Status
func (r Sars2ProteinSummaryByPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r Sars2ProteinSummaryByPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type Sars2ProteinDownloadPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r Sars2ProteinDownloadPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r Sars2ProteinDownloadPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type Sars2ProteinSummaryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V2DownloadSummary
}

// Status returns HTTPResponse.Status
func (r Sars2ProteinSummaryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r Sars2ProteinSummaryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type Sars2ProteinDownloadResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r Sars2ProteinDownloadResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r Sars2ProteinDownloadResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type Sars2ProteinTableResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V2TabularOutput
}

// Status returns HTTPResponse.Status
func (r Sars2ProteinTableResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r Sars2ProteinTableResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type VirusAnnotationReportsByTaxonResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V2reportsVirusAnnotationReportPage
}

// Status returns HTTPResponse.Status
func (r VirusAnnotationReportsByTaxonResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r VirusAnnotationReportsByTaxonResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type VirusReportsByTaxonResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V2reportsVirusDataReportPage
}

// Status returns HTTPResponse.Status
func (r VirusReportsByTaxonResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r VirusReportsByTaxonResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type VirusGenomeSummaryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V2DownloadSummary
}

// Status returns HTTPResponse.Status
func (r VirusGenomeSummaryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r VirusGenomeSummaryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type VirusGenomeDownloadResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r VirusGenomeDownloadResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r VirusGenomeDownloadResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type VirusGenomeTableResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V2TabularOutput
}

// Status returns HTTPResponse.Status
func (r VirusGenomeTableResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r VirusGenomeTableResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// BioSampleDatasetReportWithResponse request returning *BioSampleDatasetReportResponse
func (c *ClientWithResponses) BioSampleDatasetReportWithResponse(ctx context.Context, accessions []string, reqEditors ...RequestEditorFn) (*BioSampleDatasetReportResponse, error) {
	rsp, err := c.BioSampleDatasetReport(ctx, accessions, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseBioSampleDatasetReportResponse(rsp)
}

// GeneMetadataByPostWithBodyWithResponse request with arbitrary body returning *GeneMetadataByPostResponse
func (c *ClientWithResponses) GeneMetadataByPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GeneMetadataByPostResponse, error) {
	rsp, err := c.GeneMetadataByPostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGeneMetadataByPostResponse(rsp)
}

func (c *ClientWithResponses) GeneMetadataByPostWithResponse(ctx context.Context, body GeneMetadataByPostJSONRequestBody, reqEditors ...RequestEditorFn) (*GeneMetadataByPostResponse, error) {
	rsp, err := c.GeneMetadataByPost(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGeneMetadataByPostResponse(rsp)
}

// GeneMetadataByAccessionWithResponse request returning *GeneMetadataByAccessionResponse
func (c *ClientWithResponses) GeneMetadataByAccessionWithResponse(ctx context.Context, accessions []string, params *GeneMetadataByAccessionParams, reqEditors ...RequestEditorFn) (*GeneMetadataByAccessionResponse, error) {
	rsp, err := c.GeneMetadataByAccession(ctx, accessions, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGeneMetadataByAccessionResponse(rsp)
}

// DownloadGenePackagePostWithBodyWithResponse request with arbitrary body returning *DownloadGenePackagePostResponse
func (c *ClientWithResponses) DownloadGenePackagePostWithBodyWithResponse(ctx context.Context, params *DownloadGenePackagePostParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DownloadGenePackagePostResponse, error) {
	rsp, err := c.DownloadGenePackagePostWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDownloadGenePackagePostResponse(rsp)
}

func (c *ClientWithResponses) DownloadGenePackagePostWithResponse(ctx context.Context, params *DownloadGenePackagePostParams, body DownloadGenePackagePostJSONRequestBody, reqEditors ...RequestEditorFn) (*DownloadGenePackagePostResponse, error) {
	rsp, err := c.DownloadGenePackagePost(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDownloadGenePackagePostResponse(rsp)
}

// GeneDownloadSummaryByPostWithBodyWithResponse request with arbitrary body returning *GeneDownloadSummaryByPostResponse
func (c *ClientWithResponses) GeneDownloadSummaryByPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GeneDownloadSummaryByPostResponse, error) {
	rsp, err := c.GeneDownloadSummaryByPostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGeneDownloadSummaryByPostResponse(rsp)
}

func (c *ClientWithResponses) GeneDownloadSummaryByPostWithResponse(ctx context.Context, body GeneDownloadSummaryByPostJSONRequestBody, reqEditors ...RequestEditorFn) (*GeneDownloadSummaryByPostResponse, error) {
	rsp, err := c.GeneDownloadSummaryByPost(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGeneDownloadSummaryByPostResponse(rsp)
}

// GeneReportsByIdWithResponse request returning *GeneReportsByIdResponse
func (c *ClientWithResponses) GeneReportsByIdWithResponse(ctx context.Context, geneIds []int, params *GeneReportsByIdParams, reqEditors ...RequestEditorFn) (*GeneReportsByIdResponse, error) {
	rsp, err := c.GeneReportsById(ctx, geneIds, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGeneReportsByIdResponse(rsp)
}

// DownloadGenePackageWithResponse request returning *DownloadGenePackageResponse
func (c *ClientWithResponses) DownloadGenePackageWithResponse(ctx context.Context, geneIds []int, params *DownloadGenePackageParams, reqEditors ...RequestEditorFn) (*DownloadGenePackageResponse, error) {
	rsp, err := c.DownloadGenePackage(ctx, geneIds, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDownloadGenePackageResponse(rsp)
}

// GeneDownloadSummaryByIdWithResponse request returning *GeneDownloadSummaryByIdResponse
func (c *ClientWithResponses) GeneDownloadSummaryByIdWithResponse(ctx context.Context, geneIds []int, params *GeneDownloadSummaryByIdParams, reqEditors ...RequestEditorFn) (*GeneDownloadSummaryByIdResponse, error) {
	rsp, err := c.GeneDownloadSummaryById(ctx, geneIds, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGeneDownloadSummaryByIdResponse(rsp)
}

// GeneLinksByIdWithResponse request returning *GeneLinksByIdResponse
func (c *ClientWithResponses) GeneLinksByIdWithResponse(ctx context.Context, geneIds []int, reqEditors ...RequestEditorFn) (*GeneLinksByIdResponse, error) {
	rsp, err := c.GeneLinksById(ctx, geneIds, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGeneLinksByIdResponse(rsp)
}

// GeneOrthologsByIdWithResponse request returning *GeneOrthologsByIdResponse
func (c *ClientWithResponses) GeneOrthologsByIdWithResponse(ctx context.Context, geneId int, params *GeneOrthologsByIdParams, reqEditors ...RequestEditorFn) (*GeneOrthologsByIdResponse, error) {
	rsp, err := c.GeneOrthologsById(ctx, geneId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGeneOrthologsByIdResponse(rsp)
}

// GeneLinksByIdByPostWithBodyWithResponse request with arbitrary body returning *GeneLinksByIdByPostResponse
func (c *ClientWithResponses) GeneLinksByIdByPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GeneLinksByIdByPostResponse, error) {
	rsp, err := c.GeneLinksByIdByPostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGeneLinksByIdByPostResponse(rsp)
}

func (c *ClientWithResponses) GeneLinksByIdByPostWithResponse(ctx context.Context, body GeneLinksByIdByPostJSONRequestBody, reqEditors ...RequestEditorFn) (*GeneLinksByIdByPostResponse, error) {
	rsp, err := c.GeneLinksByIdByPost(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGeneLinksByIdByPostResponse(rsp)
}

// GeneOrthologsByPostWithBodyWithResponse request with arbitrary body returning *GeneOrthologsByPostResponse
func (c *ClientWithResponses) GeneOrthologsByPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GeneOrthologsByPostResponse, error) {
	rsp, err := c.GeneOrthologsByPostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGeneOrthologsByPostResponse(rsp)
}

func (c *ClientWithResponses) GeneOrthologsByPostWithResponse(ctx context.Context, body GeneOrthologsByPostJSONRequestBody, reqEditors ...RequestEditorFn) (*GeneOrthologsByPostResponse, error) {
	rsp, err := c.GeneOrthologsByPost(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGeneOrthologsByPostResponse(rsp)
}

// GeneMetadataByTaxAndSymbolWithResponse request returning *GeneMetadataByTaxAndSymbolResponse
func (c *ClientWithResponses) GeneMetadataByTaxAndSymbolWithResponse(ctx context.Context, symbols []string, taxon string, params *GeneMetadataByTaxAndSymbolParams, reqEditors ...RequestEditorFn) (*GeneMetadataByTaxAndSymbolResponse, error) {
	rsp, err := c.GeneMetadataByTaxAndSymbol(ctx, symbols, taxon, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGeneMetadataByTaxAndSymbolResponse(rsp)
}

// GeneCountsForTaxonByPostWithBodyWithResponse request with arbitrary body returning *GeneCountsForTaxonByPostResponse
func (c *ClientWithResponses) GeneCountsForTaxonByPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GeneCountsForTaxonByPostResponse, error) {
	rsp, err := c.GeneCountsForTaxonByPostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGeneCountsForTaxonByPostResponse(rsp)
}

func (c *ClientWithResponses) GeneCountsForTaxonByPostWithResponse(ctx context.Context, body GeneCountsForTaxonByPostJSONRequestBody, reqEditors ...RequestEditorFn) (*GeneCountsForTaxonByPostResponse, error) {
	rsp, err := c.GeneCountsForTaxonByPost(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGeneCountsForTaxonByPostResponse(rsp)
}

// GeneReportsByTaxonWithResponse request returning *GeneReportsByTaxonResponse
func (c *ClientWithResponses) GeneReportsByTaxonWithResponse(ctx context.Context, taxon string, params *GeneReportsByTaxonParams, reqEditors ...RequestEditorFn) (*GeneReportsByTaxonResponse, error) {
	rsp, err := c.GeneReportsByTaxon(ctx, taxon, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGeneReportsByTaxonResponse(rsp)
}

// GeneChromosomeSummaryWithResponse request returning *GeneChromosomeSummaryResponse
func (c *ClientWithResponses) GeneChromosomeSummaryWithResponse(ctx context.Context, taxon string, annotationName string, reqEditors ...RequestEditorFn) (*GeneChromosomeSummaryResponse, error) {
	rsp, err := c.GeneChromosomeSummary(ctx, taxon, annotationName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGeneChromosomeSummaryResponse(rsp)
}

// GeneCountsForTaxonWithResponse request returning *GeneCountsForTaxonResponse
func (c *ClientWithResponses) GeneCountsForTaxonWithResponse(ctx context.Context, taxon string, reqEditors ...RequestEditorFn) (*GeneCountsForTaxonResponse, error) {
	rsp, err := c.GeneCountsForTaxon(ctx, taxon, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGeneCountsForTaxonResponse(rsp)
}

// CheckAssemblyAvailabilityWithResponse request returning *CheckAssemblyAvailabilityResponse
func (c *ClientWithResponses) CheckAssemblyAvailabilityWithResponse(ctx context.Context, accessions []string, params *CheckAssemblyAvailabilityParams, reqEditors ...RequestEditorFn) (*CheckAssemblyAvailabilityResponse, error) {
	rsp, err := c.CheckAssemblyAvailability(ctx, accessions, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCheckAssemblyAvailabilityResponse(rsp)
}

// GenomeDatasetReportWithResponse request returning *GenomeDatasetReportResponse
func (c *ClientWithResponses) GenomeDatasetReportWithResponse(ctx context.Context, accessions []string, params *GenomeDatasetReportParams, reqEditors ...RequestEditorFn) (*GenomeDatasetReportResponse, error) {
	rsp, err := c.GenomeDatasetReport(ctx, accessions, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGenomeDatasetReportResponse(rsp)
}

// DownloadAssemblyPackageWithResponse request returning *DownloadAssemblyPackageResponse
func (c *ClientWithResponses) DownloadAssemblyPackageWithResponse(ctx context.Context, accessions []string, params *DownloadAssemblyPackageParams, reqEditors ...RequestEditorFn) (*DownloadAssemblyPackageResponse, error) {
	rsp, err := c.DownloadAssemblyPackage(ctx, accessions, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDownloadAssemblyPackageResponse(rsp)
}

// GenomeDownloadSummaryWithResponse request returning *GenomeDownloadSummaryResponse
func (c *ClientWithResponses) GenomeDownloadSummaryWithResponse(ctx context.Context, accessions []string, params *GenomeDownloadSummaryParams, reqEditors ...RequestEditorFn) (*GenomeDownloadSummaryResponse, error) {
	rsp, err := c.GenomeDownloadSummary(ctx, accessions, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGenomeDownloadSummaryResponse(rsp)
}

// GenomeLinksByAccessionWithResponse request returning *GenomeLinksByAccessionResponse
func (c *ClientWithResponses) GenomeLinksByAccessionWithResponse(ctx context.Context, accessions []string, reqEditors ...RequestEditorFn) (*GenomeLinksByAccessionResponse, error) {
	rsp, err := c.GenomeLinksByAccession(ctx, accessions, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGenomeLinksByAccessionResponse(rsp)
}

// GenomeAnnotationReportWithResponse request returning *GenomeAnnotationReportResponse
func (c *ClientWithResponses) GenomeAnnotationReportWithResponse(ctx context.Context, accession string, params *GenomeAnnotationReportParams, reqEditors ...RequestEditorFn) (*GenomeAnnotationReportResponse, error) {
	rsp, err := c.GenomeAnnotationReport(ctx, accession, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGenomeAnnotationReportResponse(rsp)
}

// DownloadGenomeAnnotationPackageWithResponse request returning *DownloadGenomeAnnotationPackageResponse
func (c *ClientWithResponses) DownloadGenomeAnnotationPackageWithResponse(ctx context.Context, accession string, params *DownloadGenomeAnnotationPackageParams, reqEditors ...RequestEditorFn) (*DownloadGenomeAnnotationPackageResponse, error) {
	rsp, err := c.DownloadGenomeAnnotationPackage(ctx, accession, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDownloadGenomeAnnotationPackageResponse(rsp)
}

// GenomeAnnotationDownloadSummaryWithResponse request returning *GenomeAnnotationDownloadSummaryResponse
func (c *ClientWithResponses) GenomeAnnotationDownloadSummaryWithResponse(ctx context.Context, accession string, params *GenomeAnnotationDownloadSummaryParams, reqEditors ...RequestEditorFn) (*GenomeAnnotationDownloadSummaryResponse, error) {
	rsp, err := c.GenomeAnnotationDownloadSummary(ctx, accession, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGenomeAnnotationDownloadSummaryResponse(rsp)
}

// AnnotationReportFacetsWithResponse request returning *AnnotationReportFacetsResponse
func (c *ClientWithResponses) AnnotationReportFacetsWithResponse(ctx context.Context, accession string, annotationIds []string, params *AnnotationReportFacetsParams, reqEditors ...RequestEditorFn) (*AnnotationReportFacetsResponse, error) {
	rsp, err := c.AnnotationReportFacets(ctx, accession, annotationIds, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAnnotationReportFacetsResponse(rsp)
}

// AssemblyRevisionHistoryByGetWithResponse request returning *AssemblyRevisionHistoryByGetResponse
func (c *ClientWithResponses) AssemblyRevisionHistoryByGetWithResponse(ctx context.Context, accession string, reqEditors ...RequestEditorFn) (*AssemblyRevisionHistoryByGetResponse, error) {
	rsp, err := c.AssemblyRevisionHistoryByGet(ctx, accession, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAssemblyRevisionHistoryByGetResponse(rsp)
}

// GenomeSequenceReportWithResponse request returning *GenomeSequenceReportResponse
func (c *ClientWithResponses) GenomeSequenceReportWithResponse(ctx context.Context, accession string, params *GenomeSequenceReportParams, reqEditors ...RequestEditorFn) (*GenomeSequenceReportResponse, error) {
	rsp, err := c.GenomeSequenceReport(ctx, accession, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGenomeSequenceReportResponse(rsp)
}

// GenomeAnnotationReportByPostWithBodyWithResponse request with arbitrary body returning *GenomeAnnotationReportByPostResponse
func (c *ClientWithResponses) GenomeAnnotationReportByPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GenomeAnnotationReportByPostResponse, error) {
	rsp, err := c.GenomeAnnotationReportByPostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGenomeAnnotationReportByPostResponse(rsp)
}

func (c *ClientWithResponses) GenomeAnnotationReportByPostWithResponse(ctx context.Context, body GenomeAnnotationReportByPostJSONRequestBody, reqEditors ...RequestEditorFn) (*GenomeAnnotationReportByPostResponse, error) {
	rsp, err := c.GenomeAnnotationReportByPost(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGenomeAnnotationReportByPostResponse(rsp)
}

// DownloadGenomeAnnotationPackageByPostWithBodyWithResponse request with arbitrary body returning *DownloadGenomeAnnotationPackageByPostResponse
func (c *ClientWithResponses) DownloadGenomeAnnotationPackageByPostWithBodyWithResponse(ctx context.Context, params *DownloadGenomeAnnotationPackageByPostParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DownloadGenomeAnnotationPackageByPostResponse, error) {
	rsp, err := c.DownloadGenomeAnnotationPackageByPostWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDownloadGenomeAnnotationPackageByPostResponse(rsp)
}

func (c *ClientWithResponses) DownloadGenomeAnnotationPackageByPostWithResponse(ctx context.Context, params *DownloadGenomeAnnotationPackageByPostParams, body DownloadGenomeAnnotationPackageByPostJSONRequestBody, reqEditors ...RequestEditorFn) (*DownloadGenomeAnnotationPackageByPostResponse, error) {
	rsp, err := c.DownloadGenomeAnnotationPackageByPost(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDownloadGenomeAnnotationPackageByPostResponse(rsp)
}

// GenomeAnnotationDownloadSummaryByPostWithBodyWithResponse request with arbitrary body returning *GenomeAnnotationDownloadSummaryByPostResponse
func (c *ClientWithResponses) GenomeAnnotationDownloadSummaryByPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GenomeAnnotationDownloadSummaryByPostResponse, error) {
	rsp, err := c.GenomeAnnotationDownloadSummaryByPostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGenomeAnnotationDownloadSummaryByPostResponse(rsp)
}

func (c *ClientWithResponses) GenomeAnnotationDownloadSummaryByPostWithResponse(ctx context.Context, body GenomeAnnotationDownloadSummaryByPostJSONRequestBody, reqEditors ...RequestEditorFn) (*GenomeAnnotationDownloadSummaryByPostResponse, error) {
	rsp, err := c.GenomeAnnotationDownloadSummaryByPost(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGenomeAnnotationDownloadSummaryByPostResponse(rsp)
}

// AnnotationReportFacetsByPostWithBodyWithResponse request with arbitrary body returning *AnnotationReportFacetsByPostResponse
func (c *ClientWithResponses) AnnotationReportFacetsByPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AnnotationReportFacetsByPostResponse, error) {
	rsp, err := c.AnnotationReportFacetsByPostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAnnotationReportFacetsByPostResponse(rsp)
}

func (c *ClientWithResponses) AnnotationReportFacetsByPostWithResponse(ctx context.Context, body AnnotationReportFacetsByPostJSONRequestBody, reqEditors ...RequestEditorFn) (*AnnotationReportFacetsByPostResponse, error) {
	rsp, err := c.AnnotationReportFacetsByPost(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAnnotationReportFacetsByPostResponse(rsp)
}

// GenomeDatasetReportsByAssemblyNameWithResponse request returning *GenomeDatasetReportsByAssemblyNameResponse
func (c *ClientWithResponses) GenomeDatasetReportsByAssemblyNameWithResponse(ctx context.Context, assemblyNames []string, params *GenomeDatasetReportsByAssemblyNameParams, reqEditors ...RequestEditorFn) (*GenomeDatasetReportsByAssemblyNameResponse, error) {
	rsp, err := c.GenomeDatasetReportsByAssemblyName(ctx, assemblyNames, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGenomeDatasetReportsByAssemblyNameResponse(rsp)
}

// GenomeDatasetReportsByBioprojectWithResponse request returning *GenomeDatasetReportsByBioprojectResponse
func (c *ClientWithResponses) GenomeDatasetReportsByBioprojectWithResponse(ctx context.Context, bioprojects []string, params *GenomeDatasetReportsByBioprojectParams, reqEditors ...RequestEditorFn) (*GenomeDatasetReportsByBioprojectResponse, error) {
	rsp, err := c.GenomeDatasetReportsByBioproject(ctx, bioprojects, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGenomeDatasetReportsByBioprojectResponse(rsp)
}

// GenomeDatasetReportsByBiosampleIdWithResponse request returning *GenomeDatasetReportsByBiosampleIdResponse
func (c *ClientWithResponses) GenomeDatasetReportsByBiosampleIdWithResponse(ctx context.Context, biosampleIds []string, params *GenomeDatasetReportsByBiosampleIdParams, reqEditors ...RequestEditorFn) (*GenomeDatasetReportsByBiosampleIdResponse, error) {
	rsp, err := c.GenomeDatasetReportsByBiosampleId(ctx, biosampleIds, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGenomeDatasetReportsByBiosampleIdResponse(rsp)
}

// CheckAssemblyAvailabilityPostWithBodyWithResponse request with arbitrary body returning *CheckAssemblyAvailabilityPostResponse
func (c *ClientWithResponses) CheckAssemblyAvailabilityPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CheckAssemblyAvailabilityPostResponse, error) {
	rsp, err := c.CheckAssemblyAvailabilityPostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCheckAssemblyAvailabilityPostResponse(rsp)
}

func (c *ClientWithResponses) CheckAssemblyAvailabilityPostWithResponse(ctx context.Context, body CheckAssemblyAvailabilityPostJSONRequestBody, reqEditors ...RequestEditorFn) (*CheckAssemblyAvailabilityPostResponse, error) {
	rsp, err := c.CheckAssemblyAvailabilityPost(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCheckAssemblyAvailabilityPostResponse(rsp)
}

// CheckmHistogramByTaxonByPostWithBodyWithResponse request with arbitrary body returning *CheckmHistogramByTaxonByPostResponse
func (c *ClientWithResponses) CheckmHistogramByTaxonByPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CheckmHistogramByTaxonByPostResponse, error) {
	rsp, err := c.CheckmHistogramByTaxonByPostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCheckmHistogramByTaxonByPostResponse(rsp)
}

func (c *ClientWithResponses) CheckmHistogramByTaxonByPostWithResponse(ctx context.Context, body CheckmHistogramByTaxonByPostJSONRequestBody, reqEditors ...RequestEditorFn) (*CheckmHistogramByTaxonByPostResponse, error) {
	rsp, err := c.CheckmHistogramByTaxonByPost(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCheckmHistogramByTaxonByPostResponse(rsp)
}

// GenomeDatasetReportByPostWithBodyWithResponse request with arbitrary body returning *GenomeDatasetReportByPostResponse
func (c *ClientWithResponses) GenomeDatasetReportByPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GenomeDatasetReportByPostResponse, error) {
	rsp, err := c.GenomeDatasetReportByPostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGenomeDatasetReportByPostResponse(rsp)
}

func (c *ClientWithResponses) GenomeDatasetReportByPostWithResponse(ctx context.Context, body GenomeDatasetReportByPostJSONRequestBody, reqEditors ...RequestEditorFn) (*GenomeDatasetReportByPostResponse, error) {
	rsp, err := c.GenomeDatasetReportByPost(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGenomeDatasetReportByPostResponse(rsp)
}

// DownloadAssemblyPackagePostWithBodyWithResponse request with arbitrary body returning *DownloadAssemblyPackagePostResponse
func (c *ClientWithResponses) DownloadAssemblyPackagePostWithBodyWithResponse(ctx context.Context, params *DownloadAssemblyPackagePostParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DownloadAssemblyPackagePostResponse, error) {
	rsp, err := c.DownloadAssemblyPackagePostWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDownloadAssemblyPackagePostResponse(rsp)
}

func (c *ClientWithResponses) DownloadAssemblyPackagePostWithResponse(ctx context.Context, params *DownloadAssemblyPackagePostParams, body DownloadAssemblyPackagePostJSONRequestBody, reqEditors ...RequestEditorFn) (*DownloadAssemblyPackagePostResponse, error) {
	rsp, err := c.DownloadAssemblyPackagePost(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDownloadAssemblyPackagePostResponse(rsp)
}

// GenomeDownloadSummaryByPostWithBodyWithResponse request with arbitrary body returning *GenomeDownloadSummaryByPostResponse
func (c *ClientWithResponses) GenomeDownloadSummaryByPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GenomeDownloadSummaryByPostResponse, error) {
	rsp, err := c.GenomeDownloadSummaryByPostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGenomeDownloadSummaryByPostResponse(rsp)
}

func (c *ClientWithResponses) GenomeDownloadSummaryByPostWithResponse(ctx context.Context, body GenomeDownloadSummaryByPostJSONRequestBody, reqEditors ...RequestEditorFn) (*GenomeDownloadSummaryByPostResponse, error) {
	rsp, err := c.GenomeDownloadSummaryByPost(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGenomeDownloadSummaryByPostResponse(rsp)
}

// GenomeLinksByAccessionByPostWithBodyWithResponse request with arbitrary body returning *GenomeLinksByAccessionByPostResponse
func (c *ClientWithResponses) GenomeLinksByAccessionByPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GenomeLinksByAccessionByPostResponse, error) {
	rsp, err := c.GenomeLinksByAccessionByPostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGenomeLinksByAccessionByPostResponse(rsp)
}

func (c *ClientWithResponses) GenomeLinksByAccessionByPostWithResponse(ctx context.Context, body GenomeLinksByAccessionByPostJSONRequestBody, reqEditors ...RequestEditorFn) (*GenomeLinksByAccessionByPostResponse, error) {
	rsp, err := c.GenomeLinksByAccessionByPost(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGenomeLinksByAccessionByPostResponse(rsp)
}

// AssemblyRevisionHistoryByPostWithBodyWithResponse request with arbitrary body returning *AssemblyRevisionHistoryByPostResponse
func (c *ClientWithResponses) AssemblyRevisionHistoryByPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AssemblyRevisionHistoryByPostResponse, error) {
	rsp, err := c.AssemblyRevisionHistoryByPostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAssemblyRevisionHistoryByPostResponse(rsp)
}

func (c *ClientWithResponses) AssemblyRevisionHistoryByPostWithResponse(ctx context.Context, body AssemblyRevisionHistoryByPostJSONRequestBody, reqEditors ...RequestEditorFn) (*AssemblyRevisionHistoryByPostResponse, error) {
	rsp, err := c.AssemblyRevisionHistoryByPost(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAssemblyRevisionHistoryByPostResponse(rsp)
}

// AssemblyAccessionsForSequenceAccessionWithResponse request returning *AssemblyAccessionsForSequenceAccessionResponse
func (c *ClientWithResponses) AssemblyAccessionsForSequenceAccessionWithResponse(ctx context.Context, accession string, reqEditors ...RequestEditorFn) (*AssemblyAccessionsForSequenceAccessionResponse, error) {
	rsp, err := c.AssemblyAccessionsForSequenceAccession(ctx, accession, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAssemblyAccessionsForSequenceAccessionResponse(rsp)
}

// AssemblyAccessionsForSequenceAccessionByPostWithBodyWithResponse request with arbitrary body returning *AssemblyAccessionsForSequenceAccessionByPostResponse
func (c *ClientWithResponses) AssemblyAccessionsForSequenceAccessionByPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AssemblyAccessionsForSequenceAccessionByPostResponse, error) {
	rsp, err := c.AssemblyAccessionsForSequenceAccessionByPostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAssemblyAccessionsForSequenceAccessionByPostResponse(rsp)
}

func (c *ClientWithResponses) AssemblyAccessionsForSequenceAccessionByPostWithResponse(ctx context.Context, body AssemblyAccessionsForSequenceAccessionByPostJSONRequestBody, reqEditors ...RequestEditorFn) (*AssemblyAccessionsForSequenceAccessionByPostResponse, error) {
	rsp, err := c.AssemblyAccessionsForSequenceAccessionByPost(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAssemblyAccessionsForSequenceAccessionByPostResponse(rsp)
}

// GenomeSequenceReportByPostWithBodyWithResponse request with arbitrary body returning *GenomeSequenceReportByPostResponse
func (c *ClientWithResponses) GenomeSequenceReportByPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GenomeSequenceReportByPostResponse, error) {
	rsp, err := c.GenomeSequenceReportByPostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGenomeSequenceReportByPostResponse(rsp)
}

func (c *ClientWithResponses) GenomeSequenceReportByPostWithResponse(ctx context.Context, body GenomeSequenceReportByPostJSONRequestBody, reqEditors ...RequestEditorFn) (*GenomeSequenceReportByPostResponse, error) {
	rsp, err := c.GenomeSequenceReportByPost(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGenomeSequenceReportByPostResponse(rsp)
}

// CheckmHistogramByTaxonWithResponse request returning *CheckmHistogramByTaxonResponse
func (c *ClientWithResponses) CheckmHistogramByTaxonWithResponse(ctx context.Context, speciesTaxon string, reqEditors ...RequestEditorFn) (*CheckmHistogramByTaxonResponse, error) {
	rsp, err := c.CheckmHistogramByTaxon(ctx, speciesTaxon, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCheckmHistogramByTaxonResponse(rsp)
}

// GenomeDatasetReportsByTaxonWithResponse request returning *GenomeDatasetReportsByTaxonResponse
func (c *ClientWithResponses) GenomeDatasetReportsByTaxonWithResponse(ctx context.Context, taxons []string, params *GenomeDatasetReportsByTaxonParams, reqEditors ...RequestEditorFn) (*GenomeDatasetReportsByTaxonResponse, error) {
	rsp, err := c.GenomeDatasetReportsByTaxon(ctx, taxons, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGenomeDatasetReportsByTaxonResponse(rsp)
}

// GenomeDatasetReportsByWgsWithResponse request returning *GenomeDatasetReportsByWgsResponse
func (c *ClientWithResponses) GenomeDatasetReportsByWgsWithResponse(ctx context.Context, wgsAccessions []string, params *GenomeDatasetReportsByWgsParams, reqEditors ...RequestEditorFn) (*GenomeDatasetReportsByWgsResponse, error) {
	rsp, err := c.GenomeDatasetReportsByWgs(ctx, wgsAccessions, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGenomeDatasetReportsByWgsResponse(rsp)
}

// DownloadOrganellePackageWithResponse request returning *DownloadOrganellePackageResponse
func (c *ClientWithResponses) DownloadOrganellePackageWithResponse(ctx context.Context, accessions []string, params *DownloadOrganellePackageParams, reqEditors ...RequestEditorFn) (*DownloadOrganellePackageResponse, error) {
	rsp, err := c.DownloadOrganellePackage(ctx, accessions, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDownloadOrganellePackageResponse(rsp)
}

// OrganelleDatareportByAccessionWithResponse request returning *OrganelleDatareportByAccessionResponse
func (c *ClientWithResponses) OrganelleDatareportByAccessionWithResponse(ctx context.Context, accessions []string, params *OrganelleDatareportByAccessionParams, reqEditors ...RequestEditorFn) (*OrganelleDatareportByAccessionResponse, error) {
	rsp, err := c.OrganelleDatareportByAccession(ctx, accessions, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseOrganelleDatareportByAccessionResponse(rsp)
}

// OrganelleDatareportByPostWithBodyWithResponse request with arbitrary body returning *OrganelleDatareportByPostResponse
func (c *ClientWithResponses) OrganelleDatareportByPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*OrganelleDatareportByPostResponse, error) {
	rsp, err := c.OrganelleDatareportByPostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseOrganelleDatareportByPostResponse(rsp)
}

func (c *ClientWithResponses) OrganelleDatareportByPostWithResponse(ctx context.Context, body OrganelleDatareportByPostJSONRequestBody, reqEditors ...RequestEditorFn) (*OrganelleDatareportByPostResponse, error) {
	rsp, err := c.OrganelleDatareportByPost(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseOrganelleDatareportByPostResponse(rsp)
}

// DownloadOrganellePackageByPostWithBodyWithResponse request with arbitrary body returning *DownloadOrganellePackageByPostResponse
func (c *ClientWithResponses) DownloadOrganellePackageByPostWithBodyWithResponse(ctx context.Context, params *DownloadOrganellePackageByPostParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DownloadOrganellePackageByPostResponse, error) {
	rsp, err := c.DownloadOrganellePackageByPostWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDownloadOrganellePackageByPostResponse(rsp)
}

func (c *ClientWithResponses) DownloadOrganellePackageByPostWithResponse(ctx context.Context, params *DownloadOrganellePackageByPostParams, body DownloadOrganellePackageByPostJSONRequestBody, reqEditors ...RequestEditorFn) (*DownloadOrganellePackageByPostResponse, error) {
	rsp, err := c.DownloadOrganellePackageByPost(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDownloadOrganellePackageByPostResponse(rsp)
}

// OrganelleDatareportByTaxonWithResponse request returning *OrganelleDatareportByTaxonResponse
func (c *ClientWithResponses) OrganelleDatareportByTaxonWithResponse(ctx context.Context, taxons []string, params *OrganelleDatareportByTaxonParams, reqEditors ...RequestEditorFn) (*OrganelleDatareportByTaxonResponse, error) {
	rsp, err := c.OrganelleDatareportByTaxon(ctx, taxons, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseOrganelleDatareportByTaxonResponse(rsp)
}

// DownloadProkaryoteGenePackagePostWithBodyWithResponse request with arbitrary body returning *DownloadProkaryoteGenePackagePostResponse
func (c *ClientWithResponses) DownloadProkaryoteGenePackagePostWithBodyWithResponse(ctx context.Context, params *DownloadProkaryoteGenePackagePostParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DownloadProkaryoteGenePackagePostResponse, error) {
	rsp, err := c.DownloadProkaryoteGenePackagePostWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDownloadProkaryoteGenePackagePostResponse(rsp)
}

func (c *ClientWithResponses) DownloadProkaryoteGenePackagePostWithResponse(ctx context.Context, params *DownloadProkaryoteGenePackagePostParams, body DownloadProkaryoteGenePackagePostJSONRequestBody, reqEditors ...RequestEditorFn) (*DownloadProkaryoteGenePackagePostResponse, error) {
	rsp, err := c.DownloadProkaryoteGenePackagePost(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDownloadProkaryoteGenePackagePostResponse(rsp)
}

// DownloadProkaryoteGenePackageWithResponse request returning *DownloadProkaryoteGenePackageResponse
func (c *ClientWithResponses) DownloadProkaryoteGenePackageWithResponse(ctx context.Context, accessions []string, params *DownloadProkaryoteGenePackageParams, reqEditors ...RequestEditorFn) (*DownloadProkaryoteGenePackageResponse, error) {
	rsp, err := c.DownloadProkaryoteGenePackage(ctx, accessions, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDownloadProkaryoteGenePackageResponse(rsp)
}

// TaxonomyMetadataPostWithBodyWithResponse request with arbitrary body returning *TaxonomyMetadataPostResponse
func (c *ClientWithResponses) TaxonomyMetadataPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TaxonomyMetadataPostResponse, error) {
	rsp, err := c.TaxonomyMetadataPostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTaxonomyMetadataPostResponse(rsp)
}

func (c *ClientWithResponses) TaxonomyMetadataPostWithResponse(ctx context.Context, body TaxonomyMetadataPostJSONRequestBody, reqEditors ...RequestEditorFn) (*TaxonomyMetadataPostResponse, error) {
	rsp, err := c.TaxonomyMetadataPost(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTaxonomyMetadataPostResponse(rsp)
}

// TaxonomyDataReportPostWithBodyWithResponse request with arbitrary body returning *TaxonomyDataReportPostResponse
func (c *ClientWithResponses) TaxonomyDataReportPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TaxonomyDataReportPostResponse, error) {
	rsp, err := c.TaxonomyDataReportPostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTaxonomyDataReportPostResponse(rsp)
}

func (c *ClientWithResponses) TaxonomyDataReportPostWithResponse(ctx context.Context, body TaxonomyDataReportPostJSONRequestBody, reqEditors ...RequestEditorFn) (*TaxonomyDataReportPostResponse, error) {
	rsp, err := c.TaxonomyDataReportPost(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTaxonomyDataReportPostResponse(rsp)
}

// DownloadTaxonomyPackageByPostWithBodyWithResponse request with arbitrary body returning *DownloadTaxonomyPackageByPostResponse
func (c *ClientWithResponses) DownloadTaxonomyPackageByPostWithBodyWithResponse(ctx context.Context, params *DownloadTaxonomyPackageByPostParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DownloadTaxonomyPackageByPostResponse, error) {
	rsp, err := c.DownloadTaxonomyPackageByPostWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDownloadTaxonomyPackageByPostResponse(rsp)
}

func (c *ClientWithResponses) DownloadTaxonomyPackageByPostWithResponse(ctx context.Context, params *DownloadTaxonomyPackageByPostParams, body DownloadTaxonomyPackageByPostJSONRequestBody, reqEditors ...RequestEditorFn) (*DownloadTaxonomyPackageByPostResponse, error) {
	rsp, err := c.DownloadTaxonomyPackageByPost(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDownloadTaxonomyPackageByPostResponse(rsp)
}

// TaxonomyFilteredSubtreePostWithBodyWithResponse request with arbitrary body returning *TaxonomyFilteredSubtreePostResponse
func (c *ClientWithResponses) TaxonomyFilteredSubtreePostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TaxonomyFilteredSubtreePostResponse, error) {
	rsp, err := c.TaxonomyFilteredSubtreePostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTaxonomyFilteredSubtreePostResponse(rsp)
}

func (c *ClientWithResponses) TaxonomyFilteredSubtreePostWithResponse(ctx context.Context, body TaxonomyFilteredSubtreePostJSONRequestBody, reqEditors ...RequestEditorFn) (*TaxonomyFilteredSubtreePostResponse, error) {
	rsp, err := c.TaxonomyFilteredSubtreePost(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTaxonomyFilteredSubtreePostResponse(rsp)
}

// TaxonomyImagePostWithBodyWithResponse request with arbitrary body returning *TaxonomyImagePostResponse
func (c *ClientWithResponses) TaxonomyImagePostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TaxonomyImagePostResponse, error) {
	rsp, err := c.TaxonomyImagePostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTaxonomyImagePostResponse(rsp)
}

func (c *ClientWithResponses) TaxonomyImagePostWithResponse(ctx context.Context, body TaxonomyImagePostJSONRequestBody, reqEditors ...RequestEditorFn) (*TaxonomyImagePostResponse, error) {
	rsp, err := c.TaxonomyImagePost(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTaxonomyImagePostResponse(rsp)
}

// TaxonomyImageMetadataPostWithBodyWithResponse request with arbitrary body returning *TaxonomyImageMetadataPostResponse
func (c *ClientWithResponses) TaxonomyImageMetadataPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TaxonomyImageMetadataPostResponse, error) {
	rsp, err := c.TaxonomyImageMetadataPostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTaxonomyImageMetadataPostResponse(rsp)
}

func (c *ClientWithResponses) TaxonomyImageMetadataPostWithResponse(ctx context.Context, body TaxonomyImageMetadataPostJSONRequestBody, reqEditors ...RequestEditorFn) (*TaxonomyImageMetadataPostResponse, error) {
	rsp, err := c.TaxonomyImageMetadataPost(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTaxonomyImageMetadataPostResponse(rsp)
}

// TaxonomyLinksByPostWithBodyWithResponse request with arbitrary body returning *TaxonomyLinksByPostResponse
func (c *ClientWithResponses) TaxonomyLinksByPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TaxonomyLinksByPostResponse, error) {
	rsp, err := c.TaxonomyLinksByPostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTaxonomyLinksByPostResponse(rsp)
}

func (c *ClientWithResponses) TaxonomyLinksByPostWithResponse(ctx context.Context, body TaxonomyLinksByPostJSONRequestBody, reqEditors ...RequestEditorFn) (*TaxonomyLinksByPostResponse, error) {
	rsp, err := c.TaxonomyLinksByPost(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTaxonomyLinksByPostResponse(rsp)
}

// TaxonomyNamesPostWithBodyWithResponse request with arbitrary body returning *TaxonomyNamesPostResponse
func (c *ClientWithResponses) TaxonomyNamesPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TaxonomyNamesPostResponse, error) {
	rsp, err := c.TaxonomyNamesPostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTaxonomyNamesPostResponse(rsp)
}

func (c *ClientWithResponses) TaxonomyNamesPostWithResponse(ctx context.Context, body TaxonomyNamesPostJSONRequestBody, reqEditors ...RequestEditorFn) (*TaxonomyNamesPostResponse, error) {
	rsp, err := c.TaxonomyNamesPost(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTaxonomyNamesPostResponse(rsp)
}

// TaxonomyRelatedIdsPostWithBodyWithResponse request with arbitrary body returning *TaxonomyRelatedIdsPostResponse
func (c *ClientWithResponses) TaxonomyRelatedIdsPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TaxonomyRelatedIdsPostResponse, error) {
	rsp, err := c.TaxonomyRelatedIdsPostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTaxonomyRelatedIdsPostResponse(rsp)
}

func (c *ClientWithResponses) TaxonomyRelatedIdsPostWithResponse(ctx context.Context, body TaxonomyRelatedIdsPostJSONRequestBody, reqEditors ...RequestEditorFn) (*TaxonomyRelatedIdsPostResponse, error) {
	rsp, err := c.TaxonomyRelatedIdsPost(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTaxonomyRelatedIdsPostResponse(rsp)
}

// DownloadTaxonomyPackageWithResponse request returning *DownloadTaxonomyPackageResponse
func (c *ClientWithResponses) DownloadTaxonomyPackageWithResponse(ctx context.Context, taxIds []int, params *DownloadTaxonomyPackageParams, reqEditors ...RequestEditorFn) (*DownloadTaxonomyPackageResponse, error) {
	rsp, err := c.DownloadTaxonomyPackage(ctx, taxIds, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDownloadTaxonomyPackageResponse(rsp)
}

// TaxonomyRelatedIdsWithResponse request returning *TaxonomyRelatedIdsResponse
func (c *ClientWithResponses) TaxonomyRelatedIdsWithResponse(ctx context.Context, taxId int, params *TaxonomyRelatedIdsParams, reqEditors ...RequestEditorFn) (*TaxonomyRelatedIdsResponse, error) {
	rsp, err := c.TaxonomyRelatedIds(ctx, taxId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTaxonomyRelatedIdsResponse(rsp)
}

// TaxonomyMetadataWithResponse request returning *TaxonomyMetadataResponse
func (c *ClientWithResponses) TaxonomyMetadataWithResponse(ctx context.Context, taxons []string, params *TaxonomyMetadataParams, reqEditors ...RequestEditorFn) (*TaxonomyMetadataResponse, error) {
	rsp, err := c.TaxonomyMetadata(ctx, taxons, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTaxonomyMetadataResponse(rsp)
}

// TaxonomyDataReportWithResponse request returning *TaxonomyDataReportResponse
func (c *ClientWithResponses) TaxonomyDataReportWithResponse(ctx context.Context, taxons []string, params *TaxonomyDataReportParams, reqEditors ...RequestEditorFn) (*TaxonomyDataReportResponse, error) {
	rsp, err := c.TaxonomyDataReport(ctx, taxons, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTaxonomyDataReportResponse(rsp)
}

// TaxonomyFilteredSubtreeWithResponse request returning *TaxonomyFilteredSubtreeResponse
func (c *ClientWithResponses) TaxonomyFilteredSubtreeWithResponse(ctx context.Context, taxons []string, params *TaxonomyFilteredSubtreeParams, reqEditors ...RequestEditorFn) (*TaxonomyFilteredSubtreeResponse, error) {
	rsp, err := c.TaxonomyFilteredSubtree(ctx, taxons, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTaxonomyFilteredSubtreeResponse(rsp)
}

// TaxonomyNamesWithResponse request returning *TaxonomyNamesResponse
func (c *ClientWithResponses) TaxonomyNamesWithResponse(ctx context.Context, taxons []string, params *TaxonomyNamesParams, reqEditors ...RequestEditorFn) (*TaxonomyNamesResponse, error) {
	rsp, err := c.TaxonomyNames(ctx, taxons, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTaxonomyNamesResponse(rsp)
}

// TaxonomyImageWithResponse request returning *TaxonomyImageResponse
func (c *ClientWithResponses) TaxonomyImageWithResponse(ctx context.Context, taxon string, params *TaxonomyImageParams, reqEditors ...RequestEditorFn) (*TaxonomyImageResponse, error) {
	rsp, err := c.TaxonomyImage(ctx, taxon, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTaxonomyImageResponse(rsp)
}

// TaxonomyImageMetadataWithResponse request returning *TaxonomyImageMetadataResponse
func (c *ClientWithResponses) TaxonomyImageMetadataWithResponse(ctx context.Context, taxon string, reqEditors ...RequestEditorFn) (*TaxonomyImageMetadataResponse, error) {
	rsp, err := c.TaxonomyImageMetadata(ctx, taxon, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTaxonomyImageMetadataResponse(rsp)
}

// TaxonomyLinksWithResponse request returning *TaxonomyLinksResponse
func (c *ClientWithResponses) TaxonomyLinksWithResponse(ctx context.Context, taxon string, reqEditors ...RequestEditorFn) (*TaxonomyLinksResponse, error) {
	rsp, err := c.TaxonomyLinks(ctx, taxon, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTaxonomyLinksResponse(rsp)
}

// TaxNameQueryByPostWithBodyWithResponse request with arbitrary body returning *TaxNameQueryByPostResponse
func (c *ClientWithResponses) TaxNameQueryByPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TaxNameQueryByPostResponse, error) {
	rsp, err := c.TaxNameQueryByPostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTaxNameQueryByPostResponse(rsp)
}

func (c *ClientWithResponses) TaxNameQueryByPostWithResponse(ctx context.Context, body TaxNameQueryByPostJSONRequestBody, reqEditors ...RequestEditorFn) (*TaxNameQueryByPostResponse, error) {
	rsp, err := c.TaxNameQueryByPost(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTaxNameQueryByPostResponse(rsp)
}

// TaxNameQueryWithResponse request returning *TaxNameQueryResponse
func (c *ClientWithResponses) TaxNameQueryWithResponse(ctx context.Context, taxonQuery string, params *TaxNameQueryParams, reqEditors ...RequestEditorFn) (*TaxNameQueryResponse, error) {
	rsp, err := c.TaxNameQuery(ctx, taxonQuery, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTaxNameQueryResponse(rsp)
}

// VersionWithResponse request returning *VersionResponse
func (c *ClientWithResponses) VersionWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*VersionResponse, error) {
	rsp, err := c.Version(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseVersionResponse(rsp)
}

// VirusReportsByPostWithBodyWithResponse request with arbitrary body returning *VirusReportsByPostResponse
func (c *ClientWithResponses) VirusReportsByPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*VirusReportsByPostResponse, error) {
	rsp, err := c.VirusReportsByPostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseVirusReportsByPostResponse(rsp)
}

func (c *ClientWithResponses) VirusReportsByPostWithResponse(ctx context.Context, body VirusReportsByPostJSONRequestBody, reqEditors ...RequestEditorFn) (*VirusReportsByPostResponse, error) {
	rsp, err := c.VirusReportsByPost(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseVirusReportsByPostResponse(rsp)
}

// VirusAnnotationReportsByAcessionsWithResponse request returning *VirusAnnotationReportsByAcessionsResponse
func (c *ClientWithResponses) VirusAnnotationReportsByAcessionsWithResponse(ctx context.Context, accessions []string, params *VirusAnnotationReportsByAcessionsParams, reqEditors ...RequestEditorFn) (*VirusAnnotationReportsByAcessionsResponse, error) {
	rsp, err := c.VirusAnnotationReportsByAcessions(ctx, accessions, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseVirusAnnotationReportsByAcessionsResponse(rsp)
}

// VirusAccessionAvailabilityWithResponse request returning *VirusAccessionAvailabilityResponse
func (c *ClientWithResponses) VirusAccessionAvailabilityWithResponse(ctx context.Context, accessions []string, reqEditors ...RequestEditorFn) (*VirusAccessionAvailabilityResponse, error) {
	rsp, err := c.VirusAccessionAvailability(ctx, accessions, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseVirusAccessionAvailabilityResponse(rsp)
}

// VirusReportsByAcessionsWithResponse request returning *VirusReportsByAcessionsResponse
func (c *ClientWithResponses) VirusReportsByAcessionsWithResponse(ctx context.Context, accessions []string, params *VirusReportsByAcessionsParams, reqEditors ...RequestEditorFn) (*VirusReportsByAcessionsResponse, error) {
	rsp, err := c.VirusReportsByAcessions(ctx, accessions, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseVirusReportsByAcessionsResponse(rsp)
}

// VirusGenomeDownloadAccessionWithResponse request returning *VirusGenomeDownloadAccessionResponse
func (c *ClientWithResponses) VirusGenomeDownloadAccessionWithResponse(ctx context.Context, accessions []string, params *VirusGenomeDownloadAccessionParams, reqEditors ...RequestEditorFn) (*VirusGenomeDownloadAccessionResponse, error) {
	rsp, err := c.VirusGenomeDownloadAccession(ctx, accessions, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseVirusGenomeDownloadAccessionResponse(rsp)
}

// VirusAnnotationReportsByPostWithBodyWithResponse request with arbitrary body returning *VirusAnnotationReportsByPostResponse
func (c *ClientWithResponses) VirusAnnotationReportsByPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*VirusAnnotationReportsByPostResponse, error) {
	rsp, err := c.VirusAnnotationReportsByPostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseVirusAnnotationReportsByPostResponse(rsp)
}

func (c *ClientWithResponses) VirusAnnotationReportsByPostWithResponse(ctx context.Context, body VirusAnnotationReportsByPostJSONRequestBody, reqEditors ...RequestEditorFn) (*VirusAnnotationReportsByPostResponse, error) {
	rsp, err := c.VirusAnnotationReportsByPost(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseVirusAnnotationReportsByPostResponse(rsp)
}

// VirusAccessionAvailabilityPostWithBodyWithResponse request with arbitrary body returning *VirusAccessionAvailabilityPostResponse
func (c *ClientWithResponses) VirusAccessionAvailabilityPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*VirusAccessionAvailabilityPostResponse, error) {
	rsp, err := c.VirusAccessionAvailabilityPostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseVirusAccessionAvailabilityPostResponse(rsp)
}

func (c *ClientWithResponses) VirusAccessionAvailabilityPostWithResponse(ctx context.Context, body VirusAccessionAvailabilityPostJSONRequestBody, reqEditors ...RequestEditorFn) (*VirusAccessionAvailabilityPostResponse, error) {
	rsp, err := c.VirusAccessionAvailabilityPost(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseVirusAccessionAvailabilityPostResponse(rsp)
}

// VirusGenomeSummaryByPostWithBodyWithResponse request with arbitrary body returning *VirusGenomeSummaryByPostResponse
func (c *ClientWithResponses) VirusGenomeSummaryByPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*VirusGenomeSummaryByPostResponse, error) {
	rsp, err := c.VirusGenomeSummaryByPostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseVirusGenomeSummaryByPostResponse(rsp)
}

func (c *ClientWithResponses) VirusGenomeSummaryByPostWithResponse(ctx context.Context, body VirusGenomeSummaryByPostJSONRequestBody, reqEditors ...RequestEditorFn) (*VirusGenomeSummaryByPostResponse, error) {
	rsp, err := c.VirusGenomeSummaryByPost(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseVirusGenomeSummaryByPostResponse(rsp)
}

// VirusGenomeDownloadPostWithBodyWithResponse request with arbitrary body returning *VirusGenomeDownloadPostResponse
func (c *ClientWithResponses) VirusGenomeDownloadPostWithBodyWithResponse(ctx context.Context, params *VirusGenomeDownloadPostParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*VirusGenomeDownloadPostResponse, error) {
	rsp, err := c.VirusGenomeDownloadPostWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseVirusGenomeDownloadPostResponse(rsp)
}

func (c *ClientWithResponses) VirusGenomeDownloadPostWithResponse(ctx context.Context, params *VirusGenomeDownloadPostParams, body VirusGenomeDownloadPostJSONRequestBody, reqEditors ...RequestEditorFn) (*VirusGenomeDownloadPostResponse, error) {
	rsp, err := c.VirusGenomeDownloadPost(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseVirusGenomeDownloadPostResponse(rsp)
}

// Sars2ProteinSummaryByPostWithBodyWithResponse request with arbitrary body returning *Sars2ProteinSummaryByPostResponse
func (c *ClientWithResponses) Sars2ProteinSummaryByPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*Sars2ProteinSummaryByPostResponse, error) {
	rsp, err := c.Sars2ProteinSummaryByPostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSars2ProteinSummaryByPostResponse(rsp)
}

func (c *ClientWithResponses) Sars2ProteinSummaryByPostWithResponse(ctx context.Context, body Sars2ProteinSummaryByPostJSONRequestBody, reqEditors ...RequestEditorFn) (*Sars2ProteinSummaryByPostResponse, error) {
	rsp, err := c.Sars2ProteinSummaryByPost(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSars2ProteinSummaryByPostResponse(rsp)
}

// Sars2ProteinDownloadPostWithBodyWithResponse request with arbitrary body returning *Sars2ProteinDownloadPostResponse
func (c *ClientWithResponses) Sars2ProteinDownloadPostWithBodyWithResponse(ctx context.Context, params *Sars2ProteinDownloadPostParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*Sars2ProteinDownloadPostResponse, error) {
	rsp, err := c.Sars2ProteinDownloadPostWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSars2ProteinDownloadPostResponse(rsp)
}

func (c *ClientWithResponses) Sars2ProteinDownloadPostWithResponse(ctx context.Context, params *Sars2ProteinDownloadPostParams, body Sars2ProteinDownloadPostJSONRequestBody, reqEditors ...RequestEditorFn) (*Sars2ProteinDownloadPostResponse, error) {
	rsp, err := c.Sars2ProteinDownloadPost(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSars2ProteinDownloadPostResponse(rsp)
}

// Sars2ProteinSummaryWithResponse request returning *Sars2ProteinSummaryResponse
func (c *ClientWithResponses) Sars2ProteinSummaryWithResponse(ctx context.Context, proteins []string, params *Sars2ProteinSummaryParams, reqEditors ...RequestEditorFn) (*Sars2ProteinSummaryResponse, error) {
	rsp, err := c.Sars2ProteinSummary(ctx, proteins, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSars2ProteinSummaryResponse(rsp)
}

// Sars2ProteinDownloadWithResponse request returning *Sars2ProteinDownloadResponse
func (c *ClientWithResponses) Sars2ProteinDownloadWithResponse(ctx context.Context, proteins []string, params *Sars2ProteinDownloadParams, reqEditors ...RequestEditorFn) (*Sars2ProteinDownloadResponse, error) {
	rsp, err := c.Sars2ProteinDownload(ctx, proteins, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSars2ProteinDownloadResponse(rsp)
}

// Sars2ProteinTableWithResponse request returning *Sars2ProteinTableResponse
func (c *ClientWithResponses) Sars2ProteinTableWithResponse(ctx context.Context, proteins []string, params *Sars2ProteinTableParams, reqEditors ...RequestEditorFn) (*Sars2ProteinTableResponse, error) {
	rsp, err := c.Sars2ProteinTable(ctx, proteins, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSars2ProteinTableResponse(rsp)
}

// VirusAnnotationReportsByTaxonWithResponse request returning *VirusAnnotationReportsByTaxonResponse
func (c *ClientWithResponses) VirusAnnotationReportsByTaxonWithResponse(ctx context.Context, taxon string, params *VirusAnnotationReportsByTaxonParams, reqEditors ...RequestEditorFn) (*VirusAnnotationReportsByTaxonResponse, error) {
	rsp, err := c.VirusAnnotationReportsByTaxon(ctx, taxon, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseVirusAnnotationReportsByTaxonResponse(rsp)
}

// VirusReportsByTaxonWithResponse request returning *VirusReportsByTaxonResponse
func (c *ClientWithResponses) VirusReportsByTaxonWithResponse(ctx context.Context, taxon string, params *VirusReportsByTaxonParams, reqEditors ...RequestEditorFn) (*VirusReportsByTaxonResponse, error) {
	rsp, err := c.VirusReportsByTaxon(ctx, taxon, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseVirusReportsByTaxonResponse(rsp)
}

// VirusGenomeSummaryWithResponse request returning *VirusGenomeSummaryResponse
func (c *ClientWithResponses) VirusGenomeSummaryWithResponse(ctx context.Context, taxon string, params *VirusGenomeSummaryParams, reqEditors ...RequestEditorFn) (*VirusGenomeSummaryResponse, error) {
	rsp, err := c.VirusGenomeSummary(ctx, taxon, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseVirusGenomeSummaryResponse(rsp)
}

// VirusGenomeDownloadWithResponse request returning *VirusGenomeDownloadResponse
func (c *ClientWithResponses) VirusGenomeDownloadWithResponse(ctx context.Context, taxon string, params *VirusGenomeDownloadParams, reqEditors ...RequestEditorFn) (*VirusGenomeDownloadResponse, error) {
	rsp, err := c.VirusGenomeDownload(ctx, taxon, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseVirusGenomeDownloadResponse(rsp)
}

// VirusGenomeTableWithResponse request returning *VirusGenomeTableResponse
func (c *ClientWithResponses) VirusGenomeTableWithResponse(ctx context.Context, taxon string, params *VirusGenomeTableParams, reqEditors ...RequestEditorFn) (*VirusGenomeTableResponse, error) {
	rsp, err := c.VirusGenomeTable(ctx, taxon, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseVirusGenomeTableResponse(rsp)
}

// ParseBioSampleDatasetReportResponse parses an HTTP response from a BioSampleDatasetReportWithResponse call
func ParseBioSampleDatasetReportResponse(rsp *http.Response) (*BioSampleDatasetReportResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &BioSampleDatasetReportResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V2reportsBioSampleDataReportPage
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case rsp.StatusCode == 200:
		// Content-type (text/tab-separated-values) unsupported

	}

	return response, nil
}

// ParseGeneMetadataByPostResponse parses an HTTP response from a GeneMetadataByPostWithResponse call
func ParseGeneMetadataByPostResponse(rsp *http.Response) (*GeneMetadataByPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GeneMetadataByPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V2reportsGeneDataReportPage
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case rsp.StatusCode == 200:
		// Content-type (text/tab-separated-values) unsupported

	}

	return response, nil
}

// ParseGeneMetadataByAccessionResponse parses an HTTP response from a GeneMetadataByAccessionWithResponse call
func ParseGeneMetadataByAccessionResponse(rsp *http.Response) (*GeneMetadataByAccessionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GeneMetadataByAccessionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V2reportsGeneDataReportPage
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case rsp.StatusCode == 200:
		// Content-type (text/tab-separated-values) unsupported

	}

	return response, nil
}

// ParseDownloadGenePackagePostResponse parses an HTTP response from a DownloadGenePackagePostWithResponse call
func ParseDownloadGenePackagePostResponse(rsp *http.Response) (*DownloadGenePackagePostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DownloadGenePackagePostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGeneDownloadSummaryByPostResponse parses an HTTP response from a GeneDownloadSummaryByPostWithResponse call
func ParseGeneDownloadSummaryByPostResponse(rsp *http.Response) (*GeneDownloadSummaryByPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GeneDownloadSummaryByPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V2DownloadSummary
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGeneReportsByIdResponse parses an HTTP response from a GeneReportsByIdWithResponse call
func ParseGeneReportsByIdResponse(rsp *http.Response) (*GeneReportsByIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GeneReportsByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V2reportsGeneDataReportPage
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case rsp.StatusCode == 200:
		// Content-type (text/tab-separated-values) unsupported

	}

	return response, nil
}

// ParseDownloadGenePackageResponse parses an HTTP response from a DownloadGenePackageWithResponse call
func ParseDownloadGenePackageResponse(rsp *http.Response) (*DownloadGenePackageResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DownloadGenePackageResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGeneDownloadSummaryByIdResponse parses an HTTP response from a GeneDownloadSummaryByIdWithResponse call
func ParseGeneDownloadSummaryByIdResponse(rsp *http.Response) (*GeneDownloadSummaryByIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GeneDownloadSummaryByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V2DownloadSummary
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGeneLinksByIdResponse parses an HTTP response from a GeneLinksByIdWithResponse call
func ParseGeneLinksByIdResponse(rsp *http.Response) (*GeneLinksByIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GeneLinksByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V2GeneLinksReply
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGeneOrthologsByIdResponse parses an HTTP response from a GeneOrthologsByIdWithResponse call
func ParseGeneOrthologsByIdResponse(rsp *http.Response) (*GeneOrthologsByIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GeneOrthologsByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V2reportsGeneDataReportPage
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGeneLinksByIdByPostResponse parses an HTTP response from a GeneLinksByIdByPostWithResponse call
func ParseGeneLinksByIdByPostResponse(rsp *http.Response) (*GeneLinksByIdByPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GeneLinksByIdByPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V2GeneLinksReply
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGeneOrthologsByPostResponse parses an HTTP response from a GeneOrthologsByPostWithResponse call
func ParseGeneOrthologsByPostResponse(rsp *http.Response) (*GeneOrthologsByPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GeneOrthologsByPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V2reportsGeneDataReportPage
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGeneMetadataByTaxAndSymbolResponse parses an HTTP response from a GeneMetadataByTaxAndSymbolWithResponse call
func ParseGeneMetadataByTaxAndSymbolResponse(rsp *http.Response) (*GeneMetadataByTaxAndSymbolResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GeneMetadataByTaxAndSymbolResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V2reportsGeneDataReportPage
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case rsp.StatusCode == 200:
		// Content-type (text/tab-separated-values) unsupported

	}

	return response, nil
}

// ParseGeneCountsForTaxonByPostResponse parses an HTTP response from a GeneCountsForTaxonByPostWithResponse call
func ParseGeneCountsForTaxonByPostResponse(rsp *http.Response) (*GeneCountsForTaxonByPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GeneCountsForTaxonByPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V2GeneCountsByTaxonReply
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGeneReportsByTaxonResponse parses an HTTP response from a GeneReportsByTaxonWithResponse call
func ParseGeneReportsByTaxonResponse(rsp *http.Response) (*GeneReportsByTaxonResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GeneReportsByTaxonResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V2reportsGeneDataReportPage
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case rsp.StatusCode == 200:
		// Content-type (text/tab-separated-values) unsupported

	}

	return response, nil
}

// ParseGeneChromosomeSummaryResponse parses an HTTP response from a GeneChromosomeSummaryWithResponse call
func ParseGeneChromosomeSummaryResponse(rsp *http.Response) (*GeneChromosomeSummaryResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GeneChromosomeSummaryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V2GeneChromosomeSummaryReply
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGeneCountsForTaxonResponse parses an HTTP response from a GeneCountsForTaxonWithResponse call
func ParseGeneCountsForTaxonResponse(rsp *http.Response) (*GeneCountsForTaxonResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GeneCountsForTaxonResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V2GeneCountsByTaxonReply
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCheckAssemblyAvailabilityResponse parses an HTTP response from a CheckAssemblyAvailabilityWithResponse call
func ParseCheckAssemblyAvailabilityResponse(rsp *http.Response) (*CheckAssemblyAvailabilityResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CheckAssemblyAvailabilityResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V2AssemblyDatasetAvailability
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGenomeDatasetReportResponse parses an HTTP response from a GenomeDatasetReportWithResponse call
func ParseGenomeDatasetReportResponse(rsp *http.Response) (*GenomeDatasetReportResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GenomeDatasetReportResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V2reportsAssemblyDataReportPage
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case rsp.StatusCode == 200:
		// Content-type (text/tab-separated-values) unsupported

	}

	return response, nil
}

// ParseDownloadAssemblyPackageResponse parses an HTTP response from a DownloadAssemblyPackageWithResponse call
func ParseDownloadAssemblyPackageResponse(rsp *http.Response) (*DownloadAssemblyPackageResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DownloadAssemblyPackageResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGenomeDownloadSummaryResponse parses an HTTP response from a GenomeDownloadSummaryWithResponse call
func ParseGenomeDownloadSummaryResponse(rsp *http.Response) (*GenomeDownloadSummaryResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GenomeDownloadSummaryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V2DownloadSummary
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGenomeLinksByAccessionResponse parses an HTTP response from a GenomeLinksByAccessionWithResponse call
func ParseGenomeLinksByAccessionResponse(rsp *http.Response) (*GenomeLinksByAccessionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GenomeLinksByAccessionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V2AssemblyLinksReply
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGenomeAnnotationReportResponse parses an HTTP response from a GenomeAnnotationReportWithResponse call
func ParseGenomeAnnotationReportResponse(rsp *http.Response) (*GenomeAnnotationReportResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GenomeAnnotationReportResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V2reportsGenomeAnnotationReportPage
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case rsp.StatusCode == 200:
		// Content-type (text/tab-separated-values) unsupported

	}

	return response, nil
}

// ParseDownloadGenomeAnnotationPackageResponse parses an HTTP response from a DownloadGenomeAnnotationPackageWithResponse call
func ParseDownloadGenomeAnnotationPackageResponse(rsp *http.Response) (*DownloadGenomeAnnotationPackageResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DownloadGenomeAnnotationPackageResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGenomeAnnotationDownloadSummaryResponse parses an HTTP response from a GenomeAnnotationDownloadSummaryWithResponse call
func ParseGenomeAnnotationDownloadSummaryResponse(rsp *http.Response) (*GenomeAnnotationDownloadSummaryResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GenomeAnnotationDownloadSummaryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V2DownloadSummary
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseAnnotationReportFacetsResponse parses an HTTP response from a AnnotationReportFacetsWithResponse call
func ParseAnnotationReportFacetsResponse(rsp *http.Response) (*AnnotationReportFacetsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AnnotationReportFacetsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V2GenomeAnnotationTableSummaryReply
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseAssemblyRevisionHistoryByGetResponse parses an HTTP response from a AssemblyRevisionHistoryByGetWithResponse call
func ParseAssemblyRevisionHistoryByGetResponse(rsp *http.Response) (*AssemblyRevisionHistoryByGetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AssemblyRevisionHistoryByGetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V2AssemblyRevisionHistory
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGenomeSequenceReportResponse parses an HTTP response from a GenomeSequenceReportWithResponse call
func ParseGenomeSequenceReportResponse(rsp *http.Response) (*GenomeSequenceReportResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GenomeSequenceReportResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V2SequenceReportPage
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case rsp.StatusCode == 200:
		// Content-type (text/tab-separated-values) unsupported

	}

	return response, nil
}

// ParseGenomeAnnotationReportByPostResponse parses an HTTP response from a GenomeAnnotationReportByPostWithResponse call
func ParseGenomeAnnotationReportByPostResponse(rsp *http.Response) (*GenomeAnnotationReportByPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GenomeAnnotationReportByPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V2reportsGenomeAnnotationReportPage
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case rsp.StatusCode == 200:
		// Content-type (text/tab-separated-values) unsupported

	}

	return response, nil
}

// ParseDownloadGenomeAnnotationPackageByPostResponse parses an HTTP response from a DownloadGenomeAnnotationPackageByPostWithResponse call
func ParseDownloadGenomeAnnotationPackageByPostResponse(rsp *http.Response) (*DownloadGenomeAnnotationPackageByPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DownloadGenomeAnnotationPackageByPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGenomeAnnotationDownloadSummaryByPostResponse parses an HTTP response from a GenomeAnnotationDownloadSummaryByPostWithResponse call
func ParseGenomeAnnotationDownloadSummaryByPostResponse(rsp *http.Response) (*GenomeAnnotationDownloadSummaryByPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GenomeAnnotationDownloadSummaryByPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V2DownloadSummary
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseAnnotationReportFacetsByPostResponse parses an HTTP response from a AnnotationReportFacetsByPostWithResponse call
func ParseAnnotationReportFacetsByPostResponse(rsp *http.Response) (*AnnotationReportFacetsByPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AnnotationReportFacetsByPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V2GenomeAnnotationTableSummaryReply
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGenomeDatasetReportsByAssemblyNameResponse parses an HTTP response from a GenomeDatasetReportsByAssemblyNameWithResponse call
func ParseGenomeDatasetReportsByAssemblyNameResponse(rsp *http.Response) (*GenomeDatasetReportsByAssemblyNameResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GenomeDatasetReportsByAssemblyNameResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V2reportsAssemblyDataReportPage
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case rsp.StatusCode == 200:
		// Content-type (text/tab-separated-values) unsupported

	}

	return response, nil
}

// ParseGenomeDatasetReportsByBioprojectResponse parses an HTTP response from a GenomeDatasetReportsByBioprojectWithResponse call
func ParseGenomeDatasetReportsByBioprojectResponse(rsp *http.Response) (*GenomeDatasetReportsByBioprojectResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GenomeDatasetReportsByBioprojectResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V2reportsAssemblyDataReportPage
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case rsp.StatusCode == 200:
		// Content-type (text/tab-separated-values) unsupported

	}

	return response, nil
}

// ParseGenomeDatasetReportsByBiosampleIdResponse parses an HTTP response from a GenomeDatasetReportsByBiosampleIdWithResponse call
func ParseGenomeDatasetReportsByBiosampleIdResponse(rsp *http.Response) (*GenomeDatasetReportsByBiosampleIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GenomeDatasetReportsByBiosampleIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V2reportsAssemblyDataReportPage
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case rsp.StatusCode == 200:
		// Content-type (text/tab-separated-values) unsupported

	}

	return response, nil
}

// ParseCheckAssemblyAvailabilityPostResponse parses an HTTP response from a CheckAssemblyAvailabilityPostWithResponse call
func ParseCheckAssemblyAvailabilityPostResponse(rsp *http.Response) (*CheckAssemblyAvailabilityPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CheckAssemblyAvailabilityPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V2AssemblyDatasetAvailability
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCheckmHistogramByTaxonByPostResponse parses an HTTP response from a CheckmHistogramByTaxonByPostWithResponse call
func ParseCheckmHistogramByTaxonByPostResponse(rsp *http.Response) (*CheckmHistogramByTaxonByPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CheckmHistogramByTaxonByPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V2AssemblyCheckMHistogramReply
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGenomeDatasetReportByPostResponse parses an HTTP response from a GenomeDatasetReportByPostWithResponse call
func ParseGenomeDatasetReportByPostResponse(rsp *http.Response) (*GenomeDatasetReportByPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GenomeDatasetReportByPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V2reportsAssemblyDataReportPage
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case rsp.StatusCode == 200:
		// Content-type (text/tab-separated-values) unsupported

	}

	return response, nil
}

// ParseDownloadAssemblyPackagePostResponse parses an HTTP response from a DownloadAssemblyPackagePostWithResponse call
func ParseDownloadAssemblyPackagePostResponse(rsp *http.Response) (*DownloadAssemblyPackagePostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DownloadAssemblyPackagePostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGenomeDownloadSummaryByPostResponse parses an HTTP response from a GenomeDownloadSummaryByPostWithResponse call
func ParseGenomeDownloadSummaryByPostResponse(rsp *http.Response) (*GenomeDownloadSummaryByPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GenomeDownloadSummaryByPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V2DownloadSummary
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGenomeLinksByAccessionByPostResponse parses an HTTP response from a GenomeLinksByAccessionByPostWithResponse call
func ParseGenomeLinksByAccessionByPostResponse(rsp *http.Response) (*GenomeLinksByAccessionByPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GenomeLinksByAccessionByPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V2AssemblyLinksReply
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseAssemblyRevisionHistoryByPostResponse parses an HTTP response from a AssemblyRevisionHistoryByPostWithResponse call
func ParseAssemblyRevisionHistoryByPostResponse(rsp *http.Response) (*AssemblyRevisionHistoryByPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AssemblyRevisionHistoryByPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V2AssemblyRevisionHistory
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseAssemblyAccessionsForSequenceAccessionResponse parses an HTTP response from a AssemblyAccessionsForSequenceAccessionWithResponse call
func ParseAssemblyAccessionsForSequenceAccessionResponse(rsp *http.Response) (*AssemblyAccessionsForSequenceAccessionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AssemblyAccessionsForSequenceAccessionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V2AssemblyAccessions
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseAssemblyAccessionsForSequenceAccessionByPostResponse parses an HTTP response from a AssemblyAccessionsForSequenceAccessionByPostWithResponse call
func ParseAssemblyAccessionsForSequenceAccessionByPostResponse(rsp *http.Response) (*AssemblyAccessionsForSequenceAccessionByPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AssemblyAccessionsForSequenceAccessionByPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V2AssemblyAccessions
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGenomeSequenceReportByPostResponse parses an HTTP response from a GenomeSequenceReportByPostWithResponse call
func ParseGenomeSequenceReportByPostResponse(rsp *http.Response) (*GenomeSequenceReportByPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GenomeSequenceReportByPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V2SequenceReportPage
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case rsp.StatusCode == 200:
		// Content-type (text/tab-separated-values) unsupported

	}

	return response, nil
}

// ParseCheckmHistogramByTaxonResponse parses an HTTP response from a CheckmHistogramByTaxonWithResponse call
func ParseCheckmHistogramByTaxonResponse(rsp *http.Response) (*CheckmHistogramByTaxonResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CheckmHistogramByTaxonResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V2AssemblyCheckMHistogramReply
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGenomeDatasetReportsByTaxonResponse parses an HTTP response from a GenomeDatasetReportsByTaxonWithResponse call
func ParseGenomeDatasetReportsByTaxonResponse(rsp *http.Response) (*GenomeDatasetReportsByTaxonResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GenomeDatasetReportsByTaxonResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V2reportsAssemblyDataReportPage
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case rsp.StatusCode == 200:
		// Content-type (text/tab-separated-values) unsupported

	}

	return response, nil
}

// ParseGenomeDatasetReportsByWgsResponse parses an HTTP response from a GenomeDatasetReportsByWgsWithResponse call
func ParseGenomeDatasetReportsByWgsResponse(rsp *http.Response) (*GenomeDatasetReportsByWgsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GenomeDatasetReportsByWgsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V2reportsAssemblyDataReportPage
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case rsp.StatusCode == 200:
		// Content-type (text/tab-separated-values) unsupported

	}

	return response, nil
}

// ParseDownloadOrganellePackageResponse parses an HTTP response from a DownloadOrganellePackageWithResponse call
func ParseDownloadOrganellePackageResponse(rsp *http.Response) (*DownloadOrganellePackageResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DownloadOrganellePackageResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseOrganelleDatareportByAccessionResponse parses an HTTP response from a OrganelleDatareportByAccessionWithResponse call
func ParseOrganelleDatareportByAccessionResponse(rsp *http.Response) (*OrganelleDatareportByAccessionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &OrganelleDatareportByAccessionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V2reportsOrganelleDataReports
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseOrganelleDatareportByPostResponse parses an HTTP response from a OrganelleDatareportByPostWithResponse call
func ParseOrganelleDatareportByPostResponse(rsp *http.Response) (*OrganelleDatareportByPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &OrganelleDatareportByPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V2reportsOrganelleDataReports
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDownloadOrganellePackageByPostResponse parses an HTTP response from a DownloadOrganellePackageByPostWithResponse call
func ParseDownloadOrganellePackageByPostResponse(rsp *http.Response) (*DownloadOrganellePackageByPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DownloadOrganellePackageByPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseOrganelleDatareportByTaxonResponse parses an HTTP response from a OrganelleDatareportByTaxonWithResponse call
func ParseOrganelleDatareportByTaxonResponse(rsp *http.Response) (*OrganelleDatareportByTaxonResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &OrganelleDatareportByTaxonResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V2reportsOrganelleDataReports
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDownloadProkaryoteGenePackagePostResponse parses an HTTP response from a DownloadProkaryoteGenePackagePostWithResponse call
func ParseDownloadProkaryoteGenePackagePostResponse(rsp *http.Response) (*DownloadProkaryoteGenePackagePostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DownloadProkaryoteGenePackagePostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseDownloadProkaryoteGenePackageResponse parses an HTTP response from a DownloadProkaryoteGenePackageWithResponse call
func ParseDownloadProkaryoteGenePackageResponse(rsp *http.Response) (*DownloadProkaryoteGenePackageResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DownloadProkaryoteGenePackageResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseTaxonomyMetadataPostResponse parses an HTTP response from a TaxonomyMetadataPostWithResponse call
func ParseTaxonomyMetadataPostResponse(rsp *http.Response) (*TaxonomyMetadataPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TaxonomyMetadataPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V2TaxonomyMetadataResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseTaxonomyDataReportPostResponse parses an HTTP response from a TaxonomyDataReportPostWithResponse call
func ParseTaxonomyDataReportPostResponse(rsp *http.Response) (*TaxonomyDataReportPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TaxonomyDataReportPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V2reportsTaxonomyDataReportPage
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case rsp.StatusCode == 200:
		// Content-type (text/tab-separated-values) unsupported

	}

	return response, nil
}

// ParseDownloadTaxonomyPackageByPostResponse parses an HTTP response from a DownloadTaxonomyPackageByPostWithResponse call
func ParseDownloadTaxonomyPackageByPostResponse(rsp *http.Response) (*DownloadTaxonomyPackageByPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DownloadTaxonomyPackageByPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseTaxonomyFilteredSubtreePostResponse parses an HTTP response from a TaxonomyFilteredSubtreePostWithResponse call
func ParseTaxonomyFilteredSubtreePostResponse(rsp *http.Response) (*TaxonomyFilteredSubtreePostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TaxonomyFilteredSubtreePostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V2TaxonomyFilteredSubtreeResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseTaxonomyImagePostResponse parses an HTTP response from a TaxonomyImagePostWithResponse call
func ParseTaxonomyImagePostResponse(rsp *http.Response) (*TaxonomyImagePostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TaxonomyImagePostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseTaxonomyImageMetadataPostResponse parses an HTTP response from a TaxonomyImageMetadataPostWithResponse call
func ParseTaxonomyImageMetadataPostResponse(rsp *http.Response) (*TaxonomyImageMetadataPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TaxonomyImageMetadataPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V2TaxonomyImageMetadataResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseTaxonomyLinksByPostResponse parses an HTTP response from a TaxonomyLinksByPostWithResponse call
func ParseTaxonomyLinksByPostResponse(rsp *http.Response) (*TaxonomyLinksByPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TaxonomyLinksByPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V2TaxonomyLinksResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseTaxonomyNamesPostResponse parses an HTTP response from a TaxonomyNamesPostWithResponse call
func ParseTaxonomyNamesPostResponse(rsp *http.Response) (*TaxonomyNamesPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TaxonomyNamesPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V2reportsTaxonomyNamesDataReportPage
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseTaxonomyRelatedIdsPostResponse parses an HTTP response from a TaxonomyRelatedIdsPostWithResponse call
func ParseTaxonomyRelatedIdsPostResponse(rsp *http.Response) (*TaxonomyRelatedIdsPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TaxonomyRelatedIdsPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V2TaxonomyTaxIdsPage
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDownloadTaxonomyPackageResponse parses an HTTP response from a DownloadTaxonomyPackageWithResponse call
func ParseDownloadTaxonomyPackageResponse(rsp *http.Response) (*DownloadTaxonomyPackageResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DownloadTaxonomyPackageResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseTaxonomyRelatedIdsResponse parses an HTTP response from a TaxonomyRelatedIdsWithResponse call
func ParseTaxonomyRelatedIdsResponse(rsp *http.Response) (*TaxonomyRelatedIdsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TaxonomyRelatedIdsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V2TaxonomyTaxIdsPage
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseTaxonomyMetadataResponse parses an HTTP response from a TaxonomyMetadataWithResponse call
func ParseTaxonomyMetadataResponse(rsp *http.Response) (*TaxonomyMetadataResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TaxonomyMetadataResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V2TaxonomyMetadataResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseTaxonomyDataReportResponse parses an HTTP response from a TaxonomyDataReportWithResponse call
func ParseTaxonomyDataReportResponse(rsp *http.Response) (*TaxonomyDataReportResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TaxonomyDataReportResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V2reportsTaxonomyDataReportPage
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case rsp.StatusCode == 200:
		// Content-type (text/tab-separated-values) unsupported

	}

	return response, nil
}

// ParseTaxonomyFilteredSubtreeResponse parses an HTTP response from a TaxonomyFilteredSubtreeWithResponse call
func ParseTaxonomyFilteredSubtreeResponse(rsp *http.Response) (*TaxonomyFilteredSubtreeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TaxonomyFilteredSubtreeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V2TaxonomyFilteredSubtreeResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseTaxonomyNamesResponse parses an HTTP response from a TaxonomyNamesWithResponse call
func ParseTaxonomyNamesResponse(rsp *http.Response) (*TaxonomyNamesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TaxonomyNamesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V2reportsTaxonomyNamesDataReportPage
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseTaxonomyImageResponse parses an HTTP response from a TaxonomyImageWithResponse call
func ParseTaxonomyImageResponse(rsp *http.Response) (*TaxonomyImageResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TaxonomyImageResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseTaxonomyImageMetadataResponse parses an HTTP response from a TaxonomyImageMetadataWithResponse call
func ParseTaxonomyImageMetadataResponse(rsp *http.Response) (*TaxonomyImageMetadataResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TaxonomyImageMetadataResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V2TaxonomyImageMetadataResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseTaxonomyLinksResponse parses an HTTP response from a TaxonomyLinksWithResponse call
func ParseTaxonomyLinksResponse(rsp *http.Response) (*TaxonomyLinksResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TaxonomyLinksResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V2TaxonomyLinksResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseTaxNameQueryByPostResponse parses an HTTP response from a TaxNameQueryByPostWithResponse call
func ParseTaxNameQueryByPostResponse(rsp *http.Response) (*TaxNameQueryByPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TaxNameQueryByPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V2SciNameAndIds
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseTaxNameQueryResponse parses an HTTP response from a TaxNameQueryWithResponse call
func ParseTaxNameQueryResponse(rsp *http.Response) (*TaxNameQueryResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TaxNameQueryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V2SciNameAndIds
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseVersionResponse parses an HTTP response from a VersionWithResponse call
func ParseVersionResponse(rsp *http.Response) (*VersionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &VersionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V2VersionReply
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseVirusReportsByPostResponse parses an HTTP response from a VirusReportsByPostWithResponse call
func ParseVirusReportsByPostResponse(rsp *http.Response) (*VirusReportsByPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &VirusReportsByPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V2reportsVirusDataReportPage
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case rsp.StatusCode == 200:
		// Content-type (text/tab-separated-values) unsupported

	}

	return response, nil
}

// ParseVirusAnnotationReportsByAcessionsResponse parses an HTTP response from a VirusAnnotationReportsByAcessionsWithResponse call
func ParseVirusAnnotationReportsByAcessionsResponse(rsp *http.Response) (*VirusAnnotationReportsByAcessionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &VirusAnnotationReportsByAcessionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V2reportsVirusAnnotationReportPage
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case rsp.StatusCode == 200:
		// Content-type (text/tab-separated-values) unsupported

	}

	return response, nil
}

// ParseVirusAccessionAvailabilityResponse parses an HTTP response from a VirusAccessionAvailabilityWithResponse call
func ParseVirusAccessionAvailabilityResponse(rsp *http.Response) (*VirusAccessionAvailabilityResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &VirusAccessionAvailabilityResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V2VirusAvailability
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseVirusReportsByAcessionsResponse parses an HTTP response from a VirusReportsByAcessionsWithResponse call
func ParseVirusReportsByAcessionsResponse(rsp *http.Response) (*VirusReportsByAcessionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &VirusReportsByAcessionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V2reportsVirusDataReportPage
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case rsp.StatusCode == 200:
		// Content-type (text/tab-separated-values) unsupported

	}

	return response, nil
}

// ParseVirusGenomeDownloadAccessionResponse parses an HTTP response from a VirusGenomeDownloadAccessionWithResponse call
func ParseVirusGenomeDownloadAccessionResponse(rsp *http.Response) (*VirusGenomeDownloadAccessionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &VirusGenomeDownloadAccessionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseVirusAnnotationReportsByPostResponse parses an HTTP response from a VirusAnnotationReportsByPostWithResponse call
func ParseVirusAnnotationReportsByPostResponse(rsp *http.Response) (*VirusAnnotationReportsByPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &VirusAnnotationReportsByPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V2reportsVirusAnnotationReportPage
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case rsp.StatusCode == 200:
		// Content-type (text/tab-separated-values) unsupported

	}

	return response, nil
}

// ParseVirusAccessionAvailabilityPostResponse parses an HTTP response from a VirusAccessionAvailabilityPostWithResponse call
func ParseVirusAccessionAvailabilityPostResponse(rsp *http.Response) (*VirusAccessionAvailabilityPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &VirusAccessionAvailabilityPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V2VirusAvailability
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseVirusGenomeSummaryByPostResponse parses an HTTP response from a VirusGenomeSummaryByPostWithResponse call
func ParseVirusGenomeSummaryByPostResponse(rsp *http.Response) (*VirusGenomeSummaryByPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &VirusGenomeSummaryByPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V2DownloadSummary
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseVirusGenomeDownloadPostResponse parses an HTTP response from a VirusGenomeDownloadPostWithResponse call
func ParseVirusGenomeDownloadPostResponse(rsp *http.Response) (*VirusGenomeDownloadPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &VirusGenomeDownloadPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseSars2ProteinSummaryByPostResponse parses an HTTP response from a Sars2ProteinSummaryByPostWithResponse call
func ParseSars2ProteinSummaryByPostResponse(rsp *http.Response) (*Sars2ProteinSummaryByPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &Sars2ProteinSummaryByPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V2DownloadSummary
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseSars2ProteinDownloadPostResponse parses an HTTP response from a Sars2ProteinDownloadPostWithResponse call
func ParseSars2ProteinDownloadPostResponse(rsp *http.Response) (*Sars2ProteinDownloadPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &Sars2ProteinDownloadPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseSars2ProteinSummaryResponse parses an HTTP response from a Sars2ProteinSummaryWithResponse call
func ParseSars2ProteinSummaryResponse(rsp *http.Response) (*Sars2ProteinSummaryResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &Sars2ProteinSummaryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V2DownloadSummary
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseSars2ProteinDownloadResponse parses an HTTP response from a Sars2ProteinDownloadWithResponse call
func ParseSars2ProteinDownloadResponse(rsp *http.Response) (*Sars2ProteinDownloadResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &Sars2ProteinDownloadResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseSars2ProteinTableResponse parses an HTTP response from a Sars2ProteinTableWithResponse call
func ParseSars2ProteinTableResponse(rsp *http.Response) (*Sars2ProteinTableResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &Sars2ProteinTableResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V2TabularOutput
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseVirusAnnotationReportsByTaxonResponse parses an HTTP response from a VirusAnnotationReportsByTaxonWithResponse call
func ParseVirusAnnotationReportsByTaxonResponse(rsp *http.Response) (*VirusAnnotationReportsByTaxonResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &VirusAnnotationReportsByTaxonResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V2reportsVirusAnnotationReportPage
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case rsp.StatusCode == 200:
		// Content-type (text/tab-separated-values) unsupported

	}

	return response, nil
}

// ParseVirusReportsByTaxonResponse parses an HTTP response from a VirusReportsByTaxonWithResponse call
func ParseVirusReportsByTaxonResponse(rsp *http.Response) (*VirusReportsByTaxonResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &VirusReportsByTaxonResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V2reportsVirusDataReportPage
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case rsp.StatusCode == 200:
		// Content-type (text/tab-separated-values) unsupported

	}

	return response, nil
}

// ParseVirusGenomeSummaryResponse parses an HTTP response from a VirusGenomeSummaryWithResponse call
func ParseVirusGenomeSummaryResponse(rsp *http.Response) (*VirusGenomeSummaryResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &VirusGenomeSummaryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V2DownloadSummary
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseVirusGenomeDownloadResponse parses an HTTP response from a VirusGenomeDownloadWithResponse call
func ParseVirusGenomeDownloadResponse(rsp *http.Response) (*VirusGenomeDownloadResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &VirusGenomeDownloadResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseVirusGenomeTableResponse parses an HTTP response from a VirusGenomeTableWithResponse call
func ParseVirusGenomeTableResponse(rsp *http.Response) (*VirusGenomeTableResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &VirusGenomeTableResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V2TabularOutput
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get BioSample dataset reports by accession(s)
	// (GET /biosample/accession/{accessions}/biosample_report)
	BioSampleDatasetReport(w http.ResponseWriter, r *http.Request, accessions []string)
	// Get gene metadata as JSON
	// (POST /gene)
	GeneMetadataByPost(w http.ResponseWriter, r *http.Request)
	// Get gene metadata by RefSeq Accession
	// (GET /gene/accession/{accessions})
	GeneMetadataByAccession(w http.ResponseWriter, r *http.Request, accessions []string, params GeneMetadataByAccessionParams)
	// Get a gene dataset by POST
	// (POST /gene/download)
	DownloadGenePackagePost(w http.ResponseWriter, r *http.Request, params DownloadGenePackagePostParams)
	// Get gene download summary
	// (POST /gene/download_summary)
	GeneDownloadSummaryByPost(w http.ResponseWriter, r *http.Request)
	// Get gene reports by GeneID
	// (GET /gene/id/{gene_ids})
	GeneReportsById(w http.ResponseWriter, r *http.Request, geneIds []int, params GeneReportsByIdParams)
	// Get a gene dataset by gene ID
	// (GET /gene/id/{gene_ids}/download)
	DownloadGenePackage(w http.ResponseWriter, r *http.Request, geneIds []int, params DownloadGenePackageParams)
	// Get gene download summary by GeneID
	// (GET /gene/id/{gene_ids}/download_summary)
	GeneDownloadSummaryById(w http.ResponseWriter, r *http.Request, geneIds []int, params GeneDownloadSummaryByIdParams)
	// Get gene links by gene ID
	// (GET /gene/id/{gene_ids}/links)
	GeneLinksById(w http.ResponseWriter, r *http.Request, geneIds []int)
	// Get gene orthologs by gene ID
	// (GET /gene/id/{gene_id}/orthologs)
	GeneOrthologsById(w http.ResponseWriter, r *http.Request, geneId int, params GeneOrthologsByIdParams)
	// Get gene links by gene ID
	// (POST /gene/links)
	GeneLinksByIdByPost(w http.ResponseWriter, r *http.Request)
	// Get gene orthologs by gene ID
	// (POST /gene/orthologs)
	GeneOrthologsByPost(w http.ResponseWriter, r *http.Request)
	// Get gene metadata by gene symbol
	// (GET /gene/symbol/{symbols}/taxon/{taxon})
	GeneMetadataByTaxAndSymbol(w http.ResponseWriter, r *http.Request, symbols []string, taxon string, params GeneMetadataByTaxAndSymbolParams)
	// Get gene counts by taxonomic identifier
	// (POST /gene/taxon/counts)
	GeneCountsForTaxonByPost(w http.ResponseWriter, r *http.Request)
	// Get gene reports by taxonomic identifier
	// (GET /gene/taxon/{taxon})
	GeneReportsByTaxon(w http.ResponseWriter, r *http.Request, taxon string, params GeneReportsByTaxonParams)
	// Get summary of chromosomes for a particular taxon's annotation
	// (GET /gene/taxon/{taxon}/annotation/{annotation_name}/chromosome_summary)
	GeneChromosomeSummary(w http.ResponseWriter, r *http.Request, taxon string, annotationName string)
	// Get gene counts by taxonomic identifier
	// (GET /gene/taxon/{taxon}/counts)
	GeneCountsForTaxon(w http.ResponseWriter, r *http.Request, taxon string)
	// Check the validity of genome accessions
	// (GET /genome/accession/{accessions}/check)
	CheckAssemblyAvailability(w http.ResponseWriter, r *http.Request, accessions []string, params CheckAssemblyAvailabilityParams)
	// Get dataset reports by accessions
	// (GET /genome/accession/{accessions}/dataset_report)
	GenomeDatasetReport(w http.ResponseWriter, r *http.Request, accessions []string, params GenomeDatasetReportParams)
	// Get a genome dataset by accession
	// (GET /genome/accession/{accessions}/download)
	DownloadAssemblyPackage(w http.ResponseWriter, r *http.Request, accessions []string, params DownloadAssemblyPackageParams)
	// Preview genome dataset download
	// (GET /genome/accession/{accessions}/download_summary)
	GenomeDownloadSummary(w http.ResponseWriter, r *http.Request, accessions []string, params GenomeDownloadSummaryParams)
	// Get assembly links by accessions
	// (GET /genome/accession/{accessions}/links)
	GenomeLinksByAccession(w http.ResponseWriter, r *http.Request, accessions []string)
	// Get genome annotation reports by genome accession
	// (GET /genome/accession/{accession}/annotation_report)
	GenomeAnnotationReport(w http.ResponseWriter, r *http.Request, accession string, params GenomeAnnotationReportParams)
	// Get an annotation report dataset by accession
	// (GET /genome/accession/{accession}/annotation_report/download)
	DownloadGenomeAnnotationPackage(w http.ResponseWriter, r *http.Request, accession string, params DownloadGenomeAnnotationPackageParams)
	// Preview feature dataset download
	// (GET /genome/accession/{accession}/annotation_report/download_summary)
	GenomeAnnotationDownloadSummary(w http.ResponseWriter, r *http.Request, accession string, params GenomeAnnotationDownloadSummaryParams)
	// Get genome annotation report summary information
	// (GET /genome/accession/{accession}/id/{annotation_ids}/annotation_summary)
	AnnotationReportFacets(w http.ResponseWriter, r *http.Request, accession string, annotationIds []string, params AnnotationReportFacetsParams)
	// Get revision history for assembly by accession
	// (GET /genome/accession/{accession}/revision_history)
	AssemblyRevisionHistoryByGet(w http.ResponseWriter, r *http.Request, accession string)
	// Get sequence reports by accessions
	// (GET /genome/accession/{accession}/sequence_reports)
	GenomeSequenceReport(w http.ResponseWriter, r *http.Request, accession string, params GenomeSequenceReportParams)
	// Get genome annotation reports by genome accession
	// (POST /genome/annotation_report)
	GenomeAnnotationReportByPost(w http.ResponseWriter, r *http.Request)
	// Get an annotation report dataset by accession
	// (POST /genome/annotation_report/download)
	DownloadGenomeAnnotationPackageByPost(w http.ResponseWriter, r *http.Request, params DownloadGenomeAnnotationPackageByPostParams)
	// Preview feature download by POST
	// (POST /genome/annotation_report/download_summary)
	GenomeAnnotationDownloadSummaryByPost(w http.ResponseWriter, r *http.Request)
	// Get genome annotation report summary information
	// (POST /genome/annotation_summary)
	AnnotationReportFacetsByPost(w http.ResponseWriter, r *http.Request)
	// Get dataset reports by assembly name (exact)
	// (GET /genome/assembly_name/{assembly_names}/dataset_report)
	GenomeDatasetReportsByAssemblyName(w http.ResponseWriter, r *http.Request, assemblyNames []string, params GenomeDatasetReportsByAssemblyNameParams)
	// Get dataset reports by bioproject
	// (GET /genome/bioproject/{bioprojects}/dataset_report)
	GenomeDatasetReportsByBioproject(w http.ResponseWriter, r *http.Request, bioprojects []string, params GenomeDatasetReportsByBioprojectParams)
	// Get dataset reports by biosample id
	// (GET /genome/biosample/{biosample_ids}/dataset_report)
	GenomeDatasetReportsByBiosampleId(w http.ResponseWriter, r *http.Request, biosampleIds []string, params GenomeDatasetReportsByBiosampleIdParams)
	// Check the validity of many genome accessions in a single request
	// (POST /genome/check)
	CheckAssemblyAvailabilityPost(w http.ResponseWriter, r *http.Request)
	// Get CheckM histogram by species taxon
	// (POST /genome/checkm_histogram)
	CheckmHistogramByTaxonByPost(w http.ResponseWriter, r *http.Request)
	// Get dataset reports by accessions
	// (POST /genome/dataset_report)
	GenomeDatasetReportByPost(w http.ResponseWriter, r *http.Request)
	// Get a genome dataset by post
	// (POST /genome/download)
	DownloadAssemblyPackagePost(w http.ResponseWriter, r *http.Request, params DownloadAssemblyPackagePostParams)
	// Preview genome dataset download by POST
	// (POST /genome/download_summary)
	GenomeDownloadSummaryByPost(w http.ResponseWriter, r *http.Request)
	// Get assembly links by accessions
	// (POST /genome/links)
	GenomeLinksByAccessionByPost(w http.ResponseWriter, r *http.Request)
	// Get revision history for assembly by accession
	// (POST /genome/revision_history)
	AssemblyRevisionHistoryByPost(w http.ResponseWriter, r *http.Request)
	// Get assembly accessions for a sequence accession
	// (GET /genome/sequence_accession/{accession}/sequence_assemblies)
	AssemblyAccessionsForSequenceAccession(w http.ResponseWriter, r *http.Request, accession string)
	// Get assembly accessions for a sequence accession
	// (POST /genome/sequence_assemblies)
	AssemblyAccessionsForSequenceAccessionByPost(w http.ResponseWriter, r *http.Request)
	// Get sequence reports by accessions
	// (POST /genome/sequence_reports)
	GenomeSequenceReportByPost(w http.ResponseWriter, r *http.Request)
	// Get CheckM histogram by species taxon
	// (GET /genome/taxon/{species_taxon}/checkm_histogram)
	CheckmHistogramByTaxon(w http.ResponseWriter, r *http.Request, speciesTaxon string)
	// Get dataset reports by taxons
	// (GET /genome/taxon/{taxons}/dataset_report)
	GenomeDatasetReportsByTaxon(w http.ResponseWriter, r *http.Request, taxons []string, params GenomeDatasetReportsByTaxonParams)
	// Get dataset reports by wgs accession
	// (GET /genome/wgs/{wgs_accessions}/dataset_report)
	GenomeDatasetReportsByWgs(w http.ResponseWriter, r *http.Request, wgsAccessions []string, params GenomeDatasetReportsByWgsParams)
	// Get a organelle data package by accesions
	// (GET /organelle/accession/{accessions}/download)
	DownloadOrganellePackage(w http.ResponseWriter, r *http.Request, accessions []string, params DownloadOrganellePackageParams)
	// Get Organelle dataset report by accession
	// (GET /organelle/accessions/{accessions}/dataset_report)
	OrganelleDatareportByAccession(w http.ResponseWriter, r *http.Request, accessions []string, params OrganelleDatareportByAccessionParams)
	// Get Organelle dataset report by http post
	// (POST /organelle/dataset_report)
	OrganelleDatareportByPost(w http.ResponseWriter, r *http.Request)
	// Get a organelle data package by post
	// (POST /organelle/download)
	DownloadOrganellePackageByPost(w http.ResponseWriter, r *http.Request, params DownloadOrganellePackageByPostParams)
	// Get Organelle dataset report by taxons
	// (GET /organelle/taxon/{taxons}/dataset_report)
	OrganelleDatareportByTaxon(w http.ResponseWriter, r *http.Request, taxons []string, params OrganelleDatareportByTaxonParams)
	// Get a prokaryote gene dataset by RefSeq protein accession by POST
	// (POST /protein/accession/download)
	DownloadProkaryoteGenePackagePost(w http.ResponseWriter, r *http.Request, params DownloadProkaryoteGenePackagePostParams)
	// Get a prokaryote gene dataset by RefSeq protein accession
	// (GET /protein/accession/{accessions}/download)
	DownloadProkaryoteGenePackage(w http.ResponseWriter, r *http.Request, accessions []string, params DownloadProkaryoteGenePackageParams)
	// Use taxonomic identifiers to get taxonomic metadata by post
	// (POST /taxonomy)
	TaxonomyMetadataPost(w http.ResponseWriter, r *http.Request)
	// Use taxonomic identifiers to get taxonomic names data report by post
	// (POST /taxonomy/dataset_report)
	TaxonomyDataReportPost(w http.ResponseWriter, r *http.Request)
	// Get a taxonomy data package by tax_id
	// (POST /taxonomy/download)
	DownloadTaxonomyPackageByPost(w http.ResponseWriter, r *http.Request, params DownloadTaxonomyPackageByPostParams)
	// Use taxonomic identifiers to get a filtered taxonomic subtree by post
	// (POST /taxonomy/filtered_subtree)
	TaxonomyFilteredSubtreePost(w http.ResponseWriter, r *http.Request)
	// Retrieve image associated with a taxonomic identifier by post
	// (POST /taxonomy/image)
	TaxonomyImagePost(w http.ResponseWriter, r *http.Request)
	// Retrieve image metadata associated with a taxonomic identifier by post
	// (POST /taxonomy/image/metadata)
	TaxonomyImageMetadataPost(w http.ResponseWriter, r *http.Request)
	// Retrieve external links associated with a taxonomic identifier.
	// (POST /taxonomy/links)
	TaxonomyLinksByPost(w http.ResponseWriter, r *http.Request)
	// Use taxonomic identifiers to get taxonomic names data report by post
	// (POST /taxonomy/name_report)
	TaxonomyNamesPost(w http.ResponseWriter, r *http.Request)
	// Use taxonomic identifier to get related taxonomic identifiers, such as children
	// (POST /taxonomy/related_ids)
	TaxonomyRelatedIdsPost(w http.ResponseWriter, r *http.Request)
	// Get a taxonomy data package by tax ID
	// (GET /taxonomy/taxon/{tax_ids}/download)
	DownloadTaxonomyPackage(w http.ResponseWriter, r *http.Request, taxIds []int, params DownloadTaxonomyPackageParams)
	// Use taxonomic identifier to get related taxonomic identifiers, such as children
	// (GET /taxonomy/taxon/{tax_id}/related_ids)
	TaxonomyRelatedIds(w http.ResponseWriter, r *http.Request, taxId int, params TaxonomyRelatedIdsParams)
	// Use taxonomic identifiers to get taxonomic metadata
	// (GET /taxonomy/taxon/{taxons})
	TaxonomyMetadata(w http.ResponseWriter, r *http.Request, taxons []string, params TaxonomyMetadataParams)
	// Use taxonomic identifiers to get taxonomic data report
	// (GET /taxonomy/taxon/{taxons}/dataset_report)
	TaxonomyDataReport(w http.ResponseWriter, r *http.Request, taxons []string, params TaxonomyDataReportParams)
	// Use taxonomic identifiers to get a filtered taxonomic subtree
	// (GET /taxonomy/taxon/{taxons}/filtered_subtree)
	TaxonomyFilteredSubtree(w http.ResponseWriter, r *http.Request, taxons []string, params TaxonomyFilteredSubtreeParams)
	// Use taxonomic identifiers to get taxonomic names data report
	// (GET /taxonomy/taxon/{taxons}/name_report)
	TaxonomyNames(w http.ResponseWriter, r *http.Request, taxons []string, params TaxonomyNamesParams)
	// Retrieve image associated with a taxonomic identifier
	// (GET /taxonomy/taxon/{taxon}/image)
	TaxonomyImage(w http.ResponseWriter, r *http.Request, taxon string, params TaxonomyImageParams)
	// Retrieve image metadata associated with a taxonomic identifier
	// (GET /taxonomy/taxon/{taxon}/image/metadata)
	TaxonomyImageMetadata(w http.ResponseWriter, r *http.Request, taxon string)
	// Retrieve external links associated with a taxonomic identifier.
	// (GET /taxonomy/taxon/{taxon}/links)
	TaxonomyLinks(w http.ResponseWriter, r *http.Request, taxon string)
	// Get a list of taxonomy names and IDs given a partial taxonomic name
	// (POST /taxonomy/taxon_suggest)
	TaxNameQueryByPost(w http.ResponseWriter, r *http.Request)
	// Get a list of taxonomy names and IDs given a partial taxonomic name
	// (GET /taxonomy/taxon_suggest/{taxon_query})
	TaxNameQuery(w http.ResponseWriter, r *http.Request, taxonQuery string, params TaxNameQueryParams)
	// Retrieve service version
	// (GET /version)
	Version(w http.ResponseWriter, r *http.Request)
	// Get virus metadata by POST
	// (POST /virus)
	VirusReportsByPost(w http.ResponseWriter, r *http.Request)
	// Get virus annotation report by accession
	// (GET /virus/accession/{accessions}/annotation_report)
	VirusAnnotationReportsByAcessions(w http.ResponseWriter, r *http.Request, accessions []string, params VirusAnnotationReportsByAcessionsParams)
	// Check available viruses by accession
	// (GET /virus/accession/{accessions}/check)
	VirusAccessionAvailability(w http.ResponseWriter, r *http.Request, accessions []string)
	// Get virus metadata by accession
	// (GET /virus/accession/{accessions}/dataset_report)
	VirusReportsByAcessions(w http.ResponseWriter, r *http.Request, accessions []string, params VirusReportsByAcessionsParams)
	// Download a virus genome dataset by accession
	// (GET /virus/accession/{accessions}/genome/download)
	VirusGenomeDownloadAccession(w http.ResponseWriter, r *http.Request, accessions []string, params VirusGenomeDownloadAccessionParams)
	// Get virus annotation report by POST
	// (POST /virus/annotation_report)
	VirusAnnotationReportsByPost(w http.ResponseWriter, r *http.Request)
	// Check available viruses by accession
	// (POST /virus/check)
	VirusAccessionAvailabilityPost(w http.ResponseWriter, r *http.Request)
	// Get summary data for virus genomes by post
	// (POST /virus/genome)
	VirusGenomeSummaryByPost(w http.ResponseWriter, r *http.Request)
	// Get a virus genome dataset by post
	// (POST /virus/genome/download)
	VirusGenomeDownloadPost(w http.ResponseWriter, r *http.Request, params VirusGenomeDownloadPostParams)
	// Summary of SARS-CoV-2 protein and CDS datasets by protein name
	// (POST /virus/taxon/sars2/protein)
	Sars2ProteinSummaryByPost(w http.ResponseWriter, r *http.Request)
	// Download SARS-CoV-2 protein and CDS datasets by protein name by POST request
	// (POST /virus/taxon/sars2/protein/download)
	Sars2ProteinDownloadPost(w http.ResponseWriter, r *http.Request, params Sars2ProteinDownloadPostParams)
	// Summary of SARS-CoV-2 protein and CDS datasets by protein name
	// (GET /virus/taxon/sars2/protein/{proteins})
	Sars2ProteinSummary(w http.ResponseWriter, r *http.Request, proteins []string, params Sars2ProteinSummaryParams)
	// Download SARS-CoV-2 protein and CDS datasets by protein name
	// (GET /virus/taxon/sars2/protein/{proteins}/download)
	Sars2ProteinDownload(w http.ResponseWriter, r *http.Request, proteins []string, params Sars2ProteinDownloadParams)
	// Get SARS-CoV-2 protein metadata in a tabular format.
	// (GET /virus/taxon/sars2/protein/{proteins}/table)
	Sars2ProteinTable(w http.ResponseWriter, r *http.Request, proteins []string, params Sars2ProteinTableParams)
	// Get virus annotation report by taxon
	// (GET /virus/taxon/{taxon}/annotation_report)
	VirusAnnotationReportsByTaxon(w http.ResponseWriter, r *http.Request, taxon string, params VirusAnnotationReportsByTaxonParams)
	// Get virus metadata by taxon
	// (GET /virus/taxon/{taxon}/dataset_report)
	VirusReportsByTaxon(w http.ResponseWriter, r *http.Request, taxon string, params VirusReportsByTaxonParams)
	// Get summary data for virus genomes by taxon
	// (GET /virus/taxon/{taxon}/genome)
	VirusGenomeSummary(w http.ResponseWriter, r *http.Request, taxon string, params VirusGenomeSummaryParams)
	// Download a virus genome dataset by taxon
	// (GET /virus/taxon/{taxon}/genome/download)
	VirusGenomeDownload(w http.ResponseWriter, r *http.Request, taxon string, params VirusGenomeDownloadParams)
	// Get virus genome metadata in a tabular format.
	// (GET /virus/taxon/{taxon}/genome/table)
	VirusGenomeTable(w http.ResponseWriter, r *http.Request, taxon string, params VirusGenomeTableParams)
}

// ServerInterfaceWrapper converts contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler            ServerInterface
	HandlerMiddlewares []MiddlewareFunc
	ErrorHandlerFunc   func(w http.ResponseWriter, r *http.Request, err error)
}

type MiddlewareFunc func(http.Handler) http.Handler

// BioSampleDatasetReport operation middleware
func (siw *ServerInterfaceWrapper) BioSampleDatasetReport(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "accessions" -------------
	var accessions []string

	err = runtime.BindStyledParameterWithOptions("simple", "accessions", r.PathValue("accessions"), &accessions, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "accessions", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, ApiKeyAuthHeaderScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.BioSampleDatasetReport(w, r, accessions)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GeneMetadataByPost operation middleware
func (siw *ServerInterfaceWrapper) GeneMetadataByPost(w http.ResponseWriter, r *http.Request) {

	ctx := r.Context()

	ctx = context.WithValue(ctx, ApiKeyAuthHeaderScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GeneMetadataByPost(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GeneMetadataByAccession operation middleware
func (siw *ServerInterfaceWrapper) GeneMetadataByAccession(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "accessions" -------------
	var accessions []string

	err = runtime.BindStyledParameterWithOptions("simple", "accessions", r.PathValue("accessions"), &accessions, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "accessions", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, ApiKeyAuthHeaderScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params GeneMetadataByAccessionParams

	// ------------- Optional query parameter "returned_content" -------------

	err = runtime.BindQueryParameter("form", true, false, "returned_content", r.URL.Query(), &params.ReturnedContent)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "returned_content", Err: err})
		return
	}

	// ------------- Optional query parameter "table_fields" -------------

	err = runtime.BindQueryParameter("form", true, false, "table_fields", r.URL.Query(), &params.TableFields)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "table_fields", Err: err})
		return
	}

	// ------------- Optional query parameter "include_tabular_header" -------------

	err = runtime.BindQueryParameter("form", true, false, "include_tabular_header", r.URL.Query(), &params.IncludeTabularHeader)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "include_tabular_header", Err: err})
		return
	}

	// ------------- Optional query parameter "page_size" -------------

	err = runtime.BindQueryParameter("form", true, false, "page_size", r.URL.Query(), &params.PageSize)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "page_size", Err: err})
		return
	}

	// ------------- Optional query parameter "page_token" -------------

	err = runtime.BindQueryParameter("form", true, false, "page_token", r.URL.Query(), &params.PageToken)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "page_token", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GeneMetadataByAccession(w, r, accessions, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// DownloadGenePackagePost operation middleware
func (siw *ServerInterfaceWrapper) DownloadGenePackagePost(w http.ResponseWriter, r *http.Request) {

	var err error

	ctx := r.Context()

	ctx = context.WithValue(ctx, ApiKeyAuthHeaderScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params DownloadGenePackagePostParams

	// ------------- Optional query parameter "filename" -------------

	err = runtime.BindQueryParameter("form", true, false, "filename", r.URL.Query(), &params.Filename)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "filename", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DownloadGenePackagePost(w, r, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GeneDownloadSummaryByPost operation middleware
func (siw *ServerInterfaceWrapper) GeneDownloadSummaryByPost(w http.ResponseWriter, r *http.Request) {

	ctx := r.Context()

	ctx = context.WithValue(ctx, ApiKeyAuthHeaderScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GeneDownloadSummaryByPost(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GeneReportsById operation middleware
func (siw *ServerInterfaceWrapper) GeneReportsById(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "gene_ids" -------------
	var geneIds []int

	err = runtime.BindStyledParameterWithOptions("simple", "gene_ids", r.PathValue("gene_ids"), &geneIds, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "gene_ids", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, ApiKeyAuthHeaderScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params GeneReportsByIdParams

	// ------------- Optional query parameter "returned_content" -------------

	err = runtime.BindQueryParameter("form", true, false, "returned_content", r.URL.Query(), &params.ReturnedContent)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "returned_content", Err: err})
		return
	}

	// ------------- Optional query parameter "table_fields" -------------

	err = runtime.BindQueryParameter("form", true, false, "table_fields", r.URL.Query(), &params.TableFields)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "table_fields", Err: err})
		return
	}

	// ------------- Optional query parameter "include_tabular_header" -------------

	err = runtime.BindQueryParameter("form", true, false, "include_tabular_header", r.URL.Query(), &params.IncludeTabularHeader)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "include_tabular_header", Err: err})
		return
	}

	// ------------- Optional query parameter "page_size" -------------

	err = runtime.BindQueryParameter("form", true, false, "page_size", r.URL.Query(), &params.PageSize)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "page_size", Err: err})
		return
	}

	// ------------- Optional query parameter "page_token" -------------

	err = runtime.BindQueryParameter("form", true, false, "page_token", r.URL.Query(), &params.PageToken)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "page_token", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GeneReportsById(w, r, geneIds, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// DownloadGenePackage operation middleware
func (siw *ServerInterfaceWrapper) DownloadGenePackage(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "gene_ids" -------------
	var geneIds []int

	err = runtime.BindStyledParameterWithOptions("simple", "gene_ids", r.PathValue("gene_ids"), &geneIds, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "gene_ids", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, ApiKeyAuthHeaderScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params DownloadGenePackageParams

	// ------------- Optional query parameter "include_annotation_type" -------------

	err = runtime.BindQueryParameter("form", true, false, "include_annotation_type", r.URL.Query(), &params.IncludeAnnotationType)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "include_annotation_type", Err: err})
		return
	}

	// ------------- Optional query parameter "fasta_filter" -------------

	err = runtime.BindQueryParameter("form", true, false, "fasta_filter", r.URL.Query(), &params.FastaFilter)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "fasta_filter", Err: err})
		return
	}

	// ------------- Optional query parameter "aux_report" -------------

	err = runtime.BindQueryParameter("form", true, false, "aux_report", r.URL.Query(), &params.AuxReport)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "aux_report", Err: err})
		return
	}

	// ------------- Optional query parameter "table_fields" -------------

	err = runtime.BindQueryParameter("form", true, false, "table_fields", r.URL.Query(), &params.TableFields)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "table_fields", Err: err})
		return
	}

	// ------------- Optional query parameter "table_report_type" -------------

	err = runtime.BindQueryParameter("form", true, false, "table_report_type", r.URL.Query(), &params.TableReportType)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "table_report_type", Err: err})
		return
	}

	// ------------- Optional query parameter "filename" -------------

	err = runtime.BindQueryParameter("form", true, false, "filename", r.URL.Query(), &params.Filename)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "filename", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DownloadGenePackage(w, r, geneIds, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GeneDownloadSummaryById operation middleware
func (siw *ServerInterfaceWrapper) GeneDownloadSummaryById(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "gene_ids" -------------
	var geneIds []int

	err = runtime.BindStyledParameterWithOptions("simple", "gene_ids", r.PathValue("gene_ids"), &geneIds, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "gene_ids", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, ApiKeyAuthHeaderScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params GeneDownloadSummaryByIdParams

	// ------------- Optional query parameter "include_annotation_type" -------------

	err = runtime.BindQueryParameter("form", true, false, "include_annotation_type", r.URL.Query(), &params.IncludeAnnotationType)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "include_annotation_type", Err: err})
		return
	}

	// ------------- Optional query parameter "returned_content" -------------

	err = runtime.BindQueryParameter("form", true, false, "returned_content", r.URL.Query(), &params.ReturnedContent)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "returned_content", Err: err})
		return
	}

	// ------------- Optional query parameter "fasta_filter" -------------

	err = runtime.BindQueryParameter("form", true, false, "fasta_filter", r.URL.Query(), &params.FastaFilter)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "fasta_filter", Err: err})
		return
	}

	// ------------- Optional query parameter "aux_report" -------------

	err = runtime.BindQueryParameter("form", true, false, "aux_report", r.URL.Query(), &params.AuxReport)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "aux_report", Err: err})
		return
	}

	// ------------- Optional query parameter "table_fields" -------------

	err = runtime.BindQueryParameter("form", true, false, "table_fields", r.URL.Query(), &params.TableFields)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "table_fields", Err: err})
		return
	}

	// ------------- Optional query parameter "table_report_type" -------------

	err = runtime.BindQueryParameter("form", true, false, "table_report_type", r.URL.Query(), &params.TableReportType)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "table_report_type", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GeneDownloadSummaryById(w, r, geneIds, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GeneLinksById operation middleware
func (siw *ServerInterfaceWrapper) GeneLinksById(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "gene_ids" -------------
	var geneIds []int

	err = runtime.BindStyledParameterWithOptions("simple", "gene_ids", r.PathValue("gene_ids"), &geneIds, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "gene_ids", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, ApiKeyAuthHeaderScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GeneLinksById(w, r, geneIds)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GeneOrthologsById operation middleware
func (siw *ServerInterfaceWrapper) GeneOrthologsById(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "gene_id" -------------
	var geneId int

	err = runtime.BindStyledParameterWithOptions("simple", "gene_id", r.PathValue("gene_id"), &geneId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "gene_id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, ApiKeyAuthHeaderScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params GeneOrthologsByIdParams

	// ------------- Optional query parameter "returned_content" -------------

	err = runtime.BindQueryParameter("form", true, false, "returned_content", r.URL.Query(), &params.ReturnedContent)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "returned_content", Err: err})
		return
	}

	// ------------- Optional query parameter "taxon_filter" -------------

	err = runtime.BindQueryParameter("form", true, false, "taxon_filter", r.URL.Query(), &params.TaxonFilter)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "taxon_filter", Err: err})
		return
	}

	// ------------- Optional query parameter "page_size" -------------

	err = runtime.BindQueryParameter("form", true, false, "page_size", r.URL.Query(), &params.PageSize)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "page_size", Err: err})
		return
	}

	// ------------- Optional query parameter "page_token" -------------

	err = runtime.BindQueryParameter("form", true, false, "page_token", r.URL.Query(), &params.PageToken)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "page_token", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GeneOrthologsById(w, r, geneId, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GeneLinksByIdByPost operation middleware
func (siw *ServerInterfaceWrapper) GeneLinksByIdByPost(w http.ResponseWriter, r *http.Request) {

	ctx := r.Context()

	ctx = context.WithValue(ctx, ApiKeyAuthHeaderScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GeneLinksByIdByPost(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GeneOrthologsByPost operation middleware
func (siw *ServerInterfaceWrapper) GeneOrthologsByPost(w http.ResponseWriter, r *http.Request) {

	ctx := r.Context()

	ctx = context.WithValue(ctx, ApiKeyAuthHeaderScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GeneOrthologsByPost(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GeneMetadataByTaxAndSymbol operation middleware
func (siw *ServerInterfaceWrapper) GeneMetadataByTaxAndSymbol(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "symbols" -------------
	var symbols []string

	err = runtime.BindStyledParameterWithOptions("simple", "symbols", r.PathValue("symbols"), &symbols, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "symbols", Err: err})
		return
	}

	// ------------- Path parameter "taxon" -------------
	var taxon string

	err = runtime.BindStyledParameterWithOptions("simple", "taxon", r.PathValue("taxon"), &taxon, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "taxon", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, ApiKeyAuthHeaderScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params GeneMetadataByTaxAndSymbolParams

	// ------------- Optional query parameter "returned_content" -------------

	err = runtime.BindQueryParameter("form", true, false, "returned_content", r.URL.Query(), &params.ReturnedContent)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "returned_content", Err: err})
		return
	}

	// ------------- Optional query parameter "table_fields" -------------

	err = runtime.BindQueryParameter("form", true, false, "table_fields", r.URL.Query(), &params.TableFields)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "table_fields", Err: err})
		return
	}

	// ------------- Optional query parameter "include_tabular_header" -------------

	err = runtime.BindQueryParameter("form", true, false, "include_tabular_header", r.URL.Query(), &params.IncludeTabularHeader)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "include_tabular_header", Err: err})
		return
	}

	// ------------- Optional query parameter "page_size" -------------

	err = runtime.BindQueryParameter("form", true, false, "page_size", r.URL.Query(), &params.PageSize)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "page_size", Err: err})
		return
	}

	// ------------- Optional query parameter "page_token" -------------

	err = runtime.BindQueryParameter("form", true, false, "page_token", r.URL.Query(), &params.PageToken)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "page_token", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GeneMetadataByTaxAndSymbol(w, r, symbols, taxon, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GeneCountsForTaxonByPost operation middleware
func (siw *ServerInterfaceWrapper) GeneCountsForTaxonByPost(w http.ResponseWriter, r *http.Request) {

	ctx := r.Context()

	ctx = context.WithValue(ctx, ApiKeyAuthHeaderScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GeneCountsForTaxonByPost(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GeneReportsByTaxon operation middleware
func (siw *ServerInterfaceWrapper) GeneReportsByTaxon(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "taxon" -------------
	var taxon string

	err = runtime.BindStyledParameterWithOptions("simple", "taxon", r.PathValue("taxon"), &taxon, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "taxon", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, ApiKeyAuthHeaderScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params GeneReportsByTaxonParams

	// ------------- Optional query parameter "returned_content" -------------

	err = runtime.BindQueryParameter("form", true, false, "returned_content", r.URL.Query(), &params.ReturnedContent)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "returned_content", Err: err})
		return
	}

	// ------------- Optional query parameter "table_fields" -------------

	err = runtime.BindQueryParameter("form", true, false, "table_fields", r.URL.Query(), &params.TableFields)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "table_fields", Err: err})
		return
	}

	// ------------- Optional query parameter "include_tabular_header" -------------

	err = runtime.BindQueryParameter("form", true, false, "include_tabular_header", r.URL.Query(), &params.IncludeTabularHeader)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "include_tabular_header", Err: err})
		return
	}

	// ------------- Optional query parameter "page_size" -------------

	err = runtime.BindQueryParameter("form", true, false, "page_size", r.URL.Query(), &params.PageSize)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "page_size", Err: err})
		return
	}

	// ------------- Optional query parameter "page_token" -------------

	err = runtime.BindQueryParameter("form", true, false, "page_token", r.URL.Query(), &params.PageToken)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "page_token", Err: err})
		return
	}

	// ------------- Optional query parameter "query" -------------

	err = runtime.BindQueryParameter("form", true, false, "query", r.URL.Query(), &params.Query)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "query", Err: err})
		return
	}

	// ------------- Optional query parameter "types" -------------

	err = runtime.BindQueryParameter("form", true, false, "types", r.URL.Query(), &params.Types)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "types", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GeneReportsByTaxon(w, r, taxon, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GeneChromosomeSummary operation middleware
func (siw *ServerInterfaceWrapper) GeneChromosomeSummary(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "taxon" -------------
	var taxon string

	err = runtime.BindStyledParameterWithOptions("simple", "taxon", r.PathValue("taxon"), &taxon, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "taxon", Err: err})
		return
	}

	// ------------- Path parameter "annotation_name" -------------
	var annotationName string

	err = runtime.BindStyledParameterWithOptions("simple", "annotation_name", r.PathValue("annotation_name"), &annotationName, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "annotation_name", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, ApiKeyAuthHeaderScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GeneChromosomeSummary(w, r, taxon, annotationName)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GeneCountsForTaxon operation middleware
func (siw *ServerInterfaceWrapper) GeneCountsForTaxon(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "taxon" -------------
	var taxon string

	err = runtime.BindStyledParameterWithOptions("simple", "taxon", r.PathValue("taxon"), &taxon, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "taxon", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, ApiKeyAuthHeaderScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GeneCountsForTaxon(w, r, taxon)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// CheckAssemblyAvailability operation middleware
func (siw *ServerInterfaceWrapper) CheckAssemblyAvailability(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "accessions" -------------
	var accessions []string

	err = runtime.BindStyledParameterWithOptions("simple", "accessions", r.PathValue("accessions"), &accessions, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "accessions", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, ApiKeyAuthHeaderScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params CheckAssemblyAvailabilityParams

	// ------------- Optional query parameter "_exp_debug_values" -------------

	err = runtime.BindQueryParameter("form", true, false, "_exp_debug_values", r.URL.Query(), &params.ExpDebugValues)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "_exp_debug_values", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.CheckAssemblyAvailability(w, r, accessions, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GenomeDatasetReport operation middleware
func (siw *ServerInterfaceWrapper) GenomeDatasetReport(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "accessions" -------------
	var accessions []string

	err = runtime.BindStyledParameterWithOptions("simple", "accessions", r.PathValue("accessions"), &accessions, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "accessions", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, ApiKeyAuthHeaderScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params GenomeDatasetReportParams

	// ------------- Optional query parameter "filters.reference_only" -------------

	err = runtime.BindQueryParameter("form", true, false, "filters.reference_only", r.URL.Query(), &params.FiltersReferenceOnly)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "filters.reference_only", Err: err})
		return
	}

	// ------------- Optional query parameter "filters.assembly_source" -------------

	err = runtime.BindQueryParameter("form", true, false, "filters.assembly_source", r.URL.Query(), &params.FiltersAssemblySource)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "filters.assembly_source", Err: err})
		return
	}

	// ------------- Optional query parameter "filters.has_annotation" -------------

	err = runtime.BindQueryParameter("form", true, false, "filters.has_annotation", r.URL.Query(), &params.FiltersHasAnnotation)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "filters.has_annotation", Err: err})
		return
	}

	// ------------- Optional query parameter "filters.exclude_paired_reports" -------------

	err = runtime.BindQueryParameter("form", true, false, "filters.exclude_paired_reports", r.URL.Query(), &params.FiltersExcludePairedReports)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "filters.exclude_paired_reports", Err: err})
		return
	}

	// ------------- Optional query parameter "filters.exclude_atypical" -------------

	err = runtime.BindQueryParameter("form", true, false, "filters.exclude_atypical", r.URL.Query(), &params.FiltersExcludeAtypical)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "filters.exclude_atypical", Err: err})
		return
	}

	// ------------- Optional query parameter "filters.assembly_version" -------------

	err = runtime.BindQueryParameter("form", true, false, "filters.assembly_version", r.URL.Query(), &params.FiltersAssemblyVersion)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "filters.assembly_version", Err: err})
		return
	}

	// ------------- Optional query parameter "filters.assembly_level" -------------

	err = runtime.BindQueryParameter("form", true, false, "filters.assembly_level", r.URL.Query(), &params.FiltersAssemblyLevel)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "filters.assembly_level", Err: err})
		return
	}

	// ------------- Optional query parameter "filters.first_release_date" -------------

	err = runtime.BindQueryParameter("form", true, false, "filters.first_release_date", r.URL.Query(), &params.FiltersFirstReleaseDate)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "filters.first_release_date", Err: err})
		return
	}

	// ------------- Optional query parameter "filters.last_release_date" -------------

	err = runtime.BindQueryParameter("form", true, false, "filters.last_release_date", r.URL.Query(), &params.FiltersLastReleaseDate)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "filters.last_release_date", Err: err})
		return
	}

	// ------------- Optional query parameter "filters.search_text" -------------

	err = runtime.BindQueryParameter("form", true, false, "filters.search_text", r.URL.Query(), &params.FiltersSearchText)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "filters.search_text", Err: err})
		return
	}

	// ------------- Optional query parameter "filters.is_metagenome_derived" -------------

	err = runtime.BindQueryParameter("form", true, false, "filters.is_metagenome_derived", r.URL.Query(), &params.FiltersIsMetagenomeDerived)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "filters.is_metagenome_derived", Err: err})
		return
	}

	// ------------- Optional query parameter "filters.is_type_material" -------------

	err = runtime.BindQueryParameter("form", true, false, "filters.is_type_material", r.URL.Query(), &params.FiltersIsTypeMaterial)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "filters.is_type_material", Err: err})
		return
	}

	// ------------- Optional query parameter "filters.is_ictv_exemplar" -------------

	err = runtime.BindQueryParameter("form", true, false, "filters.is_ictv_exemplar", r.URL.Query(), &params.FiltersIsIctvExemplar)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "filters.is_ictv_exemplar", Err: err})
		return
	}

	// ------------- Optional query parameter "filters.exclude_multi_isolate" -------------

	err = runtime.BindQueryParameter("form", true, false, "filters.exclude_multi_isolate", r.URL.Query(), &params.FiltersExcludeMultiIsolate)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "filters.exclude_multi_isolate", Err: err})
		return
	}

	// ------------- Optional query parameter "filters.type_material_category" -------------

	err = runtime.BindQueryParameter("form", true, false, "filters.type_material_category", r.URL.Query(), &params.FiltersTypeMaterialCategory)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "filters.type_material_category", Err: err})
		return
	}

	// ------------- Optional query parameter "tax_exact_match" -------------

	err = runtime.BindQueryParameter("form", true, false, "tax_exact_match", r.URL.Query(), &params.TaxExactMatch)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "tax_exact_match", Err: err})
		return
	}

	// ------------- Optional query parameter "table_fields" -------------

	err = runtime.BindQueryParameter("form", true, false, "table_fields", r.URL.Query(), &params.TableFields)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "table_fields", Err: err})
		return
	}

	// ------------- Optional query parameter "returned_content" -------------

	err = runtime.BindQueryParameter("form", true, false, "returned_content", r.URL.Query(), &params.ReturnedContent)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "returned_content", Err: err})
		return
	}

	// ------------- Optional query parameter "page_size" -------------

	err = runtime.BindQueryParameter("form", true, false, "page_size", r.URL.Query(), &params.PageSize)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "page_size", Err: err})
		return
	}

	// ------------- Optional query parameter "page_token" -------------

	err = runtime.BindQueryParameter("form", true, false, "page_token", r.URL.Query(), &params.PageToken)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "page_token", Err: err})
		return
	}

	// ------------- Optional query parameter "sort.field" -------------

	err = runtime.BindQueryParameter("form", true, false, "sort.field", r.URL.Query(), &params.SortField)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "sort.field", Err: err})
		return
	}

	// ------------- Optional query parameter "sort.direction" -------------

	err = runtime.BindQueryParameter("form", true, false, "sort.direction", r.URL.Query(), &params.SortDirection)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "sort.direction", Err: err})
		return
	}

	// ------------- Optional query parameter "include_tabular_header" -------------

	err = runtime.BindQueryParameter("form", true, false, "include_tabular_header", r.URL.Query(), &params.IncludeTabularHeader)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "include_tabular_header", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GenomeDatasetReport(w, r, accessions, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// DownloadAssemblyPackage operation middleware
func (siw *ServerInterfaceWrapper) DownloadAssemblyPackage(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "accessions" -------------
	var accessions []string

	err = runtime.BindStyledParameterWithOptions("simple", "accessions", r.PathValue("accessions"), &accessions, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "accessions", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, ApiKeyAuthHeaderScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params DownloadAssemblyPackageParams

	// ------------- Optional query parameter "chromosomes" -------------

	err = runtime.BindQueryParameter("form", true, false, "chromosomes", r.URL.Query(), &params.Chromosomes)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "chromosomes", Err: err})
		return
	}

	// ------------- Optional query parameter "include_annotation_type" -------------

	err = runtime.BindQueryParameter("form", true, false, "include_annotation_type", r.URL.Query(), &params.IncludeAnnotationType)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "include_annotation_type", Err: err})
		return
	}

	// ------------- Optional query parameter "hydrated" -------------

	err = runtime.BindQueryParameter("form", true, false, "hydrated", r.URL.Query(), &params.Hydrated)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "hydrated", Err: err})
		return
	}

	// ------------- Optional query parameter "_exp_debug_values" -------------

	err = runtime.BindQueryParameter("form", true, false, "_exp_debug_values", r.URL.Query(), &params.ExpDebugValues)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "_exp_debug_values", Err: err})
		return
	}

	// ------------- Optional query parameter "filename" -------------

	err = runtime.BindQueryParameter("form", true, false, "filename", r.URL.Query(), &params.Filename)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "filename", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DownloadAssemblyPackage(w, r, accessions, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GenomeDownloadSummary operation middleware
func (siw *ServerInterfaceWrapper) GenomeDownloadSummary(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "accessions" -------------
	var accessions []string

	err = runtime.BindStyledParameterWithOptions("simple", "accessions", r.PathValue("accessions"), &accessions, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "accessions", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, ApiKeyAuthHeaderScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params GenomeDownloadSummaryParams

	// ------------- Optional query parameter "chromosomes" -------------

	err = runtime.BindQueryParameter("form", true, false, "chromosomes", r.URL.Query(), &params.Chromosomes)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "chromosomes", Err: err})
		return
	}

	// ------------- Optional query parameter "include_annotation_type" -------------

	err = runtime.BindQueryParameter("form", true, false, "include_annotation_type", r.URL.Query(), &params.IncludeAnnotationType)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "include_annotation_type", Err: err})
		return
	}

	// ------------- Optional query parameter "_exp_debug_values" -------------

	err = runtime.BindQueryParameter("form", true, false, "_exp_debug_values", r.URL.Query(), &params.ExpDebugValues)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "_exp_debug_values", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GenomeDownloadSummary(w, r, accessions, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GenomeLinksByAccession operation middleware
func (siw *ServerInterfaceWrapper) GenomeLinksByAccession(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "accessions" -------------
	var accessions []string

	err = runtime.BindStyledParameterWithOptions("simple", "accessions", r.PathValue("accessions"), &accessions, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "accessions", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, ApiKeyAuthHeaderScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GenomeLinksByAccession(w, r, accessions)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GenomeAnnotationReport operation middleware
func (siw *ServerInterfaceWrapper) GenomeAnnotationReport(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "accession" -------------
	var accession string

	err = runtime.BindStyledParameterWithOptions("simple", "accession", r.PathValue("accession"), &accession, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "accession", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, ApiKeyAuthHeaderScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params GenomeAnnotationReportParams

	// ------------- Optional query parameter "annotation_ids" -------------

	err = runtime.BindQueryParameter("form", true, false, "annotation_ids", r.URL.Query(), &params.AnnotationIds)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "annotation_ids", Err: err})
		return
	}

	// ------------- Optional query parameter "symbols" -------------

	err = runtime.BindQueryParameter("form", true, false, "symbols", r.URL.Query(), &params.Symbols)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "symbols", Err: err})
		return
	}

	// ------------- Optional query parameter "locations" -------------

	err = runtime.BindQueryParameter("form", true, false, "locations", r.URL.Query(), &params.Locations)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "locations", Err: err})
		return
	}

	// ------------- Optional query parameter "gene_types" -------------

	err = runtime.BindQueryParameter("form", true, false, "gene_types", r.URL.Query(), &params.GeneTypes)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "gene_types", Err: err})
		return
	}

	// ------------- Optional query parameter "search_text" -------------

	err = runtime.BindQueryParameter("form", true, false, "search_text", r.URL.Query(), &params.SearchText)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "search_text", Err: err})
		return
	}

	// ------------- Optional query parameter "sort.field" -------------

	err = runtime.BindQueryParameter("form", true, false, "sort.field", r.URL.Query(), &params.SortField)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "sort.field", Err: err})
		return
	}

	// ------------- Optional query parameter "sort.direction" -------------

	err = runtime.BindQueryParameter("form", true, false, "sort.direction", r.URL.Query(), &params.SortDirection)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "sort.direction", Err: err})
		return
	}

	// ------------- Optional query parameter "page_size" -------------

	err = runtime.BindQueryParameter("form", true, false, "page_size", r.URL.Query(), &params.PageSize)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "page_size", Err: err})
		return
	}

	// ------------- Optional query parameter "table_fields" -------------

	err = runtime.BindQueryParameter("form", true, false, "table_fields", r.URL.Query(), &params.TableFields)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "table_fields", Err: err})
		return
	}

	// ------------- Optional query parameter "table_format" -------------

	err = runtime.BindQueryParameter("form", true, false, "table_format", r.URL.Query(), &params.TableFormat)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "table_format", Err: err})
		return
	}

	// ------------- Optional query parameter "include_tabular_header" -------------

	err = runtime.BindQueryParameter("form", true, false, "include_tabular_header", r.URL.Query(), &params.IncludeTabularHeader)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "include_tabular_header", Err: err})
		return
	}

	// ------------- Optional query parameter "page_token" -------------

	err = runtime.BindQueryParameter("form", true, false, "page_token", r.URL.Query(), &params.PageToken)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "page_token", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GenomeAnnotationReport(w, r, accession, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// DownloadGenomeAnnotationPackage operation middleware
func (siw *ServerInterfaceWrapper) DownloadGenomeAnnotationPackage(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "accession" -------------
	var accession string

	err = runtime.BindStyledParameterWithOptions("simple", "accession", r.PathValue("accession"), &accession, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "accession", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, ApiKeyAuthHeaderScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params DownloadGenomeAnnotationPackageParams

	// ------------- Optional query parameter "annotation_ids" -------------

	err = runtime.BindQueryParameter("form", true, false, "annotation_ids", r.URL.Query(), &params.AnnotationIds)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "annotation_ids", Err: err})
		return
	}

	// ------------- Optional query parameter "symbols" -------------

	err = runtime.BindQueryParameter("form", true, false, "symbols", r.URL.Query(), &params.Symbols)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "symbols", Err: err})
		return
	}

	// ------------- Optional query parameter "locations" -------------

	err = runtime.BindQueryParameter("form", true, false, "locations", r.URL.Query(), &params.Locations)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "locations", Err: err})
		return
	}

	// ------------- Optional query parameter "gene_types" -------------

	err = runtime.BindQueryParameter("form", true, false, "gene_types", r.URL.Query(), &params.GeneTypes)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "gene_types", Err: err})
		return
	}

	// ------------- Optional query parameter "search_text" -------------

	err = runtime.BindQueryParameter("form", true, false, "search_text", r.URL.Query(), &params.SearchText)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "search_text", Err: err})
		return
	}

	// ------------- Optional query parameter "sort.field" -------------

	err = runtime.BindQueryParameter("form", true, false, "sort.field", r.URL.Query(), &params.SortField)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "sort.field", Err: err})
		return
	}

	// ------------- Optional query parameter "sort.direction" -------------

	err = runtime.BindQueryParameter("form", true, false, "sort.direction", r.URL.Query(), &params.SortDirection)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "sort.direction", Err: err})
		return
	}

	// ------------- Optional query parameter "include_annotation_type" -------------

	err = runtime.BindQueryParameter("form", true, false, "include_annotation_type", r.URL.Query(), &params.IncludeAnnotationType)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "include_annotation_type", Err: err})
		return
	}

	// ------------- Optional query parameter "page_size" -------------

	err = runtime.BindQueryParameter("form", true, false, "page_size", r.URL.Query(), &params.PageSize)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "page_size", Err: err})
		return
	}

	// ------------- Optional query parameter "table_fields" -------------

	err = runtime.BindQueryParameter("form", true, false, "table_fields", r.URL.Query(), &params.TableFields)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "table_fields", Err: err})
		return
	}

	// ------------- Optional query parameter "table_format" -------------

	err = runtime.BindQueryParameter("form", true, false, "table_format", r.URL.Query(), &params.TableFormat)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "table_format", Err: err})
		return
	}

	// ------------- Optional query parameter "include_tabular_header" -------------

	err = runtime.BindQueryParameter("form", true, false, "include_tabular_header", r.URL.Query(), &params.IncludeTabularHeader)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "include_tabular_header", Err: err})
		return
	}

	// ------------- Optional query parameter "page_token" -------------

	err = runtime.BindQueryParameter("form", true, false, "page_token", r.URL.Query(), &params.PageToken)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "page_token", Err: err})
		return
	}

	// ------------- Optional query parameter "filename" -------------

	err = runtime.BindQueryParameter("form", true, false, "filename", r.URL.Query(), &params.Filename)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "filename", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DownloadGenomeAnnotationPackage(w, r, accession, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GenomeAnnotationDownloadSummary operation middleware
func (siw *ServerInterfaceWrapper) GenomeAnnotationDownloadSummary(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "accession" -------------
	var accession string

	err = runtime.BindStyledParameterWithOptions("simple", "accession", r.PathValue("accession"), &accession, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "accession", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, ApiKeyAuthHeaderScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params GenomeAnnotationDownloadSummaryParams

	// ------------- Optional query parameter "annotation_ids" -------------

	err = runtime.BindQueryParameter("form", true, false, "annotation_ids", r.URL.Query(), &params.AnnotationIds)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "annotation_ids", Err: err})
		return
	}

	// ------------- Optional query parameter "symbols" -------------

	err = runtime.BindQueryParameter("form", true, false, "symbols", r.URL.Query(), &params.Symbols)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "symbols", Err: err})
		return
	}

	// ------------- Optional query parameter "locations" -------------

	err = runtime.BindQueryParameter("form", true, false, "locations", r.URL.Query(), &params.Locations)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "locations", Err: err})
		return
	}

	// ------------- Optional query parameter "gene_types" -------------

	err = runtime.BindQueryParameter("form", true, false, "gene_types", r.URL.Query(), &params.GeneTypes)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "gene_types", Err: err})
		return
	}

	// ------------- Optional query parameter "search_text" -------------

	err = runtime.BindQueryParameter("form", true, false, "search_text", r.URL.Query(), &params.SearchText)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "search_text", Err: err})
		return
	}

	// ------------- Optional query parameter "sort.field" -------------

	err = runtime.BindQueryParameter("form", true, false, "sort.field", r.URL.Query(), &params.SortField)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "sort.field", Err: err})
		return
	}

	// ------------- Optional query parameter "sort.direction" -------------

	err = runtime.BindQueryParameter("form", true, false, "sort.direction", r.URL.Query(), &params.SortDirection)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "sort.direction", Err: err})
		return
	}

	// ------------- Optional query parameter "include_annotation_type" -------------

	err = runtime.BindQueryParameter("form", true, false, "include_annotation_type", r.URL.Query(), &params.IncludeAnnotationType)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "include_annotation_type", Err: err})
		return
	}

	// ------------- Optional query parameter "table_fields" -------------

	err = runtime.BindQueryParameter("form", true, false, "table_fields", r.URL.Query(), &params.TableFields)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "table_fields", Err: err})
		return
	}

	// ------------- Optional query parameter "table_format" -------------

	err = runtime.BindQueryParameter("form", true, false, "table_format", r.URL.Query(), &params.TableFormat)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "table_format", Err: err})
		return
	}

	// ------------- Optional query parameter "include_tabular_header" -------------

	err = runtime.BindQueryParameter("form", true, false, "include_tabular_header", r.URL.Query(), &params.IncludeTabularHeader)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "include_tabular_header", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GenomeAnnotationDownloadSummary(w, r, accession, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// AnnotationReportFacets operation middleware
func (siw *ServerInterfaceWrapper) AnnotationReportFacets(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "accession" -------------
	var accession string

	err = runtime.BindStyledParameterWithOptions("simple", "accession", r.PathValue("accession"), &accession, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "accession", Err: err})
		return
	}

	// ------------- Path parameter "annotation_ids" -------------
	var annotationIds []string

	err = runtime.BindStyledParameterWithOptions("simple", "annotation_ids", r.PathValue("annotation_ids"), &annotationIds, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "annotation_ids", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, ApiKeyAuthHeaderScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params AnnotationReportFacetsParams

	// ------------- Optional query parameter "sort.field" -------------

	err = runtime.BindQueryParameter("form", true, false, "sort.field", r.URL.Query(), &params.SortField)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "sort.field", Err: err})
		return
	}

	// ------------- Optional query parameter "sort.direction" -------------

	err = runtime.BindQueryParameter("form", true, false, "sort.direction", r.URL.Query(), &params.SortDirection)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "sort.direction", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.AnnotationReportFacets(w, r, accession, annotationIds, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// AssemblyRevisionHistoryByGet operation middleware
func (siw *ServerInterfaceWrapper) AssemblyRevisionHistoryByGet(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "accession" -------------
	var accession string

	err = runtime.BindStyledParameterWithOptions("simple", "accession", r.PathValue("accession"), &accession, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "accession", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, ApiKeyAuthHeaderScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.AssemblyRevisionHistoryByGet(w, r, accession)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GenomeSequenceReport operation middleware
func (siw *ServerInterfaceWrapper) GenomeSequenceReport(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "accession" -------------
	var accession string

	err = runtime.BindStyledParameterWithOptions("simple", "accession", r.PathValue("accession"), &accession, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "accession", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, ApiKeyAuthHeaderScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params GenomeSequenceReportParams

	// ------------- Optional query parameter "chromosomes" -------------

	err = runtime.BindQueryParameter("form", true, false, "chromosomes", r.URL.Query(), &params.Chromosomes)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "chromosomes", Err: err})
		return
	}

	// ------------- Optional query parameter "role_filters" -------------

	err = runtime.BindQueryParameter("form", true, false, "role_filters", r.URL.Query(), &params.RoleFilters)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "role_filters", Err: err})
		return
	}

	// ------------- Optional query parameter "table_fields" -------------

	err = runtime.BindQueryParameter("form", true, false, "table_fields", r.URL.Query(), &params.TableFields)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "table_fields", Err: err})
		return
	}

	// ------------- Optional query parameter "count_assembly_unplaced" -------------

	err = runtime.BindQueryParameter("form", true, false, "count_assembly_unplaced", r.URL.Query(), &params.CountAssemblyUnplaced)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "count_assembly_unplaced", Err: err})
		return
	}

	// ------------- Optional query parameter "page_size" -------------

	err = runtime.BindQueryParameter("form", true, false, "page_size", r.URL.Query(), &params.PageSize)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "page_size", Err: err})
		return
	}

	// ------------- Optional query parameter "page_token" -------------

	err = runtime.BindQueryParameter("form", true, false, "page_token", r.URL.Query(), &params.PageToken)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "page_token", Err: err})
		return
	}

	// ------------- Optional query parameter "include_tabular_header" -------------

	err = runtime.BindQueryParameter("form", true, false, "include_tabular_header", r.URL.Query(), &params.IncludeTabularHeader)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "include_tabular_header", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GenomeSequenceReport(w, r, accession, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GenomeAnnotationReportByPost operation middleware
func (siw *ServerInterfaceWrapper) GenomeAnnotationReportByPost(w http.ResponseWriter, r *http.Request) {

	ctx := r.Context()

	ctx = context.WithValue(ctx, ApiKeyAuthHeaderScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GenomeAnnotationReportByPost(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// DownloadGenomeAnnotationPackageByPost operation middleware
func (siw *ServerInterfaceWrapper) DownloadGenomeAnnotationPackageByPost(w http.ResponseWriter, r *http.Request) {

	var err error

	ctx := r.Context()

	ctx = context.WithValue(ctx, ApiKeyAuthHeaderScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params DownloadGenomeAnnotationPackageByPostParams

	// ------------- Optional query parameter "filename" -------------

	err = runtime.BindQueryParameter("form", true, false, "filename", r.URL.Query(), &params.Filename)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "filename", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DownloadGenomeAnnotationPackageByPost(w, r, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GenomeAnnotationDownloadSummaryByPost operation middleware
func (siw *ServerInterfaceWrapper) GenomeAnnotationDownloadSummaryByPost(w http.ResponseWriter, r *http.Request) {

	ctx := r.Context()

	ctx = context.WithValue(ctx, ApiKeyAuthHeaderScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GenomeAnnotationDownloadSummaryByPost(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// AnnotationReportFacetsByPost operation middleware
func (siw *ServerInterfaceWrapper) AnnotationReportFacetsByPost(w http.ResponseWriter, r *http.Request) {

	ctx := r.Context()

	ctx = context.WithValue(ctx, ApiKeyAuthHeaderScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.AnnotationReportFacetsByPost(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GenomeDatasetReportsByAssemblyName operation middleware
func (siw *ServerInterfaceWrapper) GenomeDatasetReportsByAssemblyName(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "assembly_names" -------------
	var assemblyNames []string

	err = runtime.BindStyledParameterWithOptions("simple", "assembly_names", r.PathValue("assembly_names"), &assemblyNames, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "assembly_names", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, ApiKeyAuthHeaderScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params GenomeDatasetReportsByAssemblyNameParams

	// ------------- Optional query parameter "filters.reference_only" -------------

	err = runtime.BindQueryParameter("form", true, false, "filters.reference_only", r.URL.Query(), &params.FiltersReferenceOnly)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "filters.reference_only", Err: err})
		return
	}

	// ------------- Optional query parameter "filters.assembly_source" -------------

	err = runtime.BindQueryParameter("form", true, false, "filters.assembly_source", r.URL.Query(), &params.FiltersAssemblySource)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "filters.assembly_source", Err: err})
		return
	}

	// ------------- Optional query parameter "filters.has_annotation" -------------

	err = runtime.BindQueryParameter("form", true, false, "filters.has_annotation", r.URL.Query(), &params.FiltersHasAnnotation)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "filters.has_annotation", Err: err})
		return
	}

	// ------------- Optional query parameter "filters.exclude_paired_reports" -------------

	err = runtime.BindQueryParameter("form", true, false, "filters.exclude_paired_reports", r.URL.Query(), &params.FiltersExcludePairedReports)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "filters.exclude_paired_reports", Err: err})
		return
	}

	// ------------- Optional query parameter "filters.exclude_atypical" -------------

	err = runtime.BindQueryParameter("form", true, false, "filters.exclude_atypical", r.URL.Query(), &params.FiltersExcludeAtypical)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "filters.exclude_atypical", Err: err})
		return
	}

	// ------------- Optional query parameter "filters.assembly_version" -------------

	err = runtime.BindQueryParameter("form", true, false, "filters.assembly_version", r.URL.Query(), &params.FiltersAssemblyVersion)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "filters.assembly_version", Err: err})
		return
	}

	// ------------- Optional query parameter "filters.assembly_level" -------------

	err = runtime.BindQueryParameter("form", true, false, "filters.assembly_level", r.URL.Query(), &params.FiltersAssemblyLevel)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "filters.assembly_level", Err: err})
		return
	}

	// ------------- Optional query parameter "filters.first_release_date" -------------

	err = runtime.BindQueryParameter("form", true, false, "filters.first_release_date", r.URL.Query(), &params.FiltersFirstReleaseDate)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "filters.first_release_date", Err: err})
		return
	}

	// ------------- Optional query parameter "filters.last_release_date" -------------

	err = runtime.BindQueryParameter("form", true, false, "filters.last_release_date", r.URL.Query(), &params.FiltersLastReleaseDate)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "filters.last_release_date", Err: err})
		return
	}

	// ------------- Optional query parameter "filters.search_text" -------------

	err = runtime.BindQueryParameter("form", true, false, "filters.search_text", r.URL.Query(), &params.FiltersSearchText)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "filters.search_text", Err: err})
		return
	}

	// ------------- Optional query parameter "filters.is_metagenome_derived" -------------

	err = runtime.BindQueryParameter("form", true, false, "filters.is_metagenome_derived", r.URL.Query(), &params.FiltersIsMetagenomeDerived)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "filters.is_metagenome_derived", Err: err})
		return
	}

	// ------------- Optional query parameter "filters.is_type_material" -------------

	err = runtime.BindQueryParameter("form", true, false, "filters.is_type_material", r.URL.Query(), &params.FiltersIsTypeMaterial)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "filters.is_type_material", Err: err})
		return
	}

	// ------------- Optional query parameter "filters.is_ictv_exemplar" -------------

	err = runtime.BindQueryParameter("form", true, false, "filters.is_ictv_exemplar", r.URL.Query(), &params.FiltersIsIctvExemplar)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "filters.is_ictv_exemplar", Err: err})
		return
	}

	// ------------- Optional query parameter "filters.exclude_multi_isolate" -------------

	err = runtime.BindQueryParameter("form", true, false, "filters.exclude_multi_isolate", r.URL.Query(), &params.FiltersExcludeMultiIsolate)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "filters.exclude_multi_isolate", Err: err})
		return
	}

	// ------------- Optional query parameter "filters.type_material_category" -------------

	err = runtime.BindQueryParameter("form", true, false, "filters.type_material_category", r.URL.Query(), &params.FiltersTypeMaterialCategory)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "filters.type_material_category", Err: err})
		return
	}

	// ------------- Optional query parameter "tax_exact_match" -------------

	err = runtime.BindQueryParameter("form", true, false, "tax_exact_match", r.URL.Query(), &params.TaxExactMatch)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "tax_exact_match", Err: err})
		return
	}

	// ------------- Optional query parameter "table_fields" -------------

	err = runtime.BindQueryParameter("form", true, false, "table_fields", r.URL.Query(), &params.TableFields)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "table_fields", Err: err})
		return
	}

	// ------------- Optional query parameter "returned_content" -------------

	err = runtime.BindQueryParameter("form", true, false, "returned_content", r.URL.Query(), &params.ReturnedContent)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "returned_content", Err: err})
		return
	}

	// ------------- Optional query parameter "page_size" -------------

	err = runtime.BindQueryParameter("form", true, false, "page_size", r.URL.Query(), &params.PageSize)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "page_size", Err: err})
		return
	}

	// ------------- Optional query parameter "page_token" -------------

	err = runtime.BindQueryParameter("form", true, false, "page_token", r.URL.Query(), &params.PageToken)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "page_token", Err: err})
		return
	}

	// ------------- Optional query parameter "sort.field" -------------

	err = runtime.BindQueryParameter("form", true, false, "sort.field", r.URL.Query(), &params.SortField)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "sort.field", Err: err})
		return
	}

	// ------------- Optional query parameter "sort.direction" -------------

	err = runtime.BindQueryParameter("form", true, false, "sort.direction", r.URL.Query(), &params.SortDirection)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "sort.direction", Err: err})
		return
	}

	// ------------- Optional query parameter "include_tabular_header" -------------

	err = runtime.BindQueryParameter("form", true, false, "include_tabular_header", r.URL.Query(), &params.IncludeTabularHeader)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "include_tabular_header", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GenomeDatasetReportsByAssemblyName(w, r, assemblyNames, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GenomeDatasetReportsByBioproject operation middleware
func (siw *ServerInterfaceWrapper) GenomeDatasetReportsByBioproject(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "bioprojects" -------------
	var bioprojects []string

	err = runtime.BindStyledParameterWithOptions("simple", "bioprojects", r.PathValue("bioprojects"), &bioprojects, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "bioprojects", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, ApiKeyAuthHeaderScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params GenomeDatasetReportsByBioprojectParams

	// ------------- Optional query parameter "filters.reference_only" -------------

	err = runtime.BindQueryParameter("form", true, false, "filters.reference_only", r.URL.Query(), &params.FiltersReferenceOnly)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "filters.reference_only", Err: err})
		return
	}

	// ------------- Optional query parameter "filters.assembly_source" -------------

	err = runtime.BindQueryParameter("form", true, false, "filters.assembly_source", r.URL.Query(), &params.FiltersAssemblySource)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "filters.assembly_source", Err: err})
		return
	}

	// ------------- Optional query parameter "filters.has_annotation" -------------

	err = runtime.BindQueryParameter("form", true, false, "filters.has_annotation", r.URL.Query(), &params.FiltersHasAnnotation)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "filters.has_annotation", Err: err})
		return
	}

	// ------------- Optional query parameter "filters.exclude_paired_reports" -------------

	err = runtime.BindQueryParameter("form", true, false, "filters.exclude_paired_reports", r.URL.Query(), &params.FiltersExcludePairedReports)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "filters.exclude_paired_reports", Err: err})
		return
	}

	// ------------- Optional query parameter "filters.exclude_atypical" -------------

	err = runtime.BindQueryParameter("form", true, false, "filters.exclude_atypical", r.URL.Query(), &params.FiltersExcludeAtypical)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "filters.exclude_atypical", Err: err})
		return
	}

	// ------------- Optional query parameter "filters.assembly_version" -------------

	err = runtime.BindQueryParameter("form", true, false, "filters.assembly_version", r.URL.Query(), &params.FiltersAssemblyVersion)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "filters.assembly_version", Err: err})
		return
	}

	// ------------- Optional query parameter "filters.assembly_level" -------------

	err = runtime.BindQueryParameter("form", true, false, "filters.assembly_level", r.URL.Query(), &params.FiltersAssemblyLevel)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "filters.assembly_level", Err: err})
		return
	}

	// ------------- Optional query parameter "filters.first_release_date" -------------

	err = runtime.BindQueryParameter("form", true, false, "filters.first_release_date", r.URL.Query(), &params.FiltersFirstReleaseDate)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "filters.first_release_date", Err: err})
		return
	}

	// ------------- Optional query parameter "filters.last_release_date" -------------

	err = runtime.BindQueryParameter("form", true, false, "filters.last_release_date", r.URL.Query(), &params.FiltersLastReleaseDate)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "filters.last_release_date", Err: err})
		return
	}

	// ------------- Optional query parameter "filters.search_text" -------------

	err = runtime.BindQueryParameter("form", true, false, "filters.search_text", r.URL.Query(), &params.FiltersSearchText)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "filters.search_text", Err: err})
		return
	}

	// ------------- Optional query parameter "filters.is_metagenome_derived" -------------

	err = runtime.BindQueryParameter("form", true, false, "filters.is_metagenome_derived", r.URL.Query(), &params.FiltersIsMetagenomeDerived)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "filters.is_metagenome_derived", Err: err})
		return
	}

	// ------------- Optional query parameter "filters.is_type_material" -------------

	err = runtime.BindQueryParameter("form", true, false, "filters.is_type_material", r.URL.Query(), &params.FiltersIsTypeMaterial)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "filters.is_type_material", Err: err})
		return
	}

	// ------------- Optional query parameter "filters.is_ictv_exemplar" -------------

	err = runtime.BindQueryParameter("form", true, false, "filters.is_ictv_exemplar", r.URL.Query(), &params.FiltersIsIctvExemplar)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "filters.is_ictv_exemplar", Err: err})
		return
	}

	// ------------- Optional query parameter "filters.exclude_multi_isolate" -------------

	err = runtime.BindQueryParameter("form", true, false, "filters.exclude_multi_isolate", r.URL.Query(), &params.FiltersExcludeMultiIsolate)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "filters.exclude_multi_isolate", Err: err})
		return
	}

	// ------------- Optional query parameter "filters.type_material_category" -------------

	err = runtime.BindQueryParameter("form", true, false, "filters.type_material_category", r.URL.Query(), &params.FiltersTypeMaterialCategory)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "filters.type_material_category", Err: err})
		return
	}

	// ------------- Optional query parameter "tax_exact_match" -------------

	err = runtime.BindQueryParameter("form", true, false, "tax_exact_match", r.URL.Query(), &params.TaxExactMatch)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "tax_exact_match", Err: err})
		return
	}

	// ------------- Optional query parameter "table_fields" -------------

	err = runtime.BindQueryParameter("form", true, false, "table_fields", r.URL.Query(), &params.TableFields)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "table_fields", Err: err})
		return
	}

	// ------------- Optional query parameter "returned_content" -------------

	err = runtime.BindQueryParameter("form", true, false, "returned_content", r.URL.Query(), &params.ReturnedContent)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "returned_content", Err: err})
		return
	}

	// ------------- Optional query parameter "page_size" -------------

	err = runtime.BindQueryParameter("form", true, false, "page_size", r.URL.Query(), &params.PageSize)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "page_size", Err: err})
		return
	}

	// ------------- Optional query parameter "page_token" -------------

	err = runtime.BindQueryParameter("form", true, false, "page_token", r.URL.Query(), &params.PageToken)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "page_token", Err: err})
		return
	}

	// ------------- Optional query parameter "sort.field" -------------

	err = runtime.BindQueryParameter("form", true, false, "sort.field", r.URL.Query(), &params.SortField)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "sort.field", Err: err})
		return
	}

	// ------------- Optional query parameter "sort.direction" -------------

	err = runtime.BindQueryParameter("form", true, false, "sort.direction", r.URL.Query(), &params.SortDirection)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "sort.direction", Err: err})
		return
	}

	// ------------- Optional query parameter "include_tabular_header" -------------

	err = runtime.BindQueryParameter("form", true, false, "include_tabular_header", r.URL.Query(), &params.IncludeTabularHeader)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "include_tabular_header", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GenomeDatasetReportsByBioproject(w, r, bioprojects, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GenomeDatasetReportsByBiosampleId operation middleware
func (siw *ServerInterfaceWrapper) GenomeDatasetReportsByBiosampleId(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "biosample_ids" -------------
	var biosampleIds []string

	err = runtime.BindStyledParameterWithOptions("simple", "biosample_ids", r.PathValue("biosample_ids"), &biosampleIds, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "biosample_ids", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, ApiKeyAuthHeaderScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params GenomeDatasetReportsByBiosampleIdParams

	// ------------- Optional query parameter "filters.reference_only" -------------

	err = runtime.BindQueryParameter("form", true, false, "filters.reference_only", r.URL.Query(), &params.FiltersReferenceOnly)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "filters.reference_only", Err: err})
		return
	}

	// ------------- Optional query parameter "filters.assembly_source" -------------

	err = runtime.BindQueryParameter("form", true, false, "filters.assembly_source", r.URL.Query(), &params.FiltersAssemblySource)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "filters.assembly_source", Err: err})
		return
	}

	// ------------- Optional query parameter "filters.has_annotation" -------------

	err = runtime.BindQueryParameter("form", true, false, "filters.has_annotation", r.URL.Query(), &params.FiltersHasAnnotation)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "filters.has_annotation", Err: err})
		return
	}

	// ------------- Optional query parameter "filters.exclude_paired_reports" -------------

	err = runtime.BindQueryParameter("form", true, false, "filters.exclude_paired_reports", r.URL.Query(), &params.FiltersExcludePairedReports)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "filters.exclude_paired_reports", Err: err})
		return
	}

	// ------------- Optional query parameter "filters.exclude_atypical" -------------

	err = runtime.BindQueryParameter("form", true, false, "filters.exclude_atypical", r.URL.Query(), &params.FiltersExcludeAtypical)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "filters.exclude_atypical", Err: err})
		return
	}

	// ------------- Optional query parameter "filters.assembly_version" -------------

	err = runtime.BindQueryParameter("form", true, false, "filters.assembly_version", r.URL.Query(), &params.FiltersAssemblyVersion)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "filters.assembly_version", Err: err})
		return
	}

	// ------------- Optional query parameter "filters.assembly_level" -------------

	err = runtime.BindQueryParameter("form", true, false, "filters.assembly_level", r.URL.Query(), &params.FiltersAssemblyLevel)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "filters.assembly_level", Err: err})
		return
	}

	// ------------- Optional query parameter "filters.first_release_date" -------------

	err = runtime.BindQueryParameter("form", true, false, "filters.first_release_date", r.URL.Query(), &params.FiltersFirstReleaseDate)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "filters.first_release_date", Err: err})
		return
	}

	// ------------- Optional query parameter "filters.last_release_date" -------------

	err = runtime.BindQueryParameter("form", true, false, "filters.last_release_date", r.URL.Query(), &params.FiltersLastReleaseDate)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "filters.last_release_date", Err: err})
		return
	}

	// ------------- Optional query parameter "filters.search_text" -------------

	err = runtime.BindQueryParameter("form", true, false, "filters.search_text", r.URL.Query(), &params.FiltersSearchText)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "filters.search_text", Err: err})
		return
	}

	// ------------- Optional query parameter "filters.is_metagenome_derived" -------------

	err = runtime.BindQueryParameter("form", true, false, "filters.is_metagenome_derived", r.URL.Query(), &params.FiltersIsMetagenomeDerived)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "filters.is_metagenome_derived", Err: err})
		return
	}

	// ------------- Optional query parameter "filters.is_type_material" -------------

	err = runtime.BindQueryParameter("form", true, false, "filters.is_type_material", r.URL.Query(), &params.FiltersIsTypeMaterial)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "filters.is_type_material", Err: err})
		return
	}

	// ------------- Optional query parameter "filters.is_ictv_exemplar" -------------

	err = runtime.BindQueryParameter("form", true, false, "filters.is_ictv_exemplar", r.URL.Query(), &params.FiltersIsIctvExemplar)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "filters.is_ictv_exemplar", Err: err})
		return
	}

	// ------------- Optional query parameter "filters.exclude_multi_isolate" -------------

	err = runtime.BindQueryParameter("form", true, false, "filters.exclude_multi_isolate", r.URL.Query(), &params.FiltersExcludeMultiIsolate)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "filters.exclude_multi_isolate", Err: err})
		return
	}

	// ------------- Optional query parameter "filters.type_material_category" -------------

	err = runtime.BindQueryParameter("form", true, false, "filters.type_material_category", r.URL.Query(), &params.FiltersTypeMaterialCategory)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "filters.type_material_category", Err: err})
		return
	}

	// ------------- Optional query parameter "tax_exact_match" -------------

	err = runtime.BindQueryParameter("form", true, false, "tax_exact_match", r.URL.Query(), &params.TaxExactMatch)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "tax_exact_match", Err: err})
		return
	}

	// ------------- Optional query parameter "table_fields" -------------

	err = runtime.BindQueryParameter("form", true, false, "table_fields", r.URL.Query(), &params.TableFields)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "table_fields", Err: err})
		return
	}

	// ------------- Optional query parameter "returned_content" -------------

	err = runtime.BindQueryParameter("form", true, false, "returned_content", r.URL.Query(), &params.ReturnedContent)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "returned_content", Err: err})
		return
	}

	// ------------- Optional query parameter "page_size" -------------

	err = runtime.BindQueryParameter("form", true, false, "page_size", r.URL.Query(), &params.PageSize)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "page_size", Err: err})
		return
	}

	// ------------- Optional query parameter "page_token" -------------

	err = runtime.BindQueryParameter("form", true, false, "page_token", r.URL.Query(), &params.PageToken)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "page_token", Err: err})
		return
	}

	// ------------- Optional query parameter "sort.field" -------------

	err = runtime.BindQueryParameter("form", true, false, "sort.field", r.URL.Query(), &params.SortField)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "sort.field", Err: err})
		return
	}

	// ------------- Optional query parameter "sort.direction" -------------

	err = runtime.BindQueryParameter("form", true, false, "sort.direction", r.URL.Query(), &params.SortDirection)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "sort.direction", Err: err})
		return
	}

	// ------------- Optional query parameter "include_tabular_header" -------------

	err = runtime.BindQueryParameter("form", true, false, "include_tabular_header", r.URL.Query(), &params.IncludeTabularHeader)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "include_tabular_header", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GenomeDatasetReportsByBiosampleId(w, r, biosampleIds, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// CheckAssemblyAvailabilityPost operation middleware
func (siw *ServerInterfaceWrapper) CheckAssemblyAvailabilityPost(w http.ResponseWriter, r *http.Request) {

	ctx := r.Context()

	ctx = context.WithValue(ctx, ApiKeyAuthHeaderScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.CheckAssemblyAvailabilityPost(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// CheckmHistogramByTaxonByPost operation middleware
func (siw *ServerInterfaceWrapper) CheckmHistogramByTaxonByPost(w http.ResponseWriter, r *http.Request) {

	ctx := r.Context()

	ctx = context.WithValue(ctx, ApiKeyAuthHeaderScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.CheckmHistogramByTaxonByPost(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GenomeDatasetReportByPost operation middleware
func (siw *ServerInterfaceWrapper) GenomeDatasetReportByPost(w http.ResponseWriter, r *http.Request) {

	ctx := r.Context()

	ctx = context.WithValue(ctx, ApiKeyAuthHeaderScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GenomeDatasetReportByPost(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// DownloadAssemblyPackagePost operation middleware
func (siw *ServerInterfaceWrapper) DownloadAssemblyPackagePost(w http.ResponseWriter, r *http.Request) {

	var err error

	ctx := r.Context()

	ctx = context.WithValue(ctx, ApiKeyAuthHeaderScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params DownloadAssemblyPackagePostParams

	// ------------- Optional query parameter "filename" -------------

	err = runtime.BindQueryParameter("form", true, false, "filename", r.URL.Query(), &params.Filename)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "filename", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DownloadAssemblyPackagePost(w, r, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GenomeDownloadSummaryByPost operation middleware
func (siw *ServerInterfaceWrapper) GenomeDownloadSummaryByPost(w http.ResponseWriter, r *http.Request) {

	ctx := r.Context()

	ctx = context.WithValue(ctx, ApiKeyAuthHeaderScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GenomeDownloadSummaryByPost(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GenomeLinksByAccessionByPost operation middleware
func (siw *ServerInterfaceWrapper) GenomeLinksByAccessionByPost(w http.ResponseWriter, r *http.Request) {

	ctx := r.Context()

	ctx = context.WithValue(ctx, ApiKeyAuthHeaderScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GenomeLinksByAccessionByPost(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// AssemblyRevisionHistoryByPost operation middleware
func (siw *ServerInterfaceWrapper) AssemblyRevisionHistoryByPost(w http.ResponseWriter, r *http.Request) {

	ctx := r.Context()

	ctx = context.WithValue(ctx, ApiKeyAuthHeaderScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.AssemblyRevisionHistoryByPost(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// AssemblyAccessionsForSequenceAccession operation middleware
func (siw *ServerInterfaceWrapper) AssemblyAccessionsForSequenceAccession(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "accession" -------------
	var accession string

	err = runtime.BindStyledParameterWithOptions("simple", "accession", r.PathValue("accession"), &accession, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "accession", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, ApiKeyAuthHeaderScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.AssemblyAccessionsForSequenceAccession(w, r, accession)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// AssemblyAccessionsForSequenceAccessionByPost operation middleware
func (siw *ServerInterfaceWrapper) AssemblyAccessionsForSequenceAccessionByPost(w http.ResponseWriter, r *http.Request) {

	ctx := r.Context()

	ctx = context.WithValue(ctx, ApiKeyAuthHeaderScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.AssemblyAccessionsForSequenceAccessionByPost(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GenomeSequenceReportByPost operation middleware
func (siw *ServerInterfaceWrapper) GenomeSequenceReportByPost(w http.ResponseWriter, r *http.Request) {

	ctx := r.Context()

	ctx = context.WithValue(ctx, ApiKeyAuthHeaderScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GenomeSequenceReportByPost(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// CheckmHistogramByTaxon operation middleware
func (siw *ServerInterfaceWrapper) CheckmHistogramByTaxon(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "species_taxon" -------------
	var speciesTaxon string

	err = runtime.BindStyledParameterWithOptions("simple", "species_taxon", r.PathValue("species_taxon"), &speciesTaxon, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "species_taxon", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, ApiKeyAuthHeaderScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.CheckmHistogramByTaxon(w, r, speciesTaxon)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GenomeDatasetReportsByTaxon operation middleware
func (siw *ServerInterfaceWrapper) GenomeDatasetReportsByTaxon(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "taxons" -------------
	var taxons []string

	err = runtime.BindStyledParameterWithOptions("simple", "taxons", r.PathValue("taxons"), &taxons, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "taxons", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, ApiKeyAuthHeaderScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params GenomeDatasetReportsByTaxonParams

	// ------------- Optional query parameter "filters.reference_only" -------------

	err = runtime.BindQueryParameter("form", true, false, "filters.reference_only", r.URL.Query(), &params.FiltersReferenceOnly)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "filters.reference_only", Err: err})
		return
	}

	// ------------- Optional query parameter "filters.assembly_source" -------------

	err = runtime.BindQueryParameter("form", true, false, "filters.assembly_source", r.URL.Query(), &params.FiltersAssemblySource)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "filters.assembly_source", Err: err})
		return
	}

	// ------------- Optional query parameter "filters.has_annotation" -------------

	err = runtime.BindQueryParameter("form", true, false, "filters.has_annotation", r.URL.Query(), &params.FiltersHasAnnotation)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "filters.has_annotation", Err: err})
		return
	}

	// ------------- Optional query parameter "filters.exclude_paired_reports" -------------

	err = runtime.BindQueryParameter("form", true, false, "filters.exclude_paired_reports", r.URL.Query(), &params.FiltersExcludePairedReports)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "filters.exclude_paired_reports", Err: err})
		return
	}

	// ------------- Optional query parameter "filters.exclude_atypical" -------------

	err = runtime.BindQueryParameter("form", true, false, "filters.exclude_atypical", r.URL.Query(), &params.FiltersExcludeAtypical)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "filters.exclude_atypical", Err: err})
		return
	}

	// ------------- Optional query parameter "filters.assembly_version" -------------

	err = runtime.BindQueryParameter("form", true, false, "filters.assembly_version", r.URL.Query(), &params.FiltersAssemblyVersion)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "filters.assembly_version", Err: err})
		return
	}

	// ------------- Optional query parameter "filters.assembly_level" -------------

	err = runtime.BindQueryParameter("form", true, false, "filters.assembly_level", r.URL.Query(), &params.FiltersAssemblyLevel)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "filters.assembly_level", Err: err})
		return
	}

	// ------------- Optional query parameter "filters.first_release_date" -------------

	err = runtime.BindQueryParameter("form", true, false, "filters.first_release_date", r.URL.Query(), &params.FiltersFirstReleaseDate)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "filters.first_release_date", Err: err})
		return
	}

	// ------------- Optional query parameter "filters.last_release_date" -------------

	err = runtime.BindQueryParameter("form", true, false, "filters.last_release_date", r.URL.Query(), &params.FiltersLastReleaseDate)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "filters.last_release_date", Err: err})
		return
	}

	// ------------- Optional query parameter "filters.search_text" -------------

	err = runtime.BindQueryParameter("form", true, false, "filters.search_text", r.URL.Query(), &params.FiltersSearchText)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "filters.search_text", Err: err})
		return
	}

	// ------------- Optional query parameter "filters.is_metagenome_derived" -------------

	err = runtime.BindQueryParameter("form", true, false, "filters.is_metagenome_derived", r.URL.Query(), &params.FiltersIsMetagenomeDerived)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "filters.is_metagenome_derived", Err: err})
		return
	}

	// ------------- Optional query parameter "filters.is_type_material" -------------

	err = runtime.BindQueryParameter("form", true, false, "filters.is_type_material", r.URL.Query(), &params.FiltersIsTypeMaterial)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "filters.is_type_material", Err: err})
		return
	}

	// ------------- Optional query parameter "filters.is_ictv_exemplar" -------------

	err = runtime.BindQueryParameter("form", true, false, "filters.is_ictv_exemplar", r.URL.Query(), &params.FiltersIsIctvExemplar)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "filters.is_ictv_exemplar", Err: err})
		return
	}

	// ------------- Optional query parameter "filters.exclude_multi_isolate" -------------

	err = runtime.BindQueryParameter("form", true, false, "filters.exclude_multi_isolate", r.URL.Query(), &params.FiltersExcludeMultiIsolate)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "filters.exclude_multi_isolate", Err: err})
		return
	}

	// ------------- Optional query parameter "filters.type_material_category" -------------

	err = runtime.BindQueryParameter("form", true, false, "filters.type_material_category", r.URL.Query(), &params.FiltersTypeMaterialCategory)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "filters.type_material_category", Err: err})
		return
	}

	// ------------- Optional query parameter "tax_exact_match" -------------

	err = runtime.BindQueryParameter("form", true, false, "tax_exact_match", r.URL.Query(), &params.TaxExactMatch)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "tax_exact_match", Err: err})
		return
	}

	// ------------- Optional query parameter "table_fields" -------------

	err = runtime.BindQueryParameter("form", true, false, "table_fields", r.URL.Query(), &params.TableFields)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "table_fields", Err: err})
		return
	}

	// ------------- Optional query parameter "returned_content" -------------

	err = runtime.BindQueryParameter("form", true, false, "returned_content", r.URL.Query(), &params.ReturnedContent)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "returned_content", Err: err})
		return
	}

	// ------------- Optional query parameter "page_size" -------------

	err = runtime.BindQueryParameter("form", true, false, "page_size", r.URL.Query(), &params.PageSize)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "page_size", Err: err})
		return
	}

	// ------------- Optional query parameter "page_token" -------------

	err = runtime.BindQueryParameter("form", true, false, "page_token", r.URL.Query(), &params.PageToken)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "page_token", Err: err})
		return
	}

	// ------------- Optional query parameter "sort.field" -------------

	err = runtime.BindQueryParameter("form", true, false, "sort.field", r.URL.Query(), &params.SortField)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "sort.field", Err: err})
		return
	}

	// ------------- Optional query parameter "sort.direction" -------------

	err = runtime.BindQueryParameter("form", true, false, "sort.direction", r.URL.Query(), &params.SortDirection)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "sort.direction", Err: err})
		return
	}

	// ------------- Optional query parameter "include_tabular_header" -------------

	err = runtime.BindQueryParameter("form", true, false, "include_tabular_header", r.URL.Query(), &params.IncludeTabularHeader)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "include_tabular_header", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GenomeDatasetReportsByTaxon(w, r, taxons, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GenomeDatasetReportsByWgs operation middleware
func (siw *ServerInterfaceWrapper) GenomeDatasetReportsByWgs(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "wgs_accessions" -------------
	var wgsAccessions []string

	err = runtime.BindStyledParameterWithOptions("simple", "wgs_accessions", r.PathValue("wgs_accessions"), &wgsAccessions, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "wgs_accessions", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, ApiKeyAuthHeaderScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params GenomeDatasetReportsByWgsParams

	// ------------- Optional query parameter "filters.reference_only" -------------

	err = runtime.BindQueryParameter("form", true, false, "filters.reference_only", r.URL.Query(), &params.FiltersReferenceOnly)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "filters.reference_only", Err: err})
		return
	}

	// ------------- Optional query parameter "filters.assembly_source" -------------

	err = runtime.BindQueryParameter("form", true, false, "filters.assembly_source", r.URL.Query(), &params.FiltersAssemblySource)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "filters.assembly_source", Err: err})
		return
	}

	// ------------- Optional query parameter "filters.has_annotation" -------------

	err = runtime.BindQueryParameter("form", true, false, "filters.has_annotation", r.URL.Query(), &params.FiltersHasAnnotation)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "filters.has_annotation", Err: err})
		return
	}

	// ------------- Optional query parameter "filters.exclude_paired_reports" -------------

	err = runtime.BindQueryParameter("form", true, false, "filters.exclude_paired_reports", r.URL.Query(), &params.FiltersExcludePairedReports)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "filters.exclude_paired_reports", Err: err})
		return
	}

	// ------------- Optional query parameter "filters.exclude_atypical" -------------

	err = runtime.BindQueryParameter("form", true, false, "filters.exclude_atypical", r.URL.Query(), &params.FiltersExcludeAtypical)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "filters.exclude_atypical", Err: err})
		return
	}

	// ------------- Optional query parameter "filters.assembly_version" -------------

	err = runtime.BindQueryParameter("form", true, false, "filters.assembly_version", r.URL.Query(), &params.FiltersAssemblyVersion)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "filters.assembly_version", Err: err})
		return
	}

	// ------------- Optional query parameter "filters.assembly_level" -------------

	err = runtime.BindQueryParameter("form", true, false, "filters.assembly_level", r.URL.Query(), &params.FiltersAssemblyLevel)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "filters.assembly_level", Err: err})
		return
	}

	// ------------- Optional query parameter "filters.first_release_date" -------------

	err = runtime.BindQueryParameter("form", true, false, "filters.first_release_date", r.URL.Query(), &params.FiltersFirstReleaseDate)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "filters.first_release_date", Err: err})
		return
	}

	// ------------- Optional query parameter "filters.last_release_date" -------------

	err = runtime.BindQueryParameter("form", true, false, "filters.last_release_date", r.URL.Query(), &params.FiltersLastReleaseDate)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "filters.last_release_date", Err: err})
		return
	}

	// ------------- Optional query parameter "filters.search_text" -------------

	err = runtime.BindQueryParameter("form", true, false, "filters.search_text", r.URL.Query(), &params.FiltersSearchText)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "filters.search_text", Err: err})
		return
	}

	// ------------- Optional query parameter "filters.is_metagenome_derived" -------------

	err = runtime.BindQueryParameter("form", true, false, "filters.is_metagenome_derived", r.URL.Query(), &params.FiltersIsMetagenomeDerived)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "filters.is_metagenome_derived", Err: err})
		return
	}

	// ------------- Optional query parameter "filters.is_type_material" -------------

	err = runtime.BindQueryParameter("form", true, false, "filters.is_type_material", r.URL.Query(), &params.FiltersIsTypeMaterial)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "filters.is_type_material", Err: err})
		return
	}

	// ------------- Optional query parameter "filters.is_ictv_exemplar" -------------

	err = runtime.BindQueryParameter("form", true, false, "filters.is_ictv_exemplar", r.URL.Query(), &params.FiltersIsIctvExemplar)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "filters.is_ictv_exemplar", Err: err})
		return
	}

	// ------------- Optional query parameter "filters.exclude_multi_isolate" -------------

	err = runtime.BindQueryParameter("form", true, false, "filters.exclude_multi_isolate", r.URL.Query(), &params.FiltersExcludeMultiIsolate)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "filters.exclude_multi_isolate", Err: err})
		return
	}

	// ------------- Optional query parameter "filters.type_material_category" -------------

	err = runtime.BindQueryParameter("form", true, false, "filters.type_material_category", r.URL.Query(), &params.FiltersTypeMaterialCategory)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "filters.type_material_category", Err: err})
		return
	}

	// ------------- Optional query parameter "tax_exact_match" -------------

	err = runtime.BindQueryParameter("form", true, false, "tax_exact_match", r.URL.Query(), &params.TaxExactMatch)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "tax_exact_match", Err: err})
		return
	}

	// ------------- Optional query parameter "table_fields" -------------

	err = runtime.BindQueryParameter("form", true, false, "table_fields", r.URL.Query(), &params.TableFields)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "table_fields", Err: err})
		return
	}

	// ------------- Optional query parameter "returned_content" -------------

	err = runtime.BindQueryParameter("form", true, false, "returned_content", r.URL.Query(), &params.ReturnedContent)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "returned_content", Err: err})
		return
	}

	// ------------- Optional query parameter "page_size" -------------

	err = runtime.BindQueryParameter("form", true, false, "page_size", r.URL.Query(), &params.PageSize)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "page_size", Err: err})
		return
	}

	// ------------- Optional query parameter "page_token" -------------

	err = runtime.BindQueryParameter("form", true, false, "page_token", r.URL.Query(), &params.PageToken)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "page_token", Err: err})
		return
	}

	// ------------- Optional query parameter "sort.field" -------------

	err = runtime.BindQueryParameter("form", true, false, "sort.field", r.URL.Query(), &params.SortField)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "sort.field", Err: err})
		return
	}

	// ------------- Optional query parameter "sort.direction" -------------

	err = runtime.BindQueryParameter("form", true, false, "sort.direction", r.URL.Query(), &params.SortDirection)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "sort.direction", Err: err})
		return
	}

	// ------------- Optional query parameter "include_tabular_header" -------------

	err = runtime.BindQueryParameter("form", true, false, "include_tabular_header", r.URL.Query(), &params.IncludeTabularHeader)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "include_tabular_header", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GenomeDatasetReportsByWgs(w, r, wgsAccessions, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// DownloadOrganellePackage operation middleware
func (siw *ServerInterfaceWrapper) DownloadOrganellePackage(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "accessions" -------------
	var accessions []string

	err = runtime.BindStyledParameterWithOptions("simple", "accessions", r.PathValue("accessions"), &accessions, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "accessions", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, ApiKeyAuthHeaderScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params DownloadOrganellePackageParams

	// ------------- Optional query parameter "exclude_sequence" -------------

	err = runtime.BindQueryParameter("form", true, false, "exclude_sequence", r.URL.Query(), &params.ExcludeSequence)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "exclude_sequence", Err: err})
		return
	}

	// ------------- Optional query parameter "include_annotation_type" -------------

	err = runtime.BindQueryParameter("form", true, false, "include_annotation_type", r.URL.Query(), &params.IncludeAnnotationType)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "include_annotation_type", Err: err})
		return
	}

	// ------------- Optional query parameter "filename" -------------

	err = runtime.BindQueryParameter("form", true, false, "filename", r.URL.Query(), &params.Filename)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "filename", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DownloadOrganellePackage(w, r, accessions, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// OrganelleDatareportByAccession operation middleware
func (siw *ServerInterfaceWrapper) OrganelleDatareportByAccession(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "accessions" -------------
	var accessions []string

	err = runtime.BindStyledParameterWithOptions("simple", "accessions", r.PathValue("accessions"), &accessions, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "accessions", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, ApiKeyAuthHeaderScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params OrganelleDatareportByAccessionParams

	// ------------- Optional query parameter "taxons" -------------

	err = runtime.BindQueryParameter("form", true, false, "taxons", r.URL.Query(), &params.Taxons)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "taxons", Err: err})
		return
	}

	// ------------- Optional query parameter "organelle_types" -------------

	err = runtime.BindQueryParameter("form", true, false, "organelle_types", r.URL.Query(), &params.OrganelleTypes)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "organelle_types", Err: err})
		return
	}

	// ------------- Optional query parameter "first_release_date" -------------

	err = runtime.BindQueryParameter("form", true, false, "first_release_date", r.URL.Query(), &params.FirstReleaseDate)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "first_release_date", Err: err})
		return
	}

	// ------------- Optional query parameter "last_release_date" -------------

	err = runtime.BindQueryParameter("form", true, false, "last_release_date", r.URL.Query(), &params.LastReleaseDate)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "last_release_date", Err: err})
		return
	}

	// ------------- Optional query parameter "tax_exact_match" -------------

	err = runtime.BindQueryParameter("form", true, false, "tax_exact_match", r.URL.Query(), &params.TaxExactMatch)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "tax_exact_match", Err: err})
		return
	}

	// ------------- Optional query parameter "sort.field" -------------

	err = runtime.BindQueryParameter("form", true, false, "sort.field", r.URL.Query(), &params.SortField)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "sort.field", Err: err})
		return
	}

	// ------------- Optional query parameter "sort.direction" -------------

	err = runtime.BindQueryParameter("form", true, false, "sort.direction", r.URL.Query(), &params.SortDirection)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "sort.direction", Err: err})
		return
	}

	// ------------- Optional query parameter "returned_content" -------------

	err = runtime.BindQueryParameter("form", true, false, "returned_content", r.URL.Query(), &params.ReturnedContent)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "returned_content", Err: err})
		return
	}

	// ------------- Optional query parameter "table_format" -------------

	err = runtime.BindQueryParameter("form", true, false, "table_format", r.URL.Query(), &params.TableFormat)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "table_format", Err: err})
		return
	}

	// ------------- Optional query parameter "include_tabular_header" -------------

	err = runtime.BindQueryParameter("form", true, false, "include_tabular_header", r.URL.Query(), &params.IncludeTabularHeader)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "include_tabular_header", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.OrganelleDatareportByAccession(w, r, accessions, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// OrganelleDatareportByPost operation middleware
func (siw *ServerInterfaceWrapper) OrganelleDatareportByPost(w http.ResponseWriter, r *http.Request) {

	ctx := r.Context()

	ctx = context.WithValue(ctx, ApiKeyAuthHeaderScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.OrganelleDatareportByPost(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// DownloadOrganellePackageByPost operation middleware
func (siw *ServerInterfaceWrapper) DownloadOrganellePackageByPost(w http.ResponseWriter, r *http.Request) {

	var err error

	ctx := r.Context()

	ctx = context.WithValue(ctx, ApiKeyAuthHeaderScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params DownloadOrganellePackageByPostParams

	// ------------- Optional query parameter "filename" -------------

	err = runtime.BindQueryParameter("form", true, false, "filename", r.URL.Query(), &params.Filename)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "filename", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DownloadOrganellePackageByPost(w, r, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// OrganelleDatareportByTaxon operation middleware
func (siw *ServerInterfaceWrapper) OrganelleDatareportByTaxon(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "taxons" -------------
	var taxons []string

	err = runtime.BindStyledParameterWithOptions("simple", "taxons", r.PathValue("taxons"), &taxons, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "taxons", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, ApiKeyAuthHeaderScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params OrganelleDatareportByTaxonParams

	// ------------- Optional query parameter "organelle_types" -------------

	err = runtime.BindQueryParameter("form", true, false, "organelle_types", r.URL.Query(), &params.OrganelleTypes)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "organelle_types", Err: err})
		return
	}

	// ------------- Optional query parameter "first_release_date" -------------

	err = runtime.BindQueryParameter("form", true, false, "first_release_date", r.URL.Query(), &params.FirstReleaseDate)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "first_release_date", Err: err})
		return
	}

	// ------------- Optional query parameter "last_release_date" -------------

	err = runtime.BindQueryParameter("form", true, false, "last_release_date", r.URL.Query(), &params.LastReleaseDate)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "last_release_date", Err: err})
		return
	}

	// ------------- Optional query parameter "tax_exact_match" -------------

	err = runtime.BindQueryParameter("form", true, false, "tax_exact_match", r.URL.Query(), &params.TaxExactMatch)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "tax_exact_match", Err: err})
		return
	}

	// ------------- Optional query parameter "sort.field" -------------

	err = runtime.BindQueryParameter("form", true, false, "sort.field", r.URL.Query(), &params.SortField)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "sort.field", Err: err})
		return
	}

	// ------------- Optional query parameter "sort.direction" -------------

	err = runtime.BindQueryParameter("form", true, false, "sort.direction", r.URL.Query(), &params.SortDirection)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "sort.direction", Err: err})
		return
	}

	// ------------- Optional query parameter "returned_content" -------------

	err = runtime.BindQueryParameter("form", true, false, "returned_content", r.URL.Query(), &params.ReturnedContent)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "returned_content", Err: err})
		return
	}

	// ------------- Optional query parameter "page_size" -------------

	err = runtime.BindQueryParameter("form", true, false, "page_size", r.URL.Query(), &params.PageSize)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "page_size", Err: err})
		return
	}

	// ------------- Optional query parameter "page_token" -------------

	err = runtime.BindQueryParameter("form", true, false, "page_token", r.URL.Query(), &params.PageToken)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "page_token", Err: err})
		return
	}

	// ------------- Optional query parameter "table_format" -------------

	err = runtime.BindQueryParameter("form", true, false, "table_format", r.URL.Query(), &params.TableFormat)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "table_format", Err: err})
		return
	}

	// ------------- Optional query parameter "include_tabular_header" -------------

	err = runtime.BindQueryParameter("form", true, false, "include_tabular_header", r.URL.Query(), &params.IncludeTabularHeader)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "include_tabular_header", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.OrganelleDatareportByTaxon(w, r, taxons, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// DownloadProkaryoteGenePackagePost operation middleware
func (siw *ServerInterfaceWrapper) DownloadProkaryoteGenePackagePost(w http.ResponseWriter, r *http.Request) {

	var err error

	ctx := r.Context()

	ctx = context.WithValue(ctx, ApiKeyAuthHeaderScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params DownloadProkaryoteGenePackagePostParams

	// ------------- Optional query parameter "filename" -------------

	err = runtime.BindQueryParameter("form", true, false, "filename", r.URL.Query(), &params.Filename)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "filename", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DownloadProkaryoteGenePackagePost(w, r, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// DownloadProkaryoteGenePackage operation middleware
func (siw *ServerInterfaceWrapper) DownloadProkaryoteGenePackage(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "accessions" -------------
	var accessions []string

	err = runtime.BindStyledParameterWithOptions("simple", "accessions", r.PathValue("accessions"), &accessions, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "accessions", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, ApiKeyAuthHeaderScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params DownloadProkaryoteGenePackageParams

	// ------------- Optional query parameter "include_annotation_type" -------------

	err = runtime.BindQueryParameter("form", true, false, "include_annotation_type", r.URL.Query(), &params.IncludeAnnotationType)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "include_annotation_type", Err: err})
		return
	}

	// ------------- Optional query parameter "gene_flank_config.length" -------------

	err = runtime.BindQueryParameter("form", true, false, "gene_flank_config.length", r.URL.Query(), &params.GeneFlankConfigLength)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "gene_flank_config.length", Err: err})
		return
	}

	// ------------- Optional query parameter "taxon" -------------

	err = runtime.BindQueryParameter("form", true, false, "taxon", r.URL.Query(), &params.Taxon)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "taxon", Err: err})
		return
	}

	// ------------- Optional query parameter "filename" -------------

	err = runtime.BindQueryParameter("form", true, false, "filename", r.URL.Query(), &params.Filename)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "filename", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DownloadProkaryoteGenePackage(w, r, accessions, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// TaxonomyMetadataPost operation middleware
func (siw *ServerInterfaceWrapper) TaxonomyMetadataPost(w http.ResponseWriter, r *http.Request) {

	ctx := r.Context()

	ctx = context.WithValue(ctx, ApiKeyAuthHeaderScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.TaxonomyMetadataPost(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// TaxonomyDataReportPost operation middleware
func (siw *ServerInterfaceWrapper) TaxonomyDataReportPost(w http.ResponseWriter, r *http.Request) {

	ctx := r.Context()

	ctx = context.WithValue(ctx, ApiKeyAuthHeaderScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.TaxonomyDataReportPost(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// DownloadTaxonomyPackageByPost operation middleware
func (siw *ServerInterfaceWrapper) DownloadTaxonomyPackageByPost(w http.ResponseWriter, r *http.Request) {

	var err error

	ctx := r.Context()

	ctx = context.WithValue(ctx, ApiKeyAuthHeaderScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params DownloadTaxonomyPackageByPostParams

	// ------------- Optional query parameter "filename" -------------

	err = runtime.BindQueryParameter("form", true, false, "filename", r.URL.Query(), &params.Filename)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "filename", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DownloadTaxonomyPackageByPost(w, r, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// TaxonomyFilteredSubtreePost operation middleware
func (siw *ServerInterfaceWrapper) TaxonomyFilteredSubtreePost(w http.ResponseWriter, r *http.Request) {

	ctx := r.Context()

	ctx = context.WithValue(ctx, ApiKeyAuthHeaderScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.TaxonomyFilteredSubtreePost(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// TaxonomyImagePost operation middleware
func (siw *ServerInterfaceWrapper) TaxonomyImagePost(w http.ResponseWriter, r *http.Request) {

	ctx := r.Context()

	ctx = context.WithValue(ctx, ApiKeyAuthHeaderScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.TaxonomyImagePost(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// TaxonomyImageMetadataPost operation middleware
func (siw *ServerInterfaceWrapper) TaxonomyImageMetadataPost(w http.ResponseWriter, r *http.Request) {

	ctx := r.Context()

	ctx = context.WithValue(ctx, ApiKeyAuthHeaderScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.TaxonomyImageMetadataPost(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// TaxonomyLinksByPost operation middleware
func (siw *ServerInterfaceWrapper) TaxonomyLinksByPost(w http.ResponseWriter, r *http.Request) {

	ctx := r.Context()

	ctx = context.WithValue(ctx, ApiKeyAuthHeaderScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.TaxonomyLinksByPost(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// TaxonomyNamesPost operation middleware
func (siw *ServerInterfaceWrapper) TaxonomyNamesPost(w http.ResponseWriter, r *http.Request) {

	ctx := r.Context()

	ctx = context.WithValue(ctx, ApiKeyAuthHeaderScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.TaxonomyNamesPost(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// TaxonomyRelatedIdsPost operation middleware
func (siw *ServerInterfaceWrapper) TaxonomyRelatedIdsPost(w http.ResponseWriter, r *http.Request) {

	ctx := r.Context()

	ctx = context.WithValue(ctx, ApiKeyAuthHeaderScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.TaxonomyRelatedIdsPost(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// DownloadTaxonomyPackage operation middleware
func (siw *ServerInterfaceWrapper) DownloadTaxonomyPackage(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "tax_ids" -------------
	var taxIds []int

	err = runtime.BindStyledParameterWithOptions("simple", "tax_ids", r.PathValue("tax_ids"), &taxIds, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "tax_ids", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, ApiKeyAuthHeaderScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params DownloadTaxonomyPackageParams

	// ------------- Optional query parameter "aux_reports" -------------

	err = runtime.BindQueryParameter("form", true, false, "aux_reports", r.URL.Query(), &params.AuxReports)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "aux_reports", Err: err})
		return
	}

	// ------------- Optional query parameter "filename" -------------

	err = runtime.BindQueryParameter("form", true, false, "filename", r.URL.Query(), &params.Filename)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "filename", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DownloadTaxonomyPackage(w, r, taxIds, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// TaxonomyRelatedIds operation middleware
func (siw *ServerInterfaceWrapper) TaxonomyRelatedIds(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "tax_id" -------------
	var taxId int

	err = runtime.BindStyledParameterWithOptions("simple", "tax_id", r.PathValue("tax_id"), &taxId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "tax_id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, ApiKeyAuthHeaderScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params TaxonomyRelatedIdsParams

	// ------------- Optional query parameter "include_lineage" -------------

	err = runtime.BindQueryParameter("form", true, false, "include_lineage", r.URL.Query(), &params.IncludeLineage)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "include_lineage", Err: err})
		return
	}

	// ------------- Optional query parameter "include_subtree" -------------

	err = runtime.BindQueryParameter("form", true, false, "include_subtree", r.URL.Query(), &params.IncludeSubtree)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "include_subtree", Err: err})
		return
	}

	// ------------- Optional query parameter "ranks" -------------

	err = runtime.BindQueryParameter("form", true, false, "ranks", r.URL.Query(), &params.Ranks)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "ranks", Err: err})
		return
	}

	// ------------- Optional query parameter "page_size" -------------

	err = runtime.BindQueryParameter("form", true, false, "page_size", r.URL.Query(), &params.PageSize)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "page_size", Err: err})
		return
	}

	// ------------- Optional query parameter "page_token" -------------

	err = runtime.BindQueryParameter("form", true, false, "page_token", r.URL.Query(), &params.PageToken)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "page_token", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.TaxonomyRelatedIds(w, r, taxId, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// TaxonomyMetadata operation middleware
func (siw *ServerInterfaceWrapper) TaxonomyMetadata(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "taxons" -------------
	var taxons []string

	err = runtime.BindStyledParameterWithOptions("simple", "taxons", r.PathValue("taxons"), &taxons, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "taxons", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, ApiKeyAuthHeaderScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params TaxonomyMetadataParams

	// ------------- Optional query parameter "returned_content" -------------

	err = runtime.BindQueryParameter("form", true, false, "returned_content", r.URL.Query(), &params.ReturnedContent)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "returned_content", Err: err})
		return
	}

	// ------------- Optional query parameter "page_size" -------------

	err = runtime.BindQueryParameter("form", true, false, "page_size", r.URL.Query(), &params.PageSize)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "page_size", Err: err})
		return
	}

	// ------------- Optional query parameter "include_tabular_header" -------------

	err = runtime.BindQueryParameter("form", true, false, "include_tabular_header", r.URL.Query(), &params.IncludeTabularHeader)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "include_tabular_header", Err: err})
		return
	}

	// ------------- Optional query parameter "page_token" -------------

	err = runtime.BindQueryParameter("form", true, false, "page_token", r.URL.Query(), &params.PageToken)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "page_token", Err: err})
		return
	}

	// ------------- Optional query parameter "table_format" -------------

	err = runtime.BindQueryParameter("form", true, false, "table_format", r.URL.Query(), &params.TableFormat)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "table_format", Err: err})
		return
	}

	// ------------- Optional query parameter "children" -------------

	err = runtime.BindQueryParameter("form", true, false, "children", r.URL.Query(), &params.Children)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "children", Err: err})
		return
	}

	// ------------- Optional query parameter "ranks" -------------

	err = runtime.BindQueryParameter("form", true, false, "ranks", r.URL.Query(), &params.Ranks)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "ranks", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.TaxonomyMetadata(w, r, taxons, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// TaxonomyDataReport operation middleware
func (siw *ServerInterfaceWrapper) TaxonomyDataReport(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "taxons" -------------
	var taxons []string

	err = runtime.BindStyledParameterWithOptions("simple", "taxons", r.PathValue("taxons"), &taxons, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "taxons", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, ApiKeyAuthHeaderScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params TaxonomyDataReportParams

	// ------------- Optional query parameter "returned_content" -------------

	err = runtime.BindQueryParameter("form", true, false, "returned_content", r.URL.Query(), &params.ReturnedContent)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "returned_content", Err: err})
		return
	}

	// ------------- Optional query parameter "page_size" -------------

	err = runtime.BindQueryParameter("form", true, false, "page_size", r.URL.Query(), &params.PageSize)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "page_size", Err: err})
		return
	}

	// ------------- Optional query parameter "include_tabular_header" -------------

	err = runtime.BindQueryParameter("form", true, false, "include_tabular_header", r.URL.Query(), &params.IncludeTabularHeader)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "include_tabular_header", Err: err})
		return
	}

	// ------------- Optional query parameter "page_token" -------------

	err = runtime.BindQueryParameter("form", true, false, "page_token", r.URL.Query(), &params.PageToken)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "page_token", Err: err})
		return
	}

	// ------------- Optional query parameter "table_format" -------------

	err = runtime.BindQueryParameter("form", true, false, "table_format", r.URL.Query(), &params.TableFormat)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "table_format", Err: err})
		return
	}

	// ------------- Optional query parameter "children" -------------

	err = runtime.BindQueryParameter("form", true, false, "children", r.URL.Query(), &params.Children)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "children", Err: err})
		return
	}

	// ------------- Optional query parameter "ranks" -------------

	err = runtime.BindQueryParameter("form", true, false, "ranks", r.URL.Query(), &params.Ranks)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "ranks", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.TaxonomyDataReport(w, r, taxons, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// TaxonomyFilteredSubtree operation middleware
func (siw *ServerInterfaceWrapper) TaxonomyFilteredSubtree(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "taxons" -------------
	var taxons []string

	err = runtime.BindStyledParameterWithOptions("simple", "taxons", r.PathValue("taxons"), &taxons, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "taxons", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, ApiKeyAuthHeaderScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params TaxonomyFilteredSubtreeParams

	// ------------- Optional query parameter "specified_limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "specified_limit", r.URL.Query(), &params.SpecifiedLimit)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "specified_limit", Err: err})
		return
	}

	// ------------- Optional query parameter "rank_limits" -------------

	err = runtime.BindQueryParameter("form", true, false, "rank_limits", r.URL.Query(), &params.RankLimits)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "rank_limits", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.TaxonomyFilteredSubtree(w, r, taxons, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// TaxonomyNames operation middleware
func (siw *ServerInterfaceWrapper) TaxonomyNames(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "taxons" -------------
	var taxons []string

	err = runtime.BindStyledParameterWithOptions("simple", "taxons", r.PathValue("taxons"), &taxons, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "taxons", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, ApiKeyAuthHeaderScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params TaxonomyNamesParams

	// ------------- Optional query parameter "returned_content" -------------

	err = runtime.BindQueryParameter("form", true, false, "returned_content", r.URL.Query(), &params.ReturnedContent)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "returned_content", Err: err})
		return
	}

	// ------------- Optional query parameter "page_size" -------------

	err = runtime.BindQueryParameter("form", true, false, "page_size", r.URL.Query(), &params.PageSize)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "page_size", Err: err})
		return
	}

	// ------------- Optional query parameter "include_tabular_header" -------------

	err = runtime.BindQueryParameter("form", true, false, "include_tabular_header", r.URL.Query(), &params.IncludeTabularHeader)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "include_tabular_header", Err: err})
		return
	}

	// ------------- Optional query parameter "page_token" -------------

	err = runtime.BindQueryParameter("form", true, false, "page_token", r.URL.Query(), &params.PageToken)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "page_token", Err: err})
		return
	}

	// ------------- Optional query parameter "table_format" -------------

	err = runtime.BindQueryParameter("form", true, false, "table_format", r.URL.Query(), &params.TableFormat)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "table_format", Err: err})
		return
	}

	// ------------- Optional query parameter "children" -------------

	err = runtime.BindQueryParameter("form", true, false, "children", r.URL.Query(), &params.Children)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "children", Err: err})
		return
	}

	// ------------- Optional query parameter "ranks" -------------

	err = runtime.BindQueryParameter("form", true, false, "ranks", r.URL.Query(), &params.Ranks)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "ranks", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.TaxonomyNames(w, r, taxons, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// TaxonomyImage operation middleware
func (siw *ServerInterfaceWrapper) TaxonomyImage(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "taxon" -------------
	var taxon string

	err = runtime.BindStyledParameterWithOptions("simple", "taxon", r.PathValue("taxon"), &taxon, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "taxon", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, ApiKeyAuthHeaderScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params TaxonomyImageParams

	// ------------- Optional query parameter "image_size" -------------

	err = runtime.BindQueryParameter("form", true, false, "image_size", r.URL.Query(), &params.ImageSize)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "image_size", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.TaxonomyImage(w, r, taxon, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// TaxonomyImageMetadata operation middleware
func (siw *ServerInterfaceWrapper) TaxonomyImageMetadata(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "taxon" -------------
	var taxon string

	err = runtime.BindStyledParameterWithOptions("simple", "taxon", r.PathValue("taxon"), &taxon, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "taxon", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, ApiKeyAuthHeaderScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.TaxonomyImageMetadata(w, r, taxon)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// TaxonomyLinks operation middleware
func (siw *ServerInterfaceWrapper) TaxonomyLinks(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "taxon" -------------
	var taxon string

	err = runtime.BindStyledParameterWithOptions("simple", "taxon", r.PathValue("taxon"), &taxon, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "taxon", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, ApiKeyAuthHeaderScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.TaxonomyLinks(w, r, taxon)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// TaxNameQueryByPost operation middleware
func (siw *ServerInterfaceWrapper) TaxNameQueryByPost(w http.ResponseWriter, r *http.Request) {

	ctx := r.Context()

	ctx = context.WithValue(ctx, ApiKeyAuthHeaderScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.TaxNameQueryByPost(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// TaxNameQuery operation middleware
func (siw *ServerInterfaceWrapper) TaxNameQuery(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "taxon_query" -------------
	var taxonQuery string

	err = runtime.BindStyledParameterWithOptions("simple", "taxon_query", r.PathValue("taxon_query"), &taxonQuery, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "taxon_query", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, ApiKeyAuthHeaderScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params TaxNameQueryParams

	// ------------- Optional query parameter "tax_rank_filter" -------------

	err = runtime.BindQueryParameter("form", true, false, "tax_rank_filter", r.URL.Query(), &params.TaxRankFilter)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "tax_rank_filter", Err: err})
		return
	}

	// ------------- Optional query parameter "taxon_resource_filter" -------------

	err = runtime.BindQueryParameter("form", true, false, "taxon_resource_filter", r.URL.Query(), &params.TaxonResourceFilter)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "taxon_resource_filter", Err: err})
		return
	}

	// ------------- Optional query parameter "exact_match" -------------

	err = runtime.BindQueryParameter("form", true, false, "exact_match", r.URL.Query(), &params.ExactMatch)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "exact_match", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.TaxNameQuery(w, r, taxonQuery, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// Version operation middleware
func (siw *ServerInterfaceWrapper) Version(w http.ResponseWriter, r *http.Request) {

	ctx := r.Context()

	ctx = context.WithValue(ctx, ApiKeyAuthHeaderScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.Version(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// VirusReportsByPost operation middleware
func (siw *ServerInterfaceWrapper) VirusReportsByPost(w http.ResponseWriter, r *http.Request) {

	ctx := r.Context()

	ctx = context.WithValue(ctx, ApiKeyAuthHeaderScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.VirusReportsByPost(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// VirusAnnotationReportsByAcessions operation middleware
func (siw *ServerInterfaceWrapper) VirusAnnotationReportsByAcessions(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "accessions" -------------
	var accessions []string

	err = runtime.BindStyledParameterWithOptions("simple", "accessions", r.PathValue("accessions"), &accessions, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "accessions", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, ApiKeyAuthHeaderScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params VirusAnnotationReportsByAcessionsParams

	// ------------- Optional query parameter "filter.refseq_only" -------------

	err = runtime.BindQueryParameter("form", true, false, "filter.refseq_only", r.URL.Query(), &params.FilterRefseqOnly)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "filter.refseq_only", Err: err})
		return
	}

	// ------------- Optional query parameter "filter.released_since" -------------

	err = runtime.BindQueryParameter("form", true, false, "filter.released_since", r.URL.Query(), &params.FilterReleasedSince)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "filter.released_since", Err: err})
		return
	}

	// ------------- Optional query parameter "filter.updated_since" -------------

	err = runtime.BindQueryParameter("form", true, false, "filter.updated_since", r.URL.Query(), &params.FilterUpdatedSince)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "filter.updated_since", Err: err})
		return
	}

	// ------------- Optional query parameter "filter.host" -------------

	err = runtime.BindQueryParameter("form", true, false, "filter.host", r.URL.Query(), &params.FilterHost)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "filter.host", Err: err})
		return
	}

	// ------------- Optional query parameter "filter.pangolin_classification" -------------

	err = runtime.BindQueryParameter("form", true, false, "filter.pangolin_classification", r.URL.Query(), &params.FilterPangolinClassification)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "filter.pangolin_classification", Err: err})
		return
	}

	// ------------- Optional query parameter "filter.geo_location" -------------

	err = runtime.BindQueryParameter("form", true, false, "filter.geo_location", r.URL.Query(), &params.FilterGeoLocation)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "filter.geo_location", Err: err})
		return
	}

	// ------------- Optional query parameter "filter.complete_only" -------------

	err = runtime.BindQueryParameter("form", true, false, "filter.complete_only", r.URL.Query(), &params.FilterCompleteOnly)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "filter.complete_only", Err: err})
		return
	}

	// ------------- Optional query parameter "table_fields" -------------

	err = runtime.BindQueryParameter("form", true, false, "table_fields", r.URL.Query(), &params.TableFields)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "table_fields", Err: err})
		return
	}

	// ------------- Optional query parameter "page_size" -------------

	err = runtime.BindQueryParameter("form", true, false, "page_size", r.URL.Query(), &params.PageSize)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "page_size", Err: err})
		return
	}

	// ------------- Optional query parameter "page_token" -------------

	err = runtime.BindQueryParameter("form", true, false, "page_token", r.URL.Query(), &params.PageToken)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "page_token", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.VirusAnnotationReportsByAcessions(w, r, accessions, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// VirusAccessionAvailability operation middleware
func (siw *ServerInterfaceWrapper) VirusAccessionAvailability(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "accessions" -------------
	var accessions []string

	err = runtime.BindStyledParameterWithOptions("simple", "accessions", r.PathValue("accessions"), &accessions, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "accessions", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, ApiKeyAuthHeaderScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.VirusAccessionAvailability(w, r, accessions)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// VirusReportsByAcessions operation middleware
func (siw *ServerInterfaceWrapper) VirusReportsByAcessions(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "accessions" -------------
	var accessions []string

	err = runtime.BindStyledParameterWithOptions("simple", "accessions", r.PathValue("accessions"), &accessions, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "accessions", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, ApiKeyAuthHeaderScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params VirusReportsByAcessionsParams

	// ------------- Optional query parameter "filter.refseq_only" -------------

	err = runtime.BindQueryParameter("form", true, false, "filter.refseq_only", r.URL.Query(), &params.FilterRefseqOnly)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "filter.refseq_only", Err: err})
		return
	}

	// ------------- Optional query parameter "filter.annotated_only" -------------

	err = runtime.BindQueryParameter("form", true, false, "filter.annotated_only", r.URL.Query(), &params.FilterAnnotatedOnly)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "filter.annotated_only", Err: err})
		return
	}

	// ------------- Optional query parameter "filter.released_since" -------------

	err = runtime.BindQueryParameter("form", true, false, "filter.released_since", r.URL.Query(), &params.FilterReleasedSince)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "filter.released_since", Err: err})
		return
	}

	// ------------- Optional query parameter "filter.updated_since" -------------

	err = runtime.BindQueryParameter("form", true, false, "filter.updated_since", r.URL.Query(), &params.FilterUpdatedSince)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "filter.updated_since", Err: err})
		return
	}

	// ------------- Optional query parameter "filter.host" -------------

	err = runtime.BindQueryParameter("form", true, false, "filter.host", r.URL.Query(), &params.FilterHost)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "filter.host", Err: err})
		return
	}

	// ------------- Optional query parameter "filter.pangolin_classification" -------------

	err = runtime.BindQueryParameter("form", true, false, "filter.pangolin_classification", r.URL.Query(), &params.FilterPangolinClassification)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "filter.pangolin_classification", Err: err})
		return
	}

	// ------------- Optional query parameter "filter.geo_location" -------------

	err = runtime.BindQueryParameter("form", true, false, "filter.geo_location", r.URL.Query(), &params.FilterGeoLocation)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "filter.geo_location", Err: err})
		return
	}

	// ------------- Optional query parameter "filter.complete_only" -------------

	err = runtime.BindQueryParameter("form", true, false, "filter.complete_only", r.URL.Query(), &params.FilterCompleteOnly)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "filter.complete_only", Err: err})
		return
	}

	// ------------- Optional query parameter "returned_content" -------------

	err = runtime.BindQueryParameter("form", true, false, "returned_content", r.URL.Query(), &params.ReturnedContent)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "returned_content", Err: err})
		return
	}

	// ------------- Optional query parameter "table_fields" -------------

	err = runtime.BindQueryParameter("form", true, false, "table_fields", r.URL.Query(), &params.TableFields)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "table_fields", Err: err})
		return
	}

	// ------------- Optional query parameter "page_size" -------------

	err = runtime.BindQueryParameter("form", true, false, "page_size", r.URL.Query(), &params.PageSize)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "page_size", Err: err})
		return
	}

	// ------------- Optional query parameter "page_token" -------------

	err = runtime.BindQueryParameter("form", true, false, "page_token", r.URL.Query(), &params.PageToken)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "page_token", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.VirusReportsByAcessions(w, r, accessions, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// VirusGenomeDownloadAccession operation middleware
func (siw *ServerInterfaceWrapper) VirusGenomeDownloadAccession(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "accessions" -------------
	var accessions []string

	err = runtime.BindStyledParameterWithOptions("simple", "accessions", r.PathValue("accessions"), &accessions, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "accessions", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, ApiKeyAuthHeaderScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params VirusGenomeDownloadAccessionParams

	// ------------- Optional query parameter "refseq_only" -------------

	err = runtime.BindQueryParameter("form", true, false, "refseq_only", r.URL.Query(), &params.RefseqOnly)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "refseq_only", Err: err})
		return
	}

	// ------------- Optional query parameter "annotated_only" -------------

	err = runtime.BindQueryParameter("form", true, false, "annotated_only", r.URL.Query(), &params.AnnotatedOnly)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "annotated_only", Err: err})
		return
	}

	// ------------- Optional query parameter "released_since" -------------

	err = runtime.BindQueryParameter("form", true, false, "released_since", r.URL.Query(), &params.ReleasedSince)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "released_since", Err: err})
		return
	}

	// ------------- Optional query parameter "updated_since" -------------

	err = runtime.BindQueryParameter("form", true, false, "updated_since", r.URL.Query(), &params.UpdatedSince)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "updated_since", Err: err})
		return
	}

	// ------------- Optional query parameter "host" -------------

	err = runtime.BindQueryParameter("form", true, false, "host", r.URL.Query(), &params.Host)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "host", Err: err})
		return
	}

	// ------------- Optional query parameter "pangolin_classification" -------------

	err = runtime.BindQueryParameter("form", true, false, "pangolin_classification", r.URL.Query(), &params.PangolinClassification)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "pangolin_classification", Err: err})
		return
	}

	// ------------- Optional query parameter "geo_location" -------------

	err = runtime.BindQueryParameter("form", true, false, "geo_location", r.URL.Query(), &params.GeoLocation)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "geo_location", Err: err})
		return
	}

	// ------------- Optional query parameter "complete_only" -------------

	err = runtime.BindQueryParameter("form", true, false, "complete_only", r.URL.Query(), &params.CompleteOnly)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "complete_only", Err: err})
		return
	}

	// ------------- Optional query parameter "include_sequence" -------------

	err = runtime.BindQueryParameter("form", true, false, "include_sequence", r.URL.Query(), &params.IncludeSequence)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "include_sequence", Err: err})
		return
	}

	// ------------- Optional query parameter "aux_report" -------------

	err = runtime.BindQueryParameter("form", true, false, "aux_report", r.URL.Query(), &params.AuxReport)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "aux_report", Err: err})
		return
	}

	// ------------- Optional query parameter "use_psg" -------------

	err = runtime.BindQueryParameter("form", true, false, "use_psg", r.URL.Query(), &params.UsePsg)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "use_psg", Err: err})
		return
	}

	// ------------- Optional query parameter "filename" -------------

	err = runtime.BindQueryParameter("form", true, false, "filename", r.URL.Query(), &params.Filename)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "filename", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.VirusGenomeDownloadAccession(w, r, accessions, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// VirusAnnotationReportsByPost operation middleware
func (siw *ServerInterfaceWrapper) VirusAnnotationReportsByPost(w http.ResponseWriter, r *http.Request) {

	ctx := r.Context()

	ctx = context.WithValue(ctx, ApiKeyAuthHeaderScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.VirusAnnotationReportsByPost(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// VirusAccessionAvailabilityPost operation middleware
func (siw *ServerInterfaceWrapper) VirusAccessionAvailabilityPost(w http.ResponseWriter, r *http.Request) {

	ctx := r.Context()

	ctx = context.WithValue(ctx, ApiKeyAuthHeaderScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.VirusAccessionAvailabilityPost(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// VirusGenomeSummaryByPost operation middleware
func (siw *ServerInterfaceWrapper) VirusGenomeSummaryByPost(w http.ResponseWriter, r *http.Request) {

	ctx := r.Context()

	ctx = context.WithValue(ctx, ApiKeyAuthHeaderScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.VirusGenomeSummaryByPost(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// VirusGenomeDownloadPost operation middleware
func (siw *ServerInterfaceWrapper) VirusGenomeDownloadPost(w http.ResponseWriter, r *http.Request) {

	var err error

	ctx := r.Context()

	ctx = context.WithValue(ctx, ApiKeyAuthHeaderScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params VirusGenomeDownloadPostParams

	// ------------- Optional query parameter "filename" -------------

	err = runtime.BindQueryParameter("form", true, false, "filename", r.URL.Query(), &params.Filename)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "filename", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.VirusGenomeDownloadPost(w, r, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// Sars2ProteinSummaryByPost operation middleware
func (siw *ServerInterfaceWrapper) Sars2ProteinSummaryByPost(w http.ResponseWriter, r *http.Request) {

	ctx := r.Context()

	ctx = context.WithValue(ctx, ApiKeyAuthHeaderScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.Sars2ProteinSummaryByPost(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// Sars2ProteinDownloadPost operation middleware
func (siw *ServerInterfaceWrapper) Sars2ProteinDownloadPost(w http.ResponseWriter, r *http.Request) {

	var err error

	ctx := r.Context()

	ctx = context.WithValue(ctx, ApiKeyAuthHeaderScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params Sars2ProteinDownloadPostParams

	// ------------- Optional query parameter "filename" -------------

	err = runtime.BindQueryParameter("form", true, false, "filename", r.URL.Query(), &params.Filename)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "filename", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.Sars2ProteinDownloadPost(w, r, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// Sars2ProteinSummary operation middleware
func (siw *ServerInterfaceWrapper) Sars2ProteinSummary(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "proteins" -------------
	var proteins []string

	err = runtime.BindStyledParameterWithOptions("simple", "proteins", r.PathValue("proteins"), &proteins, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "proteins", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, ApiKeyAuthHeaderScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params Sars2ProteinSummaryParams

	// ------------- Optional query parameter "refseq_only" -------------

	err = runtime.BindQueryParameter("form", true, false, "refseq_only", r.URL.Query(), &params.RefseqOnly)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "refseq_only", Err: err})
		return
	}

	// ------------- Optional query parameter "annotated_only" -------------

	err = runtime.BindQueryParameter("form", true, false, "annotated_only", r.URL.Query(), &params.AnnotatedOnly)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "annotated_only", Err: err})
		return
	}

	// ------------- Optional query parameter "released_since" -------------

	err = runtime.BindQueryParameter("form", true, false, "released_since", r.URL.Query(), &params.ReleasedSince)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "released_since", Err: err})
		return
	}

	// ------------- Optional query parameter "updated_since" -------------

	err = runtime.BindQueryParameter("form", true, false, "updated_since", r.URL.Query(), &params.UpdatedSince)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "updated_since", Err: err})
		return
	}

	// ------------- Optional query parameter "host" -------------

	err = runtime.BindQueryParameter("form", true, false, "host", r.URL.Query(), &params.Host)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "host", Err: err})
		return
	}

	// ------------- Optional query parameter "geo_location" -------------

	err = runtime.BindQueryParameter("form", true, false, "geo_location", r.URL.Query(), &params.GeoLocation)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "geo_location", Err: err})
		return
	}

	// ------------- Optional query parameter "complete_only" -------------

	err = runtime.BindQueryParameter("form", true, false, "complete_only", r.URL.Query(), &params.CompleteOnly)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "complete_only", Err: err})
		return
	}

	// ------------- Optional query parameter "include_sequence" -------------

	err = runtime.BindQueryParameter("form", true, false, "include_sequence", r.URL.Query(), &params.IncludeSequence)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "include_sequence", Err: err})
		return
	}

	// ------------- Optional query parameter "aux_report" -------------

	err = runtime.BindQueryParameter("form", true, false, "aux_report", r.URL.Query(), &params.AuxReport)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "aux_report", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.Sars2ProteinSummary(w, r, proteins, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// Sars2ProteinDownload operation middleware
func (siw *ServerInterfaceWrapper) Sars2ProteinDownload(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "proteins" -------------
	var proteins []string

	err = runtime.BindStyledParameterWithOptions("simple", "proteins", r.PathValue("proteins"), &proteins, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "proteins", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, ApiKeyAuthHeaderScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params Sars2ProteinDownloadParams

	// ------------- Optional query parameter "refseq_only" -------------

	err = runtime.BindQueryParameter("form", true, false, "refseq_only", r.URL.Query(), &params.RefseqOnly)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "refseq_only", Err: err})
		return
	}

	// ------------- Optional query parameter "annotated_only" -------------

	err = runtime.BindQueryParameter("form", true, false, "annotated_only", r.URL.Query(), &params.AnnotatedOnly)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "annotated_only", Err: err})
		return
	}

	// ------------- Optional query parameter "released_since" -------------

	err = runtime.BindQueryParameter("form", true, false, "released_since", r.URL.Query(), &params.ReleasedSince)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "released_since", Err: err})
		return
	}

	// ------------- Optional query parameter "updated_since" -------------

	err = runtime.BindQueryParameter("form", true, false, "updated_since", r.URL.Query(), &params.UpdatedSince)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "updated_since", Err: err})
		return
	}

	// ------------- Optional query parameter "host" -------------

	err = runtime.BindQueryParameter("form", true, false, "host", r.URL.Query(), &params.Host)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "host", Err: err})
		return
	}

	// ------------- Optional query parameter "geo_location" -------------

	err = runtime.BindQueryParameter("form", true, false, "geo_location", r.URL.Query(), &params.GeoLocation)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "geo_location", Err: err})
		return
	}

	// ------------- Optional query parameter "complete_only" -------------

	err = runtime.BindQueryParameter("form", true, false, "complete_only", r.URL.Query(), &params.CompleteOnly)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "complete_only", Err: err})
		return
	}

	// ------------- Optional query parameter "include_sequence" -------------

	err = runtime.BindQueryParameter("form", true, false, "include_sequence", r.URL.Query(), &params.IncludeSequence)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "include_sequence", Err: err})
		return
	}

	// ------------- Optional query parameter "aux_report" -------------

	err = runtime.BindQueryParameter("form", true, false, "aux_report", r.URL.Query(), &params.AuxReport)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "aux_report", Err: err})
		return
	}

	// ------------- Optional query parameter "filename" -------------

	err = runtime.BindQueryParameter("form", true, false, "filename", r.URL.Query(), &params.Filename)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "filename", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.Sars2ProteinDownload(w, r, proteins, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// Sars2ProteinTable operation middleware
func (siw *ServerInterfaceWrapper) Sars2ProteinTable(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "proteins" -------------
	var proteins []string

	err = runtime.BindStyledParameterWithOptions("simple", "proteins", r.PathValue("proteins"), &proteins, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "proteins", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, ApiKeyAuthHeaderScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params Sars2ProteinTableParams

	// ------------- Optional query parameter "refseq_only" -------------

	err = runtime.BindQueryParameter("form", true, false, "refseq_only", r.URL.Query(), &params.RefseqOnly)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "refseq_only", Err: err})
		return
	}

	// ------------- Optional query parameter "annotated_only" -------------

	err = runtime.BindQueryParameter("form", true, false, "annotated_only", r.URL.Query(), &params.AnnotatedOnly)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "annotated_only", Err: err})
		return
	}

	// ------------- Optional query parameter "released_since" -------------

	err = runtime.BindQueryParameter("form", true, false, "released_since", r.URL.Query(), &params.ReleasedSince)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "released_since", Err: err})
		return
	}

	// ------------- Optional query parameter "updated_since" -------------

	err = runtime.BindQueryParameter("form", true, false, "updated_since", r.URL.Query(), &params.UpdatedSince)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "updated_since", Err: err})
		return
	}

	// ------------- Optional query parameter "host" -------------

	err = runtime.BindQueryParameter("form", true, false, "host", r.URL.Query(), &params.Host)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "host", Err: err})
		return
	}

	// ------------- Optional query parameter "geo_location" -------------

	err = runtime.BindQueryParameter("form", true, false, "geo_location", r.URL.Query(), &params.GeoLocation)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "geo_location", Err: err})
		return
	}

	// ------------- Optional query parameter "complete_only" -------------

	err = runtime.BindQueryParameter("form", true, false, "complete_only", r.URL.Query(), &params.CompleteOnly)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "complete_only", Err: err})
		return
	}

	// ------------- Optional query parameter "table_fields" -------------

	err = runtime.BindQueryParameter("form", true, false, "table_fields", r.URL.Query(), &params.TableFields)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "table_fields", Err: err})
		return
	}

	// ------------- Optional query parameter "include_sequence" -------------

	err = runtime.BindQueryParameter("form", true, false, "include_sequence", r.URL.Query(), &params.IncludeSequence)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "include_sequence", Err: err})
		return
	}

	// ------------- Optional query parameter "aux_report" -------------

	err = runtime.BindQueryParameter("form", true, false, "aux_report", r.URL.Query(), &params.AuxReport)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "aux_report", Err: err})
		return
	}

	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", r.URL.Query(), &params.Format)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "format", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.Sars2ProteinTable(w, r, proteins, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// VirusAnnotationReportsByTaxon operation middleware
func (siw *ServerInterfaceWrapper) VirusAnnotationReportsByTaxon(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "taxon" -------------
	var taxon string

	err = runtime.BindStyledParameterWithOptions("simple", "taxon", r.PathValue("taxon"), &taxon, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "taxon", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, ApiKeyAuthHeaderScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params VirusAnnotationReportsByTaxonParams

	// ------------- Optional query parameter "filter.refseq_only" -------------

	err = runtime.BindQueryParameter("form", true, false, "filter.refseq_only", r.URL.Query(), &params.FilterRefseqOnly)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "filter.refseq_only", Err: err})
		return
	}

	// ------------- Optional query parameter "filter.released_since" -------------

	err = runtime.BindQueryParameter("form", true, false, "filter.released_since", r.URL.Query(), &params.FilterReleasedSince)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "filter.released_since", Err: err})
		return
	}

	// ------------- Optional query parameter "filter.updated_since" -------------

	err = runtime.BindQueryParameter("form", true, false, "filter.updated_since", r.URL.Query(), &params.FilterUpdatedSince)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "filter.updated_since", Err: err})
		return
	}

	// ------------- Optional query parameter "filter.host" -------------

	err = runtime.BindQueryParameter("form", true, false, "filter.host", r.URL.Query(), &params.FilterHost)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "filter.host", Err: err})
		return
	}

	// ------------- Optional query parameter "filter.pangolin_classification" -------------

	err = runtime.BindQueryParameter("form", true, false, "filter.pangolin_classification", r.URL.Query(), &params.FilterPangolinClassification)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "filter.pangolin_classification", Err: err})
		return
	}

	// ------------- Optional query parameter "filter.geo_location" -------------

	err = runtime.BindQueryParameter("form", true, false, "filter.geo_location", r.URL.Query(), &params.FilterGeoLocation)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "filter.geo_location", Err: err})
		return
	}

	// ------------- Optional query parameter "filter.complete_only" -------------

	err = runtime.BindQueryParameter("form", true, false, "filter.complete_only", r.URL.Query(), &params.FilterCompleteOnly)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "filter.complete_only", Err: err})
		return
	}

	// ------------- Optional query parameter "table_fields" -------------

	err = runtime.BindQueryParameter("form", true, false, "table_fields", r.URL.Query(), &params.TableFields)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "table_fields", Err: err})
		return
	}

	// ------------- Optional query parameter "page_size" -------------

	err = runtime.BindQueryParameter("form", true, false, "page_size", r.URL.Query(), &params.PageSize)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "page_size", Err: err})
		return
	}

	// ------------- Optional query parameter "page_token" -------------

	err = runtime.BindQueryParameter("form", true, false, "page_token", r.URL.Query(), &params.PageToken)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "page_token", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.VirusAnnotationReportsByTaxon(w, r, taxon, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// VirusReportsByTaxon operation middleware
func (siw *ServerInterfaceWrapper) VirusReportsByTaxon(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "taxon" -------------
	var taxon string

	err = runtime.BindStyledParameterWithOptions("simple", "taxon", r.PathValue("taxon"), &taxon, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "taxon", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, ApiKeyAuthHeaderScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params VirusReportsByTaxonParams

	// ------------- Optional query parameter "filter.refseq_only" -------------

	err = runtime.BindQueryParameter("form", true, false, "filter.refseq_only", r.URL.Query(), &params.FilterRefseqOnly)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "filter.refseq_only", Err: err})
		return
	}

	// ------------- Optional query parameter "filter.annotated_only" -------------

	err = runtime.BindQueryParameter("form", true, false, "filter.annotated_only", r.URL.Query(), &params.FilterAnnotatedOnly)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "filter.annotated_only", Err: err})
		return
	}

	// ------------- Optional query parameter "filter.released_since" -------------

	err = runtime.BindQueryParameter("form", true, false, "filter.released_since", r.URL.Query(), &params.FilterReleasedSince)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "filter.released_since", Err: err})
		return
	}

	// ------------- Optional query parameter "filter.updated_since" -------------

	err = runtime.BindQueryParameter("form", true, false, "filter.updated_since", r.URL.Query(), &params.FilterUpdatedSince)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "filter.updated_since", Err: err})
		return
	}

	// ------------- Optional query parameter "filter.host" -------------

	err = runtime.BindQueryParameter("form", true, false, "filter.host", r.URL.Query(), &params.FilterHost)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "filter.host", Err: err})
		return
	}

	// ------------- Optional query parameter "filter.pangolin_classification" -------------

	err = runtime.BindQueryParameter("form", true, false, "filter.pangolin_classification", r.URL.Query(), &params.FilterPangolinClassification)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "filter.pangolin_classification", Err: err})
		return
	}

	// ------------- Optional query parameter "filter.geo_location" -------------

	err = runtime.BindQueryParameter("form", true, false, "filter.geo_location", r.URL.Query(), &params.FilterGeoLocation)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "filter.geo_location", Err: err})
		return
	}

	// ------------- Optional query parameter "filter.complete_only" -------------

	err = runtime.BindQueryParameter("form", true, false, "filter.complete_only", r.URL.Query(), &params.FilterCompleteOnly)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "filter.complete_only", Err: err})
		return
	}

	// ------------- Optional query parameter "returned_content" -------------

	err = runtime.BindQueryParameter("form", true, false, "returned_content", r.URL.Query(), &params.ReturnedContent)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "returned_content", Err: err})
		return
	}

	// ------------- Optional query parameter "table_fields" -------------

	err = runtime.BindQueryParameter("form", true, false, "table_fields", r.URL.Query(), &params.TableFields)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "table_fields", Err: err})
		return
	}

	// ------------- Optional query parameter "page_size" -------------

	err = runtime.BindQueryParameter("form", true, false, "page_size", r.URL.Query(), &params.PageSize)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "page_size", Err: err})
		return
	}

	// ------------- Optional query parameter "page_token" -------------

	err = runtime.BindQueryParameter("form", true, false, "page_token", r.URL.Query(), &params.PageToken)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "page_token", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.VirusReportsByTaxon(w, r, taxon, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// VirusGenomeSummary operation middleware
func (siw *ServerInterfaceWrapper) VirusGenomeSummary(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "taxon" -------------
	var taxon string

	err = runtime.BindStyledParameterWithOptions("simple", "taxon", r.PathValue("taxon"), &taxon, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "taxon", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, ApiKeyAuthHeaderScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params VirusGenomeSummaryParams

	// ------------- Optional query parameter "accessions" -------------

	err = runtime.BindQueryParameter("form", true, false, "accessions", r.URL.Query(), &params.Accessions)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "accessions", Err: err})
		return
	}

	// ------------- Optional query parameter "refseq_only" -------------

	err = runtime.BindQueryParameter("form", true, false, "refseq_only", r.URL.Query(), &params.RefseqOnly)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "refseq_only", Err: err})
		return
	}

	// ------------- Optional query parameter "annotated_only" -------------

	err = runtime.BindQueryParameter("form", true, false, "annotated_only", r.URL.Query(), &params.AnnotatedOnly)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "annotated_only", Err: err})
		return
	}

	// ------------- Optional query parameter "released_since" -------------

	err = runtime.BindQueryParameter("form", true, false, "released_since", r.URL.Query(), &params.ReleasedSince)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "released_since", Err: err})
		return
	}

	// ------------- Optional query parameter "updated_since" -------------

	err = runtime.BindQueryParameter("form", true, false, "updated_since", r.URL.Query(), &params.UpdatedSince)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "updated_since", Err: err})
		return
	}

	// ------------- Optional query parameter "host" -------------

	err = runtime.BindQueryParameter("form", true, false, "host", r.URL.Query(), &params.Host)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "host", Err: err})
		return
	}

	// ------------- Optional query parameter "pangolin_classification" -------------

	err = runtime.BindQueryParameter("form", true, false, "pangolin_classification", r.URL.Query(), &params.PangolinClassification)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "pangolin_classification", Err: err})
		return
	}

	// ------------- Optional query parameter "geo_location" -------------

	err = runtime.BindQueryParameter("form", true, false, "geo_location", r.URL.Query(), &params.GeoLocation)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "geo_location", Err: err})
		return
	}

	// ------------- Optional query parameter "complete_only" -------------

	err = runtime.BindQueryParameter("form", true, false, "complete_only", r.URL.Query(), &params.CompleteOnly)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "complete_only", Err: err})
		return
	}

	// ------------- Optional query parameter "include_sequence" -------------

	err = runtime.BindQueryParameter("form", true, false, "include_sequence", r.URL.Query(), &params.IncludeSequence)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "include_sequence", Err: err})
		return
	}

	// ------------- Optional query parameter "aux_report" -------------

	err = runtime.BindQueryParameter("form", true, false, "aux_report", r.URL.Query(), &params.AuxReport)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "aux_report", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.VirusGenomeSummary(w, r, taxon, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// VirusGenomeDownload operation middleware
func (siw *ServerInterfaceWrapper) VirusGenomeDownload(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "taxon" -------------
	var taxon string

	err = runtime.BindStyledParameterWithOptions("simple", "taxon", r.PathValue("taxon"), &taxon, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "taxon", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, ApiKeyAuthHeaderScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params VirusGenomeDownloadParams

	// ------------- Optional query parameter "refseq_only" -------------

	err = runtime.BindQueryParameter("form", true, false, "refseq_only", r.URL.Query(), &params.RefseqOnly)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "refseq_only", Err: err})
		return
	}

	// ------------- Optional query parameter "annotated_only" -------------

	err = runtime.BindQueryParameter("form", true, false, "annotated_only", r.URL.Query(), &params.AnnotatedOnly)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "annotated_only", Err: err})
		return
	}

	// ------------- Optional query parameter "released_since" -------------

	err = runtime.BindQueryParameter("form", true, false, "released_since", r.URL.Query(), &params.ReleasedSince)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "released_since", Err: err})
		return
	}

	// ------------- Optional query parameter "updated_since" -------------

	err = runtime.BindQueryParameter("form", true, false, "updated_since", r.URL.Query(), &params.UpdatedSince)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "updated_since", Err: err})
		return
	}

	// ------------- Optional query parameter "host" -------------

	err = runtime.BindQueryParameter("form", true, false, "host", r.URL.Query(), &params.Host)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "host", Err: err})
		return
	}

	// ------------- Optional query parameter "pangolin_classification" -------------

	err = runtime.BindQueryParameter("form", true, false, "pangolin_classification", r.URL.Query(), &params.PangolinClassification)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "pangolin_classification", Err: err})
		return
	}

	// ------------- Optional query parameter "geo_location" -------------

	err = runtime.BindQueryParameter("form", true, false, "geo_location", r.URL.Query(), &params.GeoLocation)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "geo_location", Err: err})
		return
	}

	// ------------- Optional query parameter "complete_only" -------------

	err = runtime.BindQueryParameter("form", true, false, "complete_only", r.URL.Query(), &params.CompleteOnly)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "complete_only", Err: err})
		return
	}

	// ------------- Optional query parameter "include_sequence" -------------

	err = runtime.BindQueryParameter("form", true, false, "include_sequence", r.URL.Query(), &params.IncludeSequence)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "include_sequence", Err: err})
		return
	}

	// ------------- Optional query parameter "aux_report" -------------

	err = runtime.BindQueryParameter("form", true, false, "aux_report", r.URL.Query(), &params.AuxReport)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "aux_report", Err: err})
		return
	}

	// ------------- Optional query parameter "use_psg" -------------

	err = runtime.BindQueryParameter("form", true, false, "use_psg", r.URL.Query(), &params.UsePsg)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "use_psg", Err: err})
		return
	}

	// ------------- Optional query parameter "filename" -------------

	err = runtime.BindQueryParameter("form", true, false, "filename", r.URL.Query(), &params.Filename)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "filename", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.VirusGenomeDownload(w, r, taxon, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// VirusGenomeTable operation middleware
func (siw *ServerInterfaceWrapper) VirusGenomeTable(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "taxon" -------------
	var taxon string

	err = runtime.BindStyledParameterWithOptions("simple", "taxon", r.PathValue("taxon"), &taxon, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "taxon", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, ApiKeyAuthHeaderScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params VirusGenomeTableParams

	// ------------- Optional query parameter "accessions" -------------

	err = runtime.BindQueryParameter("form", true, false, "accessions", r.URL.Query(), &params.Accessions)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "accessions", Err: err})
		return
	}

	// ------------- Optional query parameter "refseq_only" -------------

	err = runtime.BindQueryParameter("form", true, false, "refseq_only", r.URL.Query(), &params.RefseqOnly)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "refseq_only", Err: err})
		return
	}

	// ------------- Optional query parameter "annotated_only" -------------

	err = runtime.BindQueryParameter("form", true, false, "annotated_only", r.URL.Query(), &params.AnnotatedOnly)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "annotated_only", Err: err})
		return
	}

	// ------------- Optional query parameter "released_since" -------------

	err = runtime.BindQueryParameter("form", true, false, "released_since", r.URL.Query(), &params.ReleasedSince)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "released_since", Err: err})
		return
	}

	// ------------- Optional query parameter "updated_since" -------------

	err = runtime.BindQueryParameter("form", true, false, "updated_since", r.URL.Query(), &params.UpdatedSince)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "updated_since", Err: err})
		return
	}

	// ------------- Optional query parameter "host" -------------

	err = runtime.BindQueryParameter("form", true, false, "host", r.URL.Query(), &params.Host)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "host", Err: err})
		return
	}

	// ------------- Optional query parameter "pangolin_classification" -------------

	err = runtime.BindQueryParameter("form", true, false, "pangolin_classification", r.URL.Query(), &params.PangolinClassification)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "pangolin_classification", Err: err})
		return
	}

	// ------------- Optional query parameter "geo_location" -------------

	err = runtime.BindQueryParameter("form", true, false, "geo_location", r.URL.Query(), &params.GeoLocation)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "geo_location", Err: err})
		return
	}

	// ------------- Optional query parameter "complete_only" -------------

	err = runtime.BindQueryParameter("form", true, false, "complete_only", r.URL.Query(), &params.CompleteOnly)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "complete_only", Err: err})
		return
	}

	// ------------- Optional query parameter "table_fields" -------------

	err = runtime.BindQueryParameter("form", true, false, "table_fields", r.URL.Query(), &params.TableFields)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "table_fields", Err: err})
		return
	}

	// ------------- Optional query parameter "include_sequence" -------------

	err = runtime.BindQueryParameter("form", true, false, "include_sequence", r.URL.Query(), &params.IncludeSequence)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "include_sequence", Err: err})
		return
	}

	// ------------- Optional query parameter "aux_report" -------------

	err = runtime.BindQueryParameter("form", true, false, "aux_report", r.URL.Query(), &params.AuxReport)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "aux_report", Err: err})
		return
	}

	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", r.URL.Query(), &params.Format)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "format", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.VirusGenomeTable(w, r, taxon, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

type UnescapedCookieParamError struct {
	ParamName string
	Err       error
}

func (e *UnescapedCookieParamError) Error() string {
	return fmt.Sprintf("error unescaping cookie parameter '%s'", e.ParamName)
}

func (e *UnescapedCookieParamError) Unwrap() error {
	return e.Err
}

type UnmarshalingParamError struct {
	ParamName string
	Err       error
}

func (e *UnmarshalingParamError) Error() string {
	return fmt.Sprintf("Error unmarshaling parameter %s as JSON: %s", e.ParamName, e.Err.Error())
}

func (e *UnmarshalingParamError) Unwrap() error {
	return e.Err
}

type RequiredParamError struct {
	ParamName string
}

func (e *RequiredParamError) Error() string {
	return fmt.Sprintf("Query argument %s is required, but not found", e.ParamName)
}

type RequiredHeaderError struct {
	ParamName string
	Err       error
}

func (e *RequiredHeaderError) Error() string {
	return fmt.Sprintf("Header parameter %s is required, but not found", e.ParamName)
}

func (e *RequiredHeaderError) Unwrap() error {
	return e.Err
}

type InvalidParamFormatError struct {
	ParamName string
	Err       error
}

func (e *InvalidParamFormatError) Error() string {
	return fmt.Sprintf("Invalid format for parameter %s: %s", e.ParamName, e.Err.Error())
}

func (e *InvalidParamFormatError) Unwrap() error {
	return e.Err
}

type TooManyValuesForParamError struct {
	ParamName string
	Count     int
}

func (e *TooManyValuesForParamError) Error() string {
	return fmt.Sprintf("Expected one value for %s, got %d", e.ParamName, e.Count)
}

// Handler creates http.Handler with routing matching OpenAPI spec.
func Handler(si ServerInterface) http.Handler {
	return HandlerWithOptions(si, StdHTTPServerOptions{})
}

// ServeMux is an abstraction of http.ServeMux.
type ServeMux interface {
	HandleFunc(pattern string, handler func(http.ResponseWriter, *http.Request))
	ServeHTTP(w http.ResponseWriter, r *http.Request)
}

type StdHTTPServerOptions struct {
	BaseURL          string
	BaseRouter       ServeMux
	Middlewares      []MiddlewareFunc
	ErrorHandlerFunc func(w http.ResponseWriter, r *http.Request, err error)
}

// HandlerFromMux creates http.Handler with routing matching OpenAPI spec based on the provided mux.
func HandlerFromMux(si ServerInterface, m ServeMux) http.Handler {
	return HandlerWithOptions(si, StdHTTPServerOptions{
		BaseRouter: m,
	})
}

func HandlerFromMuxWithBaseURL(si ServerInterface, m ServeMux, baseURL string) http.Handler {
	return HandlerWithOptions(si, StdHTTPServerOptions{
		BaseURL:    baseURL,
		BaseRouter: m,
	})
}

// HandlerWithOptions creates http.Handler with additional options
func HandlerWithOptions(si ServerInterface, options StdHTTPServerOptions) http.Handler {
	m := options.BaseRouter

	if m == nil {
		m = http.NewServeMux()
	}
	if options.ErrorHandlerFunc == nil {
		options.ErrorHandlerFunc = func(w http.ResponseWriter, r *http.Request, err error) {
			http.Error(w, err.Error(), http.StatusBadRequest)
		}
	}

	wrapper := ServerInterfaceWrapper{
		Handler:            si,
		HandlerMiddlewares: options.Middlewares,
		ErrorHandlerFunc:   options.ErrorHandlerFunc,
	}

	m.HandleFunc("GET "+options.BaseURL+"/biosample/accession/{accessions}/biosample_report", wrapper.BioSampleDatasetReport)
	m.HandleFunc("POST "+options.BaseURL+"/gene", wrapper.GeneMetadataByPost)
	m.HandleFunc("GET "+options.BaseURL+"/gene/accession/{accessions}", wrapper.GeneMetadataByAccession)
	m.HandleFunc("POST "+options.BaseURL+"/gene/download", wrapper.DownloadGenePackagePost)
	m.HandleFunc("POST "+options.BaseURL+"/gene/download_summary", wrapper.GeneDownloadSummaryByPost)
	m.HandleFunc("GET "+options.BaseURL+"/gene/id/{gene_ids}", wrapper.GeneReportsById)
	m.HandleFunc("GET "+options.BaseURL+"/gene/id/{gene_ids}/download", wrapper.DownloadGenePackage)
	m.HandleFunc("GET "+options.BaseURL+"/gene/id/{gene_ids}/download_summary", wrapper.GeneDownloadSummaryById)
	m.HandleFunc("GET "+options.BaseURL+"/gene/id/{gene_ids}/links", wrapper.GeneLinksById)
	m.HandleFunc("GET "+options.BaseURL+"/gene/id/{gene_id}/orthologs", wrapper.GeneOrthologsById)
	m.HandleFunc("POST "+options.BaseURL+"/gene/links", wrapper.GeneLinksByIdByPost)
	m.HandleFunc("POST "+options.BaseURL+"/gene/orthologs", wrapper.GeneOrthologsByPost)
	m.HandleFunc("GET "+options.BaseURL+"/gene/symbol/{symbols}/taxon/{taxon}", wrapper.GeneMetadataByTaxAndSymbol)
	m.HandleFunc("POST "+options.BaseURL+"/gene/taxon/counts", wrapper.GeneCountsForTaxonByPost)
	m.HandleFunc("GET "+options.BaseURL+"/gene/taxon/{taxon}", wrapper.GeneReportsByTaxon)
	m.HandleFunc("GET "+options.BaseURL+"/gene/taxon/{taxon}/annotation/{annotation_name}/chromosome_summary", wrapper.GeneChromosomeSummary)
	m.HandleFunc("GET "+options.BaseURL+"/gene/taxon/{taxon}/counts", wrapper.GeneCountsForTaxon)
	m.HandleFunc("GET "+options.BaseURL+"/genome/accession/{accessions}/check", wrapper.CheckAssemblyAvailability)
	m.HandleFunc("GET "+options.BaseURL+"/genome/accession/{accessions}/dataset_report", wrapper.GenomeDatasetReport)
	m.HandleFunc("GET "+options.BaseURL+"/genome/accession/{accessions}/download", wrapper.DownloadAssemblyPackage)
	m.HandleFunc("GET "+options.BaseURL+"/genome/accession/{accessions}/download_summary", wrapper.GenomeDownloadSummary)
	m.HandleFunc("GET "+options.BaseURL+"/genome/accession/{accessions}/links", wrapper.GenomeLinksByAccession)
	m.HandleFunc("GET "+options.BaseURL+"/genome/accession/{accession}/annotation_report", wrapper.GenomeAnnotationReport)
	m.HandleFunc("GET "+options.BaseURL+"/genome/accession/{accession}/annotation_report/download", wrapper.DownloadGenomeAnnotationPackage)
	m.HandleFunc("GET "+options.BaseURL+"/genome/accession/{accession}/annotation_report/download_summary", wrapper.GenomeAnnotationDownloadSummary)
	m.HandleFunc("GET "+options.BaseURL+"/genome/accession/{accession}/id/{annotation_ids}/annotation_summary", wrapper.AnnotationReportFacets)
	m.HandleFunc("GET "+options.BaseURL+"/genome/accession/{accession}/revision_history", wrapper.AssemblyRevisionHistoryByGet)
	m.HandleFunc("GET "+options.BaseURL+"/genome/accession/{accession}/sequence_reports", wrapper.GenomeSequenceReport)
	m.HandleFunc("POST "+options.BaseURL+"/genome/annotation_report", wrapper.GenomeAnnotationReportByPost)
	m.HandleFunc("POST "+options.BaseURL+"/genome/annotation_report/download", wrapper.DownloadGenomeAnnotationPackageByPost)
	m.HandleFunc("POST "+options.BaseURL+"/genome/annotation_report/download_summary", wrapper.GenomeAnnotationDownloadSummaryByPost)
	m.HandleFunc("POST "+options.BaseURL+"/genome/annotation_summary", wrapper.AnnotationReportFacetsByPost)
	m.HandleFunc("GET "+options.BaseURL+"/genome/assembly_name/{assembly_names}/dataset_report", wrapper.GenomeDatasetReportsByAssemblyName)
	m.HandleFunc("GET "+options.BaseURL+"/genome/bioproject/{bioprojects}/dataset_report", wrapper.GenomeDatasetReportsByBioproject)
	m.HandleFunc("GET "+options.BaseURL+"/genome/biosample/{biosample_ids}/dataset_report", wrapper.GenomeDatasetReportsByBiosampleId)
	m.HandleFunc("POST "+options.BaseURL+"/genome/check", wrapper.CheckAssemblyAvailabilityPost)
	m.HandleFunc("POST "+options.BaseURL+"/genome/checkm_histogram", wrapper.CheckmHistogramByTaxonByPost)
	m.HandleFunc("POST "+options.BaseURL+"/genome/dataset_report", wrapper.GenomeDatasetReportByPost)
	m.HandleFunc("POST "+options.BaseURL+"/genome/download", wrapper.DownloadAssemblyPackagePost)
	m.HandleFunc("POST "+options.BaseURL+"/genome/download_summary", wrapper.GenomeDownloadSummaryByPost)
	m.HandleFunc("POST "+options.BaseURL+"/genome/links", wrapper.GenomeLinksByAccessionByPost)
	m.HandleFunc("POST "+options.BaseURL+"/genome/revision_history", wrapper.AssemblyRevisionHistoryByPost)
	m.HandleFunc("GET "+options.BaseURL+"/genome/sequence_accession/{accession}/sequence_assemblies", wrapper.AssemblyAccessionsForSequenceAccession)
	m.HandleFunc("POST "+options.BaseURL+"/genome/sequence_assemblies", wrapper.AssemblyAccessionsForSequenceAccessionByPost)
	m.HandleFunc("POST "+options.BaseURL+"/genome/sequence_reports", wrapper.GenomeSequenceReportByPost)
	m.HandleFunc("GET "+options.BaseURL+"/genome/taxon/{species_taxon}/checkm_histogram", wrapper.CheckmHistogramByTaxon)
	m.HandleFunc("GET "+options.BaseURL+"/genome/taxon/{taxons}/dataset_report", wrapper.GenomeDatasetReportsByTaxon)
	m.HandleFunc("GET "+options.BaseURL+"/genome/wgs/{wgs_accessions}/dataset_report", wrapper.GenomeDatasetReportsByWgs)
	m.HandleFunc("GET "+options.BaseURL+"/organelle/accession/{accessions}/download", wrapper.DownloadOrganellePackage)
	m.HandleFunc("GET "+options.BaseURL+"/organelle/accessions/{accessions}/dataset_report", wrapper.OrganelleDatareportByAccession)
	m.HandleFunc("POST "+options.BaseURL+"/organelle/dataset_report", wrapper.OrganelleDatareportByPost)
	m.HandleFunc("POST "+options.BaseURL+"/organelle/download", wrapper.DownloadOrganellePackageByPost)
	m.HandleFunc("GET "+options.BaseURL+"/organelle/taxon/{taxons}/dataset_report", wrapper.OrganelleDatareportByTaxon)
	m.HandleFunc("POST "+options.BaseURL+"/protein/accession/download", wrapper.DownloadProkaryoteGenePackagePost)
	m.HandleFunc("GET "+options.BaseURL+"/protein/accession/{accessions}/download", wrapper.DownloadProkaryoteGenePackage)
	m.HandleFunc("POST "+options.BaseURL+"/taxonomy", wrapper.TaxonomyMetadataPost)
	m.HandleFunc("POST "+options.BaseURL+"/taxonomy/dataset_report", wrapper.TaxonomyDataReportPost)
	m.HandleFunc("POST "+options.BaseURL+"/taxonomy/download", wrapper.DownloadTaxonomyPackageByPost)
	m.HandleFunc("POST "+options.BaseURL+"/taxonomy/filtered_subtree", wrapper.TaxonomyFilteredSubtreePost)
	m.HandleFunc("POST "+options.BaseURL+"/taxonomy/image", wrapper.TaxonomyImagePost)
	m.HandleFunc("POST "+options.BaseURL+"/taxonomy/image/metadata", wrapper.TaxonomyImageMetadataPost)
	m.HandleFunc("POST "+options.BaseURL+"/taxonomy/links", wrapper.TaxonomyLinksByPost)
	m.HandleFunc("POST "+options.BaseURL+"/taxonomy/name_report", wrapper.TaxonomyNamesPost)
	m.HandleFunc("POST "+options.BaseURL+"/taxonomy/related_ids", wrapper.TaxonomyRelatedIdsPost)
	m.HandleFunc("GET "+options.BaseURL+"/taxonomy/taxon/{tax_ids}/download", wrapper.DownloadTaxonomyPackage)
	m.HandleFunc("GET "+options.BaseURL+"/taxonomy/taxon/{tax_id}/related_ids", wrapper.TaxonomyRelatedIds)
	m.HandleFunc("GET "+options.BaseURL+"/taxonomy/taxon/{taxons}", wrapper.TaxonomyMetadata)
	m.HandleFunc("GET "+options.BaseURL+"/taxonomy/taxon/{taxons}/dataset_report", wrapper.TaxonomyDataReport)
	m.HandleFunc("GET "+options.BaseURL+"/taxonomy/taxon/{taxons}/filtered_subtree", wrapper.TaxonomyFilteredSubtree)
	m.HandleFunc("GET "+options.BaseURL+"/taxonomy/taxon/{taxons}/name_report", wrapper.TaxonomyNames)
	m.HandleFunc("GET "+options.BaseURL+"/taxonomy/taxon/{taxon}/image", wrapper.TaxonomyImage)
	m.HandleFunc("GET "+options.BaseURL+"/taxonomy/taxon/{taxon}/image/metadata", wrapper.TaxonomyImageMetadata)
	m.HandleFunc("GET "+options.BaseURL+"/taxonomy/taxon/{taxon}/links", wrapper.TaxonomyLinks)
	m.HandleFunc("POST "+options.BaseURL+"/taxonomy/taxon_suggest", wrapper.TaxNameQueryByPost)
	m.HandleFunc("GET "+options.BaseURL+"/taxonomy/taxon_suggest/{taxon_query}", wrapper.TaxNameQuery)
	m.HandleFunc("GET "+options.BaseURL+"/version", wrapper.Version)
	m.HandleFunc("POST "+options.BaseURL+"/virus", wrapper.VirusReportsByPost)
	m.HandleFunc("GET "+options.BaseURL+"/virus/accession/{accessions}/annotation_report", wrapper.VirusAnnotationReportsByAcessions)
	m.HandleFunc("GET "+options.BaseURL+"/virus/accession/{accessions}/check", wrapper.VirusAccessionAvailability)
	m.HandleFunc("GET "+options.BaseURL+"/virus/accession/{accessions}/dataset_report", wrapper.VirusReportsByAcessions)
	m.HandleFunc("GET "+options.BaseURL+"/virus/accession/{accessions}/genome/download", wrapper.VirusGenomeDownloadAccession)
	m.HandleFunc("POST "+options.BaseURL+"/virus/annotation_report", wrapper.VirusAnnotationReportsByPost)
	m.HandleFunc("POST "+options.BaseURL+"/virus/check", wrapper.VirusAccessionAvailabilityPost)
	m.HandleFunc("POST "+options.BaseURL+"/virus/genome", wrapper.VirusGenomeSummaryByPost)
	m.HandleFunc("POST "+options.BaseURL+"/virus/genome/download", wrapper.VirusGenomeDownloadPost)
	m.HandleFunc("POST "+options.BaseURL+"/virus/taxon/sars2/protein", wrapper.Sars2ProteinSummaryByPost)
	m.HandleFunc("POST "+options.BaseURL+"/virus/taxon/sars2/protein/download", wrapper.Sars2ProteinDownloadPost)
	m.HandleFunc("GET "+options.BaseURL+"/virus/taxon/sars2/protein/{proteins}", wrapper.Sars2ProteinSummary)
	m.HandleFunc("GET "+options.BaseURL+"/virus/taxon/sars2/protein/{proteins}/download", wrapper.Sars2ProteinDownload)
	m.HandleFunc("GET "+options.BaseURL+"/virus/taxon/sars2/protein/{proteins}/table", wrapper.Sars2ProteinTable)
	m.HandleFunc("GET "+options.BaseURL+"/virus/taxon/{taxon}/annotation_report", wrapper.VirusAnnotationReportsByTaxon)
	m.HandleFunc("GET "+options.BaseURL+"/virus/taxon/{taxon}/dataset_report", wrapper.VirusReportsByTaxon)
	m.HandleFunc("GET "+options.BaseURL+"/virus/taxon/{taxon}/genome", wrapper.VirusGenomeSummary)
	m.HandleFunc("GET "+options.BaseURL+"/virus/taxon/{taxon}/genome/download", wrapper.VirusGenomeDownload)
	m.HandleFunc("GET "+options.BaseURL+"/virus/taxon/{taxon}/genome/table", wrapper.VirusGenomeTable)

	return m
}
