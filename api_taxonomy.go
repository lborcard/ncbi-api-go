/*
NCBI Datasets API

### NCBI Datasets is a resource that lets you easily gather data from NCBI. The Datasets version 2 API is still in alpha, and we're updating it often to add new functionality, iron out bugs and enhance usability. For some larger downloads, you may want to download a [dehydrated zip archive](https://www.ncbi.nlm.nih.gov/datasets/docs/v2/how-tos/genomes/large-download/), and retrieve the individual data files at a later time. 

API version: v2alpha
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
	"os"
	"reflect"
)


// TaxonomyApiService TaxonomyApi service
type TaxonomyApiService service

type TaxonomyApiDownloadTaxonomyPackageRequest struct {
	ctx context.Context
	ApiService *TaxonomyApiService
	taxIds []int32
	auxReports *[]V2TaxonomyDatasetRequestTaxonomyReportType
	filename *string
}

// list additional reports to include with download. TAXONOMY_REPORT is included by default.
func (r TaxonomyApiDownloadTaxonomyPackageRequest) AuxReports(auxReports []V2TaxonomyDatasetRequestTaxonomyReportType) TaxonomyApiDownloadTaxonomyPackageRequest {
	r.auxReports = &auxReports
	return r
}

// Output file name.
func (r TaxonomyApiDownloadTaxonomyPackageRequest) Filename(filename string) TaxonomyApiDownloadTaxonomyPackageRequest {
	r.filename = &filename
	return r
}

func (r TaxonomyApiDownloadTaxonomyPackageRequest) Execute() (**os.File, *http.Response, error) {
	return r.ApiService.DownloadTaxonomyPackageExecute(r)
}

/*
DownloadTaxonomyPackage Get a taxonomy data package by tax ID

Download a taxonomy report and names data package.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param taxIds
 @return TaxonomyApiDownloadTaxonomyPackageRequest
*/
func (a *TaxonomyApiService) DownloadTaxonomyPackage(ctx context.Context, taxIds []int32) TaxonomyApiDownloadTaxonomyPackageRequest {
	return TaxonomyApiDownloadTaxonomyPackageRequest{
		ApiService: a,
		ctx: ctx,
		taxIds: taxIds,
	}
}

// Execute executes the request
//  @return *os.File
func (a *TaxonomyApiService) DownloadTaxonomyPackageExecute(r TaxonomyApiDownloadTaxonomyPackageRequest) (**os.File, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  **os.File
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TaxonomyApiService.DownloadTaxonomyPackage")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/taxonomy/taxon/{tax_ids}/download"
	localVarPath = strings.Replace(localVarPath, "{"+"tax_ids"+"}", url.PathEscape(parameterToString(r.taxIds, "csv")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.auxReports != nil {
		t := *r.auxReports
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("aux_reports", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("aux_reports", parameterToString(t, "multi"))
		}
	}
	if r.filename != nil {
		localVarQueryParams.Add("filename", parameterToString(*r.filename, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/zip"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuthHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v RpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type TaxonomyApiDownloadTaxonomyPackageByPostRequest struct {
	ctx context.Context
	ApiService *TaxonomyApiService
	v2TaxonomyDatasetRequest *V2TaxonomyDatasetRequest
	filename *string
}

func (r TaxonomyApiDownloadTaxonomyPackageByPostRequest) V2TaxonomyDatasetRequest(v2TaxonomyDatasetRequest V2TaxonomyDatasetRequest) TaxonomyApiDownloadTaxonomyPackageByPostRequest {
	r.v2TaxonomyDatasetRequest = &v2TaxonomyDatasetRequest
	return r
}

// Output file name.
func (r TaxonomyApiDownloadTaxonomyPackageByPostRequest) Filename(filename string) TaxonomyApiDownloadTaxonomyPackageByPostRequest {
	r.filename = &filename
	return r
}

func (r TaxonomyApiDownloadTaxonomyPackageByPostRequest) Execute() (**os.File, *http.Response, error) {
	return r.ApiService.DownloadTaxonomyPackageByPostExecute(r)
}

/*
DownloadTaxonomyPackageByPost Get a taxonomy data package by tax_id

Download a taxonomy report and names data package.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return TaxonomyApiDownloadTaxonomyPackageByPostRequest
*/
func (a *TaxonomyApiService) DownloadTaxonomyPackageByPost(ctx context.Context) TaxonomyApiDownloadTaxonomyPackageByPostRequest {
	return TaxonomyApiDownloadTaxonomyPackageByPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return *os.File
func (a *TaxonomyApiService) DownloadTaxonomyPackageByPostExecute(r TaxonomyApiDownloadTaxonomyPackageByPostRequest) (**os.File, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  **os.File
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TaxonomyApiService.DownloadTaxonomyPackageByPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/taxonomy/download"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.v2TaxonomyDatasetRequest == nil {
		return localVarReturnValue, nil, reportError("v2TaxonomyDatasetRequest is required and must be specified")
	}

	if r.filename != nil {
		localVarQueryParams.Add("filename", parameterToString(*r.filename, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/zip"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.v2TaxonomyDatasetRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuthHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v RpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type TaxonomyApiTaxNameQueryRequest struct {
	ctx context.Context
	ApiService *TaxonomyApiService
	taxonQuery string
	taxRankFilter *V2OrganismQueryRequestTaxRankFilter
	taxonResourceFilter *V2OrganismQueryRequestTaxonResourceFilter
	exactMatch *bool
}

// Set the scope of searched tax ranks when filtering by gene or genome.  Not used for &#39;all&#39;
func (r TaxonomyApiTaxNameQueryRequest) TaxRankFilter(taxRankFilter V2OrganismQueryRequestTaxRankFilter) TaxonomyApiTaxNameQueryRequest {
	r.taxRankFilter = &taxRankFilter
	return r
}

// Limit results to those with gene or genome counts (no filter by default)
func (r TaxonomyApiTaxNameQueryRequest) TaxonResourceFilter(taxonResourceFilter V2OrganismQueryRequestTaxonResourceFilter) TaxonomyApiTaxNameQueryRequest {
	r.taxonResourceFilter = &taxonResourceFilter
	return r
}

// If true, only return results that exactly match the provided name or tax-id
func (r TaxonomyApiTaxNameQueryRequest) ExactMatch(exactMatch bool) TaxonomyApiTaxNameQueryRequest {
	r.exactMatch = &exactMatch
	return r
}

func (r TaxonomyApiTaxNameQueryRequest) Execute() (*V2SciNameAndIds, *http.Response, error) {
	return r.ApiService.TaxNameQueryExecute(r)
}

/*
TaxNameQuery Get a list of taxonomy names and IDs given a partial taxonomic name

This endpoint retrieves a list of taxonomy names and IDs given a possibly partial taxonomic name of any rank.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param taxonQuery NCBI Taxonomy ID or name (common or scientific) at any taxonomic rank
 @return TaxonomyApiTaxNameQueryRequest
*/
func (a *TaxonomyApiService) TaxNameQuery(ctx context.Context, taxonQuery string) TaxonomyApiTaxNameQueryRequest {
	return TaxonomyApiTaxNameQueryRequest{
		ApiService: a,
		ctx: ctx,
		taxonQuery: taxonQuery,
	}
}

// Execute executes the request
//  @return V2SciNameAndIds
func (a *TaxonomyApiService) TaxNameQueryExecute(r TaxonomyApiTaxNameQueryRequest) (*V2SciNameAndIds, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V2SciNameAndIds
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TaxonomyApiService.TaxNameQuery")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/taxonomy/taxon_suggest/{taxon_query}"
	localVarPath = strings.Replace(localVarPath, "{"+"taxon_query"+"}", url.PathEscape(parameterToString(r.taxonQuery, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.taxRankFilter != nil {
		localVarQueryParams.Add("tax_rank_filter", parameterToString(*r.taxRankFilter, ""))
	}
	if r.taxonResourceFilter != nil {
		localVarQueryParams.Add("taxon_resource_filter", parameterToString(*r.taxonResourceFilter, ""))
	}
	if r.exactMatch != nil {
		localVarQueryParams.Add("exact_match", parameterToString(*r.exactMatch, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuthHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v RpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type TaxonomyApiTaxNameQueryByPostRequest struct {
	ctx context.Context
	ApiService *TaxonomyApiService
	v2OrganismQueryRequest *V2OrganismQueryRequest
}

func (r TaxonomyApiTaxNameQueryByPostRequest) V2OrganismQueryRequest(v2OrganismQueryRequest V2OrganismQueryRequest) TaxonomyApiTaxNameQueryByPostRequest {
	r.v2OrganismQueryRequest = &v2OrganismQueryRequest
	return r
}

func (r TaxonomyApiTaxNameQueryByPostRequest) Execute() (*V2SciNameAndIds, *http.Response, error) {
	return r.ApiService.TaxNameQueryByPostExecute(r)
}

/*
TaxNameQueryByPost Get a list of taxonomy names and IDs given a partial taxonomic name

This endpoint retrieves a list of taxonomy names and IDs given a possibly partial taxonomic name of any rank, by post.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return TaxonomyApiTaxNameQueryByPostRequest
*/
func (a *TaxonomyApiService) TaxNameQueryByPost(ctx context.Context) TaxonomyApiTaxNameQueryByPostRequest {
	return TaxonomyApiTaxNameQueryByPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V2SciNameAndIds
func (a *TaxonomyApiService) TaxNameQueryByPostExecute(r TaxonomyApiTaxNameQueryByPostRequest) (*V2SciNameAndIds, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V2SciNameAndIds
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TaxonomyApiService.TaxNameQueryByPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/taxonomy/taxon_suggest"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.v2OrganismQueryRequest == nil {
		return localVarReturnValue, nil, reportError("v2OrganismQueryRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.v2OrganismQueryRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuthHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v RpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type TaxonomyApiTaxonomyDataReportRequest struct {
	ctx context.Context
	ApiService *TaxonomyApiService
	taxons []string
	returnedContent *V2TaxonomyMetadataRequestContentType
	pageSize *int32
	includeTabularHeader *V2IncludeTabularHeader
	pageToken *string
	tableFormat *V2TaxonomyMetadataRequestTableFormat
	children *bool
	ranks *[]V2reportsRankType
}

// Return either tax-ids alone, or entire taxononmy-metadata records
func (r TaxonomyApiTaxonomyDataReportRequest) ReturnedContent(returnedContent V2TaxonomyMetadataRequestContentType) TaxonomyApiTaxonomyDataReportRequest {
	r.returnedContent = &returnedContent
	return r
}

// The maximum number of taxons to return. Default is 20 and maximum is 1000. If the number of results exceeds the page size, &#x60;page_token&#x60; can be used to retrieve the remaining results.
func (r TaxonomyApiTaxonomyDataReportRequest) PageSize(pageSize int32) TaxonomyApiTaxonomyDataReportRequest {
	r.pageSize = &pageSize
	return r
}

// Whether this request for tabular data should include the header row
func (r TaxonomyApiTaxonomyDataReportRequest) IncludeTabularHeader(includeTabularHeader V2IncludeTabularHeader) TaxonomyApiTaxonomyDataReportRequest {
	r.includeTabularHeader = &includeTabularHeader
	return r
}

// A page token is returned from &#x60;GetTaxonomyDataReportFor&#x60; and &#x60;GetTaxonomyNamesDataReportFor&#x60; calls with more than &#x60;page_size&#x60; results. When &#x60;page_token&#x60; is empty, all results have been retrieved.
func (r TaxonomyApiTaxonomyDataReportRequest) PageToken(pageToken string) TaxonomyApiTaxonomyDataReportRequest {
	r.pageToken = &pageToken
	return r
}

func (r TaxonomyApiTaxonomyDataReportRequest) TableFormat(tableFormat V2TaxonomyMetadataRequestTableFormat) TaxonomyApiTaxonomyDataReportRequest {
	r.tableFormat = &tableFormat
	return r
}

// Flag for tax explosion.
func (r TaxonomyApiTaxonomyDataReportRequest) Children(children bool) TaxonomyApiTaxonomyDataReportRequest {
	r.children = &children
	return r
}

// Only include taxons of the provided ranks. If empty, return all ranks.
func (r TaxonomyApiTaxonomyDataReportRequest) Ranks(ranks []V2reportsRankType) TaxonomyApiTaxonomyDataReportRequest {
	r.ranks = &ranks
	return r
}

func (r TaxonomyApiTaxonomyDataReportRequest) Execute() (*V2reportsTaxonomyDataReportPage, *http.Response, error) {
	return r.ApiService.TaxonomyDataReportExecute(r)
}

/*
TaxonomyDataReport Use taxonomic identifiers to get taxonomic data report

Using NCBI Taxonomy IDs or names (common or scientific) at any rank, get metadata about a taxonomic node including taxonomic identifiers, lineage information, child nodes, and gene and genome counts in JSON format.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param taxons
 @return TaxonomyApiTaxonomyDataReportRequest
*/
func (a *TaxonomyApiService) TaxonomyDataReport(ctx context.Context, taxons []string) TaxonomyApiTaxonomyDataReportRequest {
	return TaxonomyApiTaxonomyDataReportRequest{
		ApiService: a,
		ctx: ctx,
		taxons: taxons,
	}
}

// Execute executes the request
//  @return V2reportsTaxonomyDataReportPage
func (a *TaxonomyApiService) TaxonomyDataReportExecute(r TaxonomyApiTaxonomyDataReportRequest) (*V2reportsTaxonomyDataReportPage, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V2reportsTaxonomyDataReportPage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TaxonomyApiService.TaxonomyDataReport")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/taxonomy/taxon/{taxons}/dataset_report"
	localVarPath = strings.Replace(localVarPath, "{"+"taxons"+"}", url.PathEscape(parameterToString(r.taxons, "csv")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.returnedContent != nil {
		localVarQueryParams.Add("returned_content", parameterToString(*r.returnedContent, ""))
	}
	if r.pageSize != nil {
		localVarQueryParams.Add("page_size", parameterToString(*r.pageSize, ""))
	}
	if r.includeTabularHeader != nil {
		localVarQueryParams.Add("include_tabular_header", parameterToString(*r.includeTabularHeader, ""))
	}
	if r.pageToken != nil {
		localVarQueryParams.Add("page_token", parameterToString(*r.pageToken, ""))
	}
	if r.tableFormat != nil {
		localVarQueryParams.Add("table_format", parameterToString(*r.tableFormat, ""))
	}
	if r.children != nil {
		localVarQueryParams.Add("children", parameterToString(*r.children, ""))
	}
	if r.ranks != nil {
		t := *r.ranks
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("ranks", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("ranks", parameterToString(t, "multi"))
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "application/x-ndjson", "text/tab-separated-values"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuthHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v RpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type TaxonomyApiTaxonomyDataReportPostRequest struct {
	ctx context.Context
	ApiService *TaxonomyApiService
	v2TaxonomyMetadataRequest *V2TaxonomyMetadataRequest
}

func (r TaxonomyApiTaxonomyDataReportPostRequest) V2TaxonomyMetadataRequest(v2TaxonomyMetadataRequest V2TaxonomyMetadataRequest) TaxonomyApiTaxonomyDataReportPostRequest {
	r.v2TaxonomyMetadataRequest = &v2TaxonomyMetadataRequest
	return r
}

func (r TaxonomyApiTaxonomyDataReportPostRequest) Execute() (*V2reportsTaxonomyDataReportPage, *http.Response, error) {
	return r.ApiService.TaxonomyDataReportPostExecute(r)
}

/*
TaxonomyDataReportPost Use taxonomic identifiers to get taxonomic names data report by post

Using NCBI Taxonomy IDs or names (common or scientific) at any rank, get metadata about a taxonomic node including taxonomic identifiers, lineage information, child nodes, and gene and genome counts in JSON format.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return TaxonomyApiTaxonomyDataReportPostRequest
*/
func (a *TaxonomyApiService) TaxonomyDataReportPost(ctx context.Context) TaxonomyApiTaxonomyDataReportPostRequest {
	return TaxonomyApiTaxonomyDataReportPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V2reportsTaxonomyDataReportPage
func (a *TaxonomyApiService) TaxonomyDataReportPostExecute(r TaxonomyApiTaxonomyDataReportPostRequest) (*V2reportsTaxonomyDataReportPage, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V2reportsTaxonomyDataReportPage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TaxonomyApiService.TaxonomyDataReportPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/taxonomy/dataset_report"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.v2TaxonomyMetadataRequest == nil {
		return localVarReturnValue, nil, reportError("v2TaxonomyMetadataRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "application/x-ndjson", "text/tab-separated-values"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.v2TaxonomyMetadataRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuthHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v RpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type TaxonomyApiTaxonomyFilteredSubtreeRequest struct {
	ctx context.Context
	ApiService *TaxonomyApiService
	taxons []string
	specifiedLimit *bool
	rankLimits *[]V2reportsRankType
}

// Limit to specified species
func (r TaxonomyApiTaxonomyFilteredSubtreeRequest) SpecifiedLimit(specifiedLimit bool) TaxonomyApiTaxonomyFilteredSubtreeRequest {
	r.specifiedLimit = &specifiedLimit
	return r
}

// Limit to the provided ranks.  If empty, accept any rank.
func (r TaxonomyApiTaxonomyFilteredSubtreeRequest) RankLimits(rankLimits []V2reportsRankType) TaxonomyApiTaxonomyFilteredSubtreeRequest {
	r.rankLimits = &rankLimits
	return r
}

func (r TaxonomyApiTaxonomyFilteredSubtreeRequest) Execute() (*V2TaxonomyFilteredSubtreeResponse, *http.Response, error) {
	return r.ApiService.TaxonomyFilteredSubtreeExecute(r)
}

/*
TaxonomyFilteredSubtree Use taxonomic identifiers to get a filtered taxonomic subtree

Using NCBI Taxonomy IDs or names (common or scientific) at any rank, get a filtered taxonomic subtree that includes the full parent lineage and all immediate children from the selected taxonomic ranks in JSON format.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param taxons
 @return TaxonomyApiTaxonomyFilteredSubtreeRequest
*/
func (a *TaxonomyApiService) TaxonomyFilteredSubtree(ctx context.Context, taxons []string) TaxonomyApiTaxonomyFilteredSubtreeRequest {
	return TaxonomyApiTaxonomyFilteredSubtreeRequest{
		ApiService: a,
		ctx: ctx,
		taxons: taxons,
	}
}

// Execute executes the request
//  @return V2TaxonomyFilteredSubtreeResponse
func (a *TaxonomyApiService) TaxonomyFilteredSubtreeExecute(r TaxonomyApiTaxonomyFilteredSubtreeRequest) (*V2TaxonomyFilteredSubtreeResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V2TaxonomyFilteredSubtreeResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TaxonomyApiService.TaxonomyFilteredSubtree")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/taxonomy/taxon/{taxons}/filtered_subtree"
	localVarPath = strings.Replace(localVarPath, "{"+"taxons"+"}", url.PathEscape(parameterToString(r.taxons, "csv")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.specifiedLimit != nil {
		localVarQueryParams.Add("specified_limit", parameterToString(*r.specifiedLimit, ""))
	}
	if r.rankLimits != nil {
		t := *r.rankLimits
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("rank_limits", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("rank_limits", parameterToString(t, "multi"))
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuthHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v RpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type TaxonomyApiTaxonomyFilteredSubtreePostRequest struct {
	ctx context.Context
	ApiService *TaxonomyApiService
	v2TaxonomyFilteredSubtreeRequest *V2TaxonomyFilteredSubtreeRequest
}

func (r TaxonomyApiTaxonomyFilteredSubtreePostRequest) V2TaxonomyFilteredSubtreeRequest(v2TaxonomyFilteredSubtreeRequest V2TaxonomyFilteredSubtreeRequest) TaxonomyApiTaxonomyFilteredSubtreePostRequest {
	r.v2TaxonomyFilteredSubtreeRequest = &v2TaxonomyFilteredSubtreeRequest
	return r
}

func (r TaxonomyApiTaxonomyFilteredSubtreePostRequest) Execute() (*V2TaxonomyFilteredSubtreeResponse, *http.Response, error) {
	return r.ApiService.TaxonomyFilteredSubtreePostExecute(r)
}

/*
TaxonomyFilteredSubtreePost Use taxonomic identifiers to get a filtered taxonomic subtree by post

Using NCBI Taxonomy IDs or names (common or scientific) at any rank, get a filtered taxonomic subtree that includes the full parent lineage and all immediate children from the selected taxonomic ranks in JSON format.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return TaxonomyApiTaxonomyFilteredSubtreePostRequest
*/
func (a *TaxonomyApiService) TaxonomyFilteredSubtreePost(ctx context.Context) TaxonomyApiTaxonomyFilteredSubtreePostRequest {
	return TaxonomyApiTaxonomyFilteredSubtreePostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V2TaxonomyFilteredSubtreeResponse
func (a *TaxonomyApiService) TaxonomyFilteredSubtreePostExecute(r TaxonomyApiTaxonomyFilteredSubtreePostRequest) (*V2TaxonomyFilteredSubtreeResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V2TaxonomyFilteredSubtreeResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TaxonomyApiService.TaxonomyFilteredSubtreePost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/taxonomy/filtered_subtree"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.v2TaxonomyFilteredSubtreeRequest == nil {
		return localVarReturnValue, nil, reportError("v2TaxonomyFilteredSubtreeRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.v2TaxonomyFilteredSubtreeRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuthHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v RpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type TaxonomyApiTaxonomyImageRequest struct {
	ctx context.Context
	ApiService *TaxonomyApiService
	taxon string
	imageSize *V2ImageSize
}

func (r TaxonomyApiTaxonomyImageRequest) ImageSize(imageSize V2ImageSize) TaxonomyApiTaxonomyImageRequest {
	r.imageSize = &imageSize
	return r
}

func (r TaxonomyApiTaxonomyImageRequest) Execute() (**os.File, *http.Response, error) {
	return r.ApiService.TaxonomyImageExecute(r)
}

/*
TaxonomyImage Retrieve image associated with a taxonomic identifier

Using an NCBI Taxonomy ID or a name (common or scientific) at any rank, get the image associated with the taxon.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param taxon
 @return TaxonomyApiTaxonomyImageRequest
*/
func (a *TaxonomyApiService) TaxonomyImage(ctx context.Context, taxon string) TaxonomyApiTaxonomyImageRequest {
	return TaxonomyApiTaxonomyImageRequest{
		ApiService: a,
		ctx: ctx,
		taxon: taxon,
	}
}

// Execute executes the request
//  @return *os.File
func (a *TaxonomyApiService) TaxonomyImageExecute(r TaxonomyApiTaxonomyImageRequest) (**os.File, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  **os.File
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TaxonomyApiService.TaxonomyImage")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/taxonomy/taxon/{taxon}/image"
	localVarPath = strings.Replace(localVarPath, "{"+"taxon"+"}", url.PathEscape(parameterToString(r.taxon, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.imageSize != nil {
		localVarQueryParams.Add("image_size", parameterToString(*r.imageSize, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "image/jpeg", "image/png", "image/gif", "image/tiff", "image/svg+xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuthHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v RpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type TaxonomyApiTaxonomyImageMetadataRequest struct {
	ctx context.Context
	ApiService *TaxonomyApiService
	taxon string
}

func (r TaxonomyApiTaxonomyImageMetadataRequest) Execute() (*V2TaxonomyImageMetadataResponse, *http.Response, error) {
	return r.ApiService.TaxonomyImageMetadataExecute(r)
}

/*
TaxonomyImageMetadata Retrieve image metadata associated with a taxonomic identifier

Using an NCBI Taxonomy ID or a name (common or scientific) at any rank, get the image metadata associated with the taxon.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param taxon
 @return TaxonomyApiTaxonomyImageMetadataRequest
*/
func (a *TaxonomyApiService) TaxonomyImageMetadata(ctx context.Context, taxon string) TaxonomyApiTaxonomyImageMetadataRequest {
	return TaxonomyApiTaxonomyImageMetadataRequest{
		ApiService: a,
		ctx: ctx,
		taxon: taxon,
	}
}

// Execute executes the request
//  @return V2TaxonomyImageMetadataResponse
func (a *TaxonomyApiService) TaxonomyImageMetadataExecute(r TaxonomyApiTaxonomyImageMetadataRequest) (*V2TaxonomyImageMetadataResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V2TaxonomyImageMetadataResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TaxonomyApiService.TaxonomyImageMetadata")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/taxonomy/taxon/{taxon}/image/metadata"
	localVarPath = strings.Replace(localVarPath, "{"+"taxon"+"}", url.PathEscape(parameterToString(r.taxon, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuthHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v RpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type TaxonomyApiTaxonomyImageMetadataPostRequest struct {
	ctx context.Context
	ApiService *TaxonomyApiService
	v2TaxonomyImageMetadataRequest *V2TaxonomyImageMetadataRequest
}

func (r TaxonomyApiTaxonomyImageMetadataPostRequest) V2TaxonomyImageMetadataRequest(v2TaxonomyImageMetadataRequest V2TaxonomyImageMetadataRequest) TaxonomyApiTaxonomyImageMetadataPostRequest {
	r.v2TaxonomyImageMetadataRequest = &v2TaxonomyImageMetadataRequest
	return r
}

func (r TaxonomyApiTaxonomyImageMetadataPostRequest) Execute() (*V2TaxonomyImageMetadataResponse, *http.Response, error) {
	return r.ApiService.TaxonomyImageMetadataPostExecute(r)
}

/*
TaxonomyImageMetadataPost Retrieve image metadata associated with a taxonomic identifier by post

Using an NCBI Taxonomy ID or a name (common or scientific) at any rank, get the image metadata associated with the taxon.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return TaxonomyApiTaxonomyImageMetadataPostRequest
*/
func (a *TaxonomyApiService) TaxonomyImageMetadataPost(ctx context.Context) TaxonomyApiTaxonomyImageMetadataPostRequest {
	return TaxonomyApiTaxonomyImageMetadataPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V2TaxonomyImageMetadataResponse
func (a *TaxonomyApiService) TaxonomyImageMetadataPostExecute(r TaxonomyApiTaxonomyImageMetadataPostRequest) (*V2TaxonomyImageMetadataResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V2TaxonomyImageMetadataResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TaxonomyApiService.TaxonomyImageMetadataPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/taxonomy/image/metadata"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.v2TaxonomyImageMetadataRequest == nil {
		return localVarReturnValue, nil, reportError("v2TaxonomyImageMetadataRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.v2TaxonomyImageMetadataRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuthHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v RpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type TaxonomyApiTaxonomyImagePostRequest struct {
	ctx context.Context
	ApiService *TaxonomyApiService
	v2TaxonomyImageRequest *V2TaxonomyImageRequest
}

func (r TaxonomyApiTaxonomyImagePostRequest) V2TaxonomyImageRequest(v2TaxonomyImageRequest V2TaxonomyImageRequest) TaxonomyApiTaxonomyImagePostRequest {
	r.v2TaxonomyImageRequest = &v2TaxonomyImageRequest
	return r
}

func (r TaxonomyApiTaxonomyImagePostRequest) Execute() (**os.File, *http.Response, error) {
	return r.ApiService.TaxonomyImagePostExecute(r)
}

/*
TaxonomyImagePost Retrieve image associated with a taxonomic identifier by post

Using an NCBI Taxonomy ID or a name (common or scientific) at any rank, get the image associated with the taxon.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return TaxonomyApiTaxonomyImagePostRequest
*/
func (a *TaxonomyApiService) TaxonomyImagePost(ctx context.Context) TaxonomyApiTaxonomyImagePostRequest {
	return TaxonomyApiTaxonomyImagePostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return *os.File
func (a *TaxonomyApiService) TaxonomyImagePostExecute(r TaxonomyApiTaxonomyImagePostRequest) (**os.File, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  **os.File
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TaxonomyApiService.TaxonomyImagePost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/taxonomy/image"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.v2TaxonomyImageRequest == nil {
		return localVarReturnValue, nil, reportError("v2TaxonomyImageRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "image/jpeg", "image/png", "image/tiff", "image/svg+xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.v2TaxonomyImageRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuthHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v RpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type TaxonomyApiTaxonomyLinksRequest struct {
	ctx context.Context
	ApiService *TaxonomyApiService
	taxon string
}

func (r TaxonomyApiTaxonomyLinksRequest) Execute() (*V2TaxonomyLinksResponse, *http.Response, error) {
	return r.ApiService.TaxonomyLinksExecute(r)
}

/*
TaxonomyLinks Retrieve external links associated with a taxonomic identifier.

Using an NCBI Taxonomy ID at any rank, get the external links associated with the taxon.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param taxon
 @return TaxonomyApiTaxonomyLinksRequest
*/
func (a *TaxonomyApiService) TaxonomyLinks(ctx context.Context, taxon string) TaxonomyApiTaxonomyLinksRequest {
	return TaxonomyApiTaxonomyLinksRequest{
		ApiService: a,
		ctx: ctx,
		taxon: taxon,
	}
}

// Execute executes the request
//  @return V2TaxonomyLinksResponse
func (a *TaxonomyApiService) TaxonomyLinksExecute(r TaxonomyApiTaxonomyLinksRequest) (*V2TaxonomyLinksResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V2TaxonomyLinksResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TaxonomyApiService.TaxonomyLinks")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/taxonomy/taxon/{taxon}/links"
	localVarPath = strings.Replace(localVarPath, "{"+"taxon"+"}", url.PathEscape(parameterToString(r.taxon, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuthHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v RpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type TaxonomyApiTaxonomyLinksByPostRequest struct {
	ctx context.Context
	ApiService *TaxonomyApiService
	v2TaxonomyLinksRequest *V2TaxonomyLinksRequest
}

func (r TaxonomyApiTaxonomyLinksByPostRequest) V2TaxonomyLinksRequest(v2TaxonomyLinksRequest V2TaxonomyLinksRequest) TaxonomyApiTaxonomyLinksByPostRequest {
	r.v2TaxonomyLinksRequest = &v2TaxonomyLinksRequest
	return r
}

func (r TaxonomyApiTaxonomyLinksByPostRequest) Execute() (*V2TaxonomyLinksResponse, *http.Response, error) {
	return r.ApiService.TaxonomyLinksByPostExecute(r)
}

/*
TaxonomyLinksByPost Retrieve external links associated with a taxonomic identifier.

Using an NCBI Taxonomy ID at any rank, get the external links associated with the taxon.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return TaxonomyApiTaxonomyLinksByPostRequest
*/
func (a *TaxonomyApiService) TaxonomyLinksByPost(ctx context.Context) TaxonomyApiTaxonomyLinksByPostRequest {
	return TaxonomyApiTaxonomyLinksByPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V2TaxonomyLinksResponse
func (a *TaxonomyApiService) TaxonomyLinksByPostExecute(r TaxonomyApiTaxonomyLinksByPostRequest) (*V2TaxonomyLinksResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V2TaxonomyLinksResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TaxonomyApiService.TaxonomyLinksByPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/taxonomy/links"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.v2TaxonomyLinksRequest == nil {
		return localVarReturnValue, nil, reportError("v2TaxonomyLinksRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.v2TaxonomyLinksRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuthHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v RpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type TaxonomyApiTaxonomyMetadataRequest struct {
	ctx context.Context
	ApiService *TaxonomyApiService
	taxons []string
	returnedContent *V2TaxonomyMetadataRequestContentType
	pageSize *int32
	includeTabularHeader *V2IncludeTabularHeader
	pageToken *string
	tableFormat *V2TaxonomyMetadataRequestTableFormat
	children *bool
	ranks *[]V2reportsRankType
}

// Return either tax-ids alone, or entire taxononmy-metadata records
func (r TaxonomyApiTaxonomyMetadataRequest) ReturnedContent(returnedContent V2TaxonomyMetadataRequestContentType) TaxonomyApiTaxonomyMetadataRequest {
	r.returnedContent = &returnedContent
	return r
}

// The maximum number of taxons to return. Default is 20 and maximum is 1000. If the number of results exceeds the page size, &#x60;page_token&#x60; can be used to retrieve the remaining results.
func (r TaxonomyApiTaxonomyMetadataRequest) PageSize(pageSize int32) TaxonomyApiTaxonomyMetadataRequest {
	r.pageSize = &pageSize
	return r
}

// Whether this request for tabular data should include the header row
func (r TaxonomyApiTaxonomyMetadataRequest) IncludeTabularHeader(includeTabularHeader V2IncludeTabularHeader) TaxonomyApiTaxonomyMetadataRequest {
	r.includeTabularHeader = &includeTabularHeader
	return r
}

// A page token is returned from &#x60;GetTaxonomyDataReportFor&#x60; and &#x60;GetTaxonomyNamesDataReportFor&#x60; calls with more than &#x60;page_size&#x60; results. When &#x60;page_token&#x60; is empty, all results have been retrieved.
func (r TaxonomyApiTaxonomyMetadataRequest) PageToken(pageToken string) TaxonomyApiTaxonomyMetadataRequest {
	r.pageToken = &pageToken
	return r
}

func (r TaxonomyApiTaxonomyMetadataRequest) TableFormat(tableFormat V2TaxonomyMetadataRequestTableFormat) TaxonomyApiTaxonomyMetadataRequest {
	r.tableFormat = &tableFormat
	return r
}

// Flag for tax explosion.
func (r TaxonomyApiTaxonomyMetadataRequest) Children(children bool) TaxonomyApiTaxonomyMetadataRequest {
	r.children = &children
	return r
}

// Only include taxons of the provided ranks. If empty, return all ranks.
func (r TaxonomyApiTaxonomyMetadataRequest) Ranks(ranks []V2reportsRankType) TaxonomyApiTaxonomyMetadataRequest {
	r.ranks = &ranks
	return r
}

func (r TaxonomyApiTaxonomyMetadataRequest) Execute() (*V2TaxonomyMetadataResponse, *http.Response, error) {
	return r.ApiService.TaxonomyMetadataExecute(r)
}

/*
TaxonomyMetadata Use taxonomic identifiers to get taxonomic metadata

Using NCBI Taxonomy IDs or names (common or scientific) at any rank, get metadata about a taxonomic node including taxonomic identifiers, lineage information, child nodes, and gene and genome counts in JSON format.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param taxons
 @return TaxonomyApiTaxonomyMetadataRequest
*/
func (a *TaxonomyApiService) TaxonomyMetadata(ctx context.Context, taxons []string) TaxonomyApiTaxonomyMetadataRequest {
	return TaxonomyApiTaxonomyMetadataRequest{
		ApiService: a,
		ctx: ctx,
		taxons: taxons,
	}
}

// Execute executes the request
//  @return V2TaxonomyMetadataResponse
func (a *TaxonomyApiService) TaxonomyMetadataExecute(r TaxonomyApiTaxonomyMetadataRequest) (*V2TaxonomyMetadataResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V2TaxonomyMetadataResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TaxonomyApiService.TaxonomyMetadata")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/taxonomy/taxon/{taxons}"
	localVarPath = strings.Replace(localVarPath, "{"+"taxons"+"}", url.PathEscape(parameterToString(r.taxons, "csv")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.returnedContent != nil {
		localVarQueryParams.Add("returned_content", parameterToString(*r.returnedContent, ""))
	}
	if r.pageSize != nil {
		localVarQueryParams.Add("page_size", parameterToString(*r.pageSize, ""))
	}
	if r.includeTabularHeader != nil {
		localVarQueryParams.Add("include_tabular_header", parameterToString(*r.includeTabularHeader, ""))
	}
	if r.pageToken != nil {
		localVarQueryParams.Add("page_token", parameterToString(*r.pageToken, ""))
	}
	if r.tableFormat != nil {
		localVarQueryParams.Add("table_format", parameterToString(*r.tableFormat, ""))
	}
	if r.children != nil {
		localVarQueryParams.Add("children", parameterToString(*r.children, ""))
	}
	if r.ranks != nil {
		t := *r.ranks
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("ranks", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("ranks", parameterToString(t, "multi"))
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuthHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v RpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type TaxonomyApiTaxonomyMetadataPostRequest struct {
	ctx context.Context
	ApiService *TaxonomyApiService
	v2TaxonomyMetadataRequest *V2TaxonomyMetadataRequest
}

func (r TaxonomyApiTaxonomyMetadataPostRequest) V2TaxonomyMetadataRequest(v2TaxonomyMetadataRequest V2TaxonomyMetadataRequest) TaxonomyApiTaxonomyMetadataPostRequest {
	r.v2TaxonomyMetadataRequest = &v2TaxonomyMetadataRequest
	return r
}

func (r TaxonomyApiTaxonomyMetadataPostRequest) Execute() (*V2TaxonomyMetadataResponse, *http.Response, error) {
	return r.ApiService.TaxonomyMetadataPostExecute(r)
}

/*
TaxonomyMetadataPost Use taxonomic identifiers to get taxonomic metadata by post

Using NCBI Taxonomy IDs or names (common or scientific) at any rank, get metadata about a taxonomic node including taxonomic identifiers, lineage information, child nodes, and gene and genome counts in JSON format.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return TaxonomyApiTaxonomyMetadataPostRequest
*/
func (a *TaxonomyApiService) TaxonomyMetadataPost(ctx context.Context) TaxonomyApiTaxonomyMetadataPostRequest {
	return TaxonomyApiTaxonomyMetadataPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V2TaxonomyMetadataResponse
func (a *TaxonomyApiService) TaxonomyMetadataPostExecute(r TaxonomyApiTaxonomyMetadataPostRequest) (*V2TaxonomyMetadataResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V2TaxonomyMetadataResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TaxonomyApiService.TaxonomyMetadataPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/taxonomy"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.v2TaxonomyMetadataRequest == nil {
		return localVarReturnValue, nil, reportError("v2TaxonomyMetadataRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.v2TaxonomyMetadataRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuthHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v RpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type TaxonomyApiTaxonomyNamesRequest struct {
	ctx context.Context
	ApiService *TaxonomyApiService
	taxons []string
	returnedContent *V2TaxonomyMetadataRequestContentType
	pageSize *int32
	includeTabularHeader *V2IncludeTabularHeader
	pageToken *string
	tableFormat *V2TaxonomyMetadataRequestTableFormat
	children *bool
	ranks *[]V2reportsRankType
}

// Return either tax-ids alone, or entire taxononmy-metadata records
func (r TaxonomyApiTaxonomyNamesRequest) ReturnedContent(returnedContent V2TaxonomyMetadataRequestContentType) TaxonomyApiTaxonomyNamesRequest {
	r.returnedContent = &returnedContent
	return r
}

// The maximum number of taxons to return. Default is 20 and maximum is 1000. If the number of results exceeds the page size, &#x60;page_token&#x60; can be used to retrieve the remaining results.
func (r TaxonomyApiTaxonomyNamesRequest) PageSize(pageSize int32) TaxonomyApiTaxonomyNamesRequest {
	r.pageSize = &pageSize
	return r
}

// Whether this request for tabular data should include the header row
func (r TaxonomyApiTaxonomyNamesRequest) IncludeTabularHeader(includeTabularHeader V2IncludeTabularHeader) TaxonomyApiTaxonomyNamesRequest {
	r.includeTabularHeader = &includeTabularHeader
	return r
}

// A page token is returned from &#x60;GetTaxonomyDataReportFor&#x60; and &#x60;GetTaxonomyNamesDataReportFor&#x60; calls with more than &#x60;page_size&#x60; results. When &#x60;page_token&#x60; is empty, all results have been retrieved.
func (r TaxonomyApiTaxonomyNamesRequest) PageToken(pageToken string) TaxonomyApiTaxonomyNamesRequest {
	r.pageToken = &pageToken
	return r
}

func (r TaxonomyApiTaxonomyNamesRequest) TableFormat(tableFormat V2TaxonomyMetadataRequestTableFormat) TaxonomyApiTaxonomyNamesRequest {
	r.tableFormat = &tableFormat
	return r
}

// Flag for tax explosion.
func (r TaxonomyApiTaxonomyNamesRequest) Children(children bool) TaxonomyApiTaxonomyNamesRequest {
	r.children = &children
	return r
}

// Only include taxons of the provided ranks. If empty, return all ranks.
func (r TaxonomyApiTaxonomyNamesRequest) Ranks(ranks []V2reportsRankType) TaxonomyApiTaxonomyNamesRequest {
	r.ranks = &ranks
	return r
}

func (r TaxonomyApiTaxonomyNamesRequest) Execute() (*V2reportsTaxonomyNamesDataReportPage, *http.Response, error) {
	return r.ApiService.TaxonomyNamesExecute(r)
}

/*
TaxonomyNames Use taxonomic identifiers to get taxonomic names data report

Using NCBI Taxonomy IDs or names (common or scientific) at any rank, get metadata about associated taxonomic names.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param taxons
 @return TaxonomyApiTaxonomyNamesRequest
*/
func (a *TaxonomyApiService) TaxonomyNames(ctx context.Context, taxons []string) TaxonomyApiTaxonomyNamesRequest {
	return TaxonomyApiTaxonomyNamesRequest{
		ApiService: a,
		ctx: ctx,
		taxons: taxons,
	}
}

// Execute executes the request
//  @return V2reportsTaxonomyNamesDataReportPage
func (a *TaxonomyApiService) TaxonomyNamesExecute(r TaxonomyApiTaxonomyNamesRequest) (*V2reportsTaxonomyNamesDataReportPage, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V2reportsTaxonomyNamesDataReportPage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TaxonomyApiService.TaxonomyNames")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/taxonomy/taxon/{taxons}/name_report"
	localVarPath = strings.Replace(localVarPath, "{"+"taxons"+"}", url.PathEscape(parameterToString(r.taxons, "csv")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.returnedContent != nil {
		localVarQueryParams.Add("returned_content", parameterToString(*r.returnedContent, ""))
	}
	if r.pageSize != nil {
		localVarQueryParams.Add("page_size", parameterToString(*r.pageSize, ""))
	}
	if r.includeTabularHeader != nil {
		localVarQueryParams.Add("include_tabular_header", parameterToString(*r.includeTabularHeader, ""))
	}
	if r.pageToken != nil {
		localVarQueryParams.Add("page_token", parameterToString(*r.pageToken, ""))
	}
	if r.tableFormat != nil {
		localVarQueryParams.Add("table_format", parameterToString(*r.tableFormat, ""))
	}
	if r.children != nil {
		localVarQueryParams.Add("children", parameterToString(*r.children, ""))
	}
	if r.ranks != nil {
		t := *r.ranks
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("ranks", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("ranks", parameterToString(t, "multi"))
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuthHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v RpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type TaxonomyApiTaxonomyNamesPostRequest struct {
	ctx context.Context
	ApiService *TaxonomyApiService
	v2TaxonomyMetadataRequest *V2TaxonomyMetadataRequest
}

func (r TaxonomyApiTaxonomyNamesPostRequest) V2TaxonomyMetadataRequest(v2TaxonomyMetadataRequest V2TaxonomyMetadataRequest) TaxonomyApiTaxonomyNamesPostRequest {
	r.v2TaxonomyMetadataRequest = &v2TaxonomyMetadataRequest
	return r
}

func (r TaxonomyApiTaxonomyNamesPostRequest) Execute() (*V2reportsTaxonomyNamesDataReportPage, *http.Response, error) {
	return r.ApiService.TaxonomyNamesPostExecute(r)
}

/*
TaxonomyNamesPost Use taxonomic identifiers to get taxonomic names data report by post

Using NCBI Taxonomy IDs or names (common or scientific) at any rank, get metadata about associated taxonomic names.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return TaxonomyApiTaxonomyNamesPostRequest
*/
func (a *TaxonomyApiService) TaxonomyNamesPost(ctx context.Context) TaxonomyApiTaxonomyNamesPostRequest {
	return TaxonomyApiTaxonomyNamesPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V2reportsTaxonomyNamesDataReportPage
func (a *TaxonomyApiService) TaxonomyNamesPostExecute(r TaxonomyApiTaxonomyNamesPostRequest) (*V2reportsTaxonomyNamesDataReportPage, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V2reportsTaxonomyNamesDataReportPage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TaxonomyApiService.TaxonomyNamesPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/taxonomy/name_report"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.v2TaxonomyMetadataRequest == nil {
		return localVarReturnValue, nil, reportError("v2TaxonomyMetadataRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.v2TaxonomyMetadataRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuthHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v RpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type TaxonomyApiTaxonomyRelatedIdsRequest struct {
	ctx context.Context
	ApiService *TaxonomyApiService
	taxId int32
	includeLineage *bool
	includeSubtree *bool
	ranks *[]V2reportsRankType
	pageSize *int32
	pageToken *string
}

// If true, return reports for all taxonomy nodes in the lineages of the requested tax_id
func (r TaxonomyApiTaxonomyRelatedIdsRequest) IncludeLineage(includeLineage bool) TaxonomyApiTaxonomyRelatedIdsRequest {
	r.includeLineage = &includeLineage
	return r
}

// If true, return reports for all taxonomy nodes that are children of the requested tax_ids
func (r TaxonomyApiTaxonomyRelatedIdsRequest) IncludeSubtree(includeSubtree bool) TaxonomyApiTaxonomyRelatedIdsRequest {
	r.includeSubtree = &includeSubtree
	return r
}

// Only include taxons of the provided ranks. If empty, return all ranks.
func (r TaxonomyApiTaxonomyRelatedIdsRequest) Ranks(ranks []V2reportsRankType) TaxonomyApiTaxonomyRelatedIdsRequest {
	r.ranks = &ranks
	return r
}

// The maximum number of taxids to return. Default is 20 and maximum is 1000. If the number of results exceeds the page size, &#x60;page_token&#x60; can be used to retrieve the remaining results.
func (r TaxonomyApiTaxonomyRelatedIdsRequest) PageSize(pageSize int32) TaxonomyApiTaxonomyRelatedIdsRequest {
	r.pageSize = &pageSize
	return r
}

// A page token is returned from a &#x60;GetRelatedTaxids&#x60; call with more than &#x60;page_size&#x60; results. Use this token, along with the previous &#x60;TaxonomyRelatedIdRequest&#x60; parameters, to retrieve the next page of results. When &#x60;page_token&#x60; is empty, all results have been retrieved.
func (r TaxonomyApiTaxonomyRelatedIdsRequest) PageToken(pageToken string) TaxonomyApiTaxonomyRelatedIdsRequest {
	r.pageToken = &pageToken
	return r
}

func (r TaxonomyApiTaxonomyRelatedIdsRequest) Execute() (*V2TaxonomyTaxIdsPage, *http.Response, error) {
	return r.ApiService.TaxonomyRelatedIdsExecute(r)
}

/*
TaxonomyRelatedIds Use taxonomic identifier to get related taxonomic identifiers, such as children

Using a single NCBI Taxonomy ID at any rank, get a list of related taxonomic IDs in JSON format.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param taxId
 @return TaxonomyApiTaxonomyRelatedIdsRequest
*/
func (a *TaxonomyApiService) TaxonomyRelatedIds(ctx context.Context, taxId int32) TaxonomyApiTaxonomyRelatedIdsRequest {
	return TaxonomyApiTaxonomyRelatedIdsRequest{
		ApiService: a,
		ctx: ctx,
		taxId: taxId,
	}
}

// Execute executes the request
//  @return V2TaxonomyTaxIdsPage
func (a *TaxonomyApiService) TaxonomyRelatedIdsExecute(r TaxonomyApiTaxonomyRelatedIdsRequest) (*V2TaxonomyTaxIdsPage, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V2TaxonomyTaxIdsPage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TaxonomyApiService.TaxonomyRelatedIds")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/taxonomy/taxon/{tax_id}/related_ids"
	localVarPath = strings.Replace(localVarPath, "{"+"tax_id"+"}", url.PathEscape(parameterToString(r.taxId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.includeLineage != nil {
		localVarQueryParams.Add("include_lineage", parameterToString(*r.includeLineage, ""))
	}
	if r.includeSubtree != nil {
		localVarQueryParams.Add("include_subtree", parameterToString(*r.includeSubtree, ""))
	}
	if r.ranks != nil {
		t := *r.ranks
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("ranks", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("ranks", parameterToString(t, "multi"))
		}
	}
	if r.pageSize != nil {
		localVarQueryParams.Add("page_size", parameterToString(*r.pageSize, ""))
	}
	if r.pageToken != nil {
		localVarQueryParams.Add("page_token", parameterToString(*r.pageToken, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuthHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v RpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type TaxonomyApiTaxonomyRelatedIdsPostRequest struct {
	ctx context.Context
	ApiService *TaxonomyApiService
	v2TaxonomyRelatedIdRequest *V2TaxonomyRelatedIdRequest
}

func (r TaxonomyApiTaxonomyRelatedIdsPostRequest) V2TaxonomyRelatedIdRequest(v2TaxonomyRelatedIdRequest V2TaxonomyRelatedIdRequest) TaxonomyApiTaxonomyRelatedIdsPostRequest {
	r.v2TaxonomyRelatedIdRequest = &v2TaxonomyRelatedIdRequest
	return r
}

func (r TaxonomyApiTaxonomyRelatedIdsPostRequest) Execute() (*V2TaxonomyTaxIdsPage, *http.Response, error) {
	return r.ApiService.TaxonomyRelatedIdsPostExecute(r)
}

/*
TaxonomyRelatedIdsPost Use taxonomic identifier to get related taxonomic identifiers, such as children

Using a single NCBI Taxonomy ID at any rank, get a list of related taxonomic IDs in JSON format.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return TaxonomyApiTaxonomyRelatedIdsPostRequest
*/
func (a *TaxonomyApiService) TaxonomyRelatedIdsPost(ctx context.Context) TaxonomyApiTaxonomyRelatedIdsPostRequest {
	return TaxonomyApiTaxonomyRelatedIdsPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V2TaxonomyTaxIdsPage
func (a *TaxonomyApiService) TaxonomyRelatedIdsPostExecute(r TaxonomyApiTaxonomyRelatedIdsPostRequest) (*V2TaxonomyTaxIdsPage, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V2TaxonomyTaxIdsPage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TaxonomyApiService.TaxonomyRelatedIdsPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/taxonomy/related_ids"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.v2TaxonomyRelatedIdRequest == nil {
		return localVarReturnValue, nil, reportError("v2TaxonomyRelatedIdRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.v2TaxonomyRelatedIdRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuthHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v RpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
