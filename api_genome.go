/*
NCBI Datasets API

### NCBI Datasets is a resource that lets you easily gather data from NCBI. The Datasets version 2 API is still in alpha, and we're updating it often to add new functionality, iron out bugs and enhance usability. For some larger downloads, you may want to download a [dehydrated zip archive](https://www.ncbi.nlm.nih.gov/datasets/docs/v2/how-tos/genomes/large-download/), and retrieve the individual data files at a later time. 

API version: v2alpha
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package ncbi-openapi-v2_goland

import (
	"bytes"
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
	"os"
	"reflect"
	"time"
)


// GenomeApiService GenomeApi service
type GenomeApiService service

type GenomeApiAnnotationReportFacetsRequest struct {
	ctx context.Context
	ApiService *GenomeApiService
	accession string
	annotationIds []string
	sortField *string
	sortDirection *V2SortDirection
}

func (r GenomeApiAnnotationReportFacetsRequest) SortField(sortField string) GenomeApiAnnotationReportFacetsRequest {
	r.sortField = &sortField
	return r
}

func (r GenomeApiAnnotationReportFacetsRequest) SortDirection(sortDirection V2SortDirection) GenomeApiAnnotationReportFacetsRequest {
	r.sortDirection = &sortDirection
	return r
}

func (r GenomeApiAnnotationReportFacetsRequest) Execute() (*V2GenomeAnnotationTableSummaryReply, *http.Response, error) {
	return r.ApiService.AnnotationReportFacetsExecute(r)
}

/*
AnnotationReportFacets Get genome annotation report summary information

Get genome annotation report summary information by genome accession. The return facets can be used in subsequent queries.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accession
 @param annotationIds Limit the reports by internal, unstable annotation ids.
 @return GenomeApiAnnotationReportFacetsRequest
*/
func (a *GenomeApiService) AnnotationReportFacets(ctx context.Context, accession string, annotationIds []string) GenomeApiAnnotationReportFacetsRequest {
	return GenomeApiAnnotationReportFacetsRequest{
		ApiService: a,
		ctx: ctx,
		accession: accession,
		annotationIds: annotationIds,
	}
}

// Execute executes the request
//  @return V2GenomeAnnotationTableSummaryReply
func (a *GenomeApiService) AnnotationReportFacetsExecute(r GenomeApiAnnotationReportFacetsRequest) (*V2GenomeAnnotationTableSummaryReply, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V2GenomeAnnotationTableSummaryReply
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GenomeApiService.AnnotationReportFacets")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/genome/accession/{accession}/id/{annotation_ids}/annotation_summary"
	localVarPath = strings.Replace(localVarPath, "{"+"accession"+"}", url.PathEscape(parameterToString(r.accession, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"annotation_ids"+"}", url.PathEscape(parameterToString(r.annotationIds, "csv")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.sortField != nil {
		localVarQueryParams.Add("sort.field", parameterToString(*r.sortField, ""))
	}
	if r.sortDirection != nil {
		localVarQueryParams.Add("sort.direction", parameterToString(*r.sortDirection, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuthHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v RpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type GenomeApiAnnotationReportFacetsByPostRequest struct {
	ctx context.Context
	ApiService *GenomeApiService
	v2GenomeAnnotationRequest *V2GenomeAnnotationRequest
}

func (r GenomeApiAnnotationReportFacetsByPostRequest) V2GenomeAnnotationRequest(v2GenomeAnnotationRequest V2GenomeAnnotationRequest) GenomeApiAnnotationReportFacetsByPostRequest {
	r.v2GenomeAnnotationRequest = &v2GenomeAnnotationRequest
	return r
}

func (r GenomeApiAnnotationReportFacetsByPostRequest) Execute() (*V2GenomeAnnotationTableSummaryReply, *http.Response, error) {
	return r.ApiService.AnnotationReportFacetsByPostExecute(r)
}

/*
AnnotationReportFacetsByPost Get genome annotation report summary information

Get genome annotation report summary information by genome accession. The return facets can be used in subsequent queries.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return GenomeApiAnnotationReportFacetsByPostRequest
*/
func (a *GenomeApiService) AnnotationReportFacetsByPost(ctx context.Context) GenomeApiAnnotationReportFacetsByPostRequest {
	return GenomeApiAnnotationReportFacetsByPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V2GenomeAnnotationTableSummaryReply
func (a *GenomeApiService) AnnotationReportFacetsByPostExecute(r GenomeApiAnnotationReportFacetsByPostRequest) (*V2GenomeAnnotationTableSummaryReply, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V2GenomeAnnotationTableSummaryReply
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GenomeApiService.AnnotationReportFacetsByPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/genome/annotation_summary"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.v2GenomeAnnotationRequest == nil {
		return localVarReturnValue, nil, reportError("v2GenomeAnnotationRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.v2GenomeAnnotationRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuthHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v RpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type GenomeApiAssemblyAccessionsForSequenceAccessionRequest struct {
	ctx context.Context
	ApiService *GenomeApiService
	accession string
}

func (r GenomeApiAssemblyAccessionsForSequenceAccessionRequest) Execute() (*V2AssemblyAccessions, *http.Response, error) {
	return r.ApiService.AssemblyAccessionsForSequenceAccessionExecute(r)
}

/*
AssemblyAccessionsForSequenceAccession Get assembly accessions for a sequence accession

Get assembly accessions for a sequence (nucleotide) accession

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accession
 @return GenomeApiAssemblyAccessionsForSequenceAccessionRequest
*/
func (a *GenomeApiService) AssemblyAccessionsForSequenceAccession(ctx context.Context, accession string) GenomeApiAssemblyAccessionsForSequenceAccessionRequest {
	return GenomeApiAssemblyAccessionsForSequenceAccessionRequest{
		ApiService: a,
		ctx: ctx,
		accession: accession,
	}
}

// Execute executes the request
//  @return V2AssemblyAccessions
func (a *GenomeApiService) AssemblyAccessionsForSequenceAccessionExecute(r GenomeApiAssemblyAccessionsForSequenceAccessionRequest) (*V2AssemblyAccessions, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V2AssemblyAccessions
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GenomeApiService.AssemblyAccessionsForSequenceAccession")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/genome/sequence_accession/{accession}/sequence_assemblies"
	localVarPath = strings.Replace(localVarPath, "{"+"accession"+"}", url.PathEscape(parameterToString(r.accession, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuthHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v RpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type GenomeApiAssemblyAccessionsForSequenceAccessionByPostRequest struct {
	ctx context.Context
	ApiService *GenomeApiService
	v2SequenceAccessionRequest *V2SequenceAccessionRequest
}

func (r GenomeApiAssemblyAccessionsForSequenceAccessionByPostRequest) V2SequenceAccessionRequest(v2SequenceAccessionRequest V2SequenceAccessionRequest) GenomeApiAssemblyAccessionsForSequenceAccessionByPostRequest {
	r.v2SequenceAccessionRequest = &v2SequenceAccessionRequest
	return r
}

func (r GenomeApiAssemblyAccessionsForSequenceAccessionByPostRequest) Execute() (*V2AssemblyAccessions, *http.Response, error) {
	return r.ApiService.AssemblyAccessionsForSequenceAccessionByPostExecute(r)
}

/*
AssemblyAccessionsForSequenceAccessionByPost Get assembly accessions for a sequence accession

Get assembly accessions for a sequence (nucleotide) accession

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return GenomeApiAssemblyAccessionsForSequenceAccessionByPostRequest
*/
func (a *GenomeApiService) AssemblyAccessionsForSequenceAccessionByPost(ctx context.Context) GenomeApiAssemblyAccessionsForSequenceAccessionByPostRequest {
	return GenomeApiAssemblyAccessionsForSequenceAccessionByPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V2AssemblyAccessions
func (a *GenomeApiService) AssemblyAccessionsForSequenceAccessionByPostExecute(r GenomeApiAssemblyAccessionsForSequenceAccessionByPostRequest) (*V2AssemblyAccessions, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V2AssemblyAccessions
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GenomeApiService.AssemblyAccessionsForSequenceAccessionByPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/genome/sequence_assemblies"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.v2SequenceAccessionRequest == nil {
		return localVarReturnValue, nil, reportError("v2SequenceAccessionRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.v2SequenceAccessionRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuthHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v RpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type GenomeApiAssemblyRevisionHistoryByGetRequest struct {
	ctx context.Context
	ApiService *GenomeApiService
	accession string
}

func (r GenomeApiAssemblyRevisionHistoryByGetRequest) Execute() (*V2AssemblyRevisionHistory, *http.Response, error) {
	return r.ApiService.AssemblyRevisionHistoryByGetExecute(r)
}

/*
AssemblyRevisionHistoryByGet Get revision history for assembly by accession

Get revision history for assembly by accession

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accession
 @return GenomeApiAssemblyRevisionHistoryByGetRequest
*/
func (a *GenomeApiService) AssemblyRevisionHistoryByGet(ctx context.Context, accession string) GenomeApiAssemblyRevisionHistoryByGetRequest {
	return GenomeApiAssemblyRevisionHistoryByGetRequest{
		ApiService: a,
		ctx: ctx,
		accession: accession,
	}
}

// Execute executes the request
//  @return V2AssemblyRevisionHistory
func (a *GenomeApiService) AssemblyRevisionHistoryByGetExecute(r GenomeApiAssemblyRevisionHistoryByGetRequest) (*V2AssemblyRevisionHistory, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V2AssemblyRevisionHistory
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GenomeApiService.AssemblyRevisionHistoryByGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/genome/accession/{accession}/revision_history"
	localVarPath = strings.Replace(localVarPath, "{"+"accession"+"}", url.PathEscape(parameterToString(r.accession, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuthHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v RpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type GenomeApiAssemblyRevisionHistoryByPostRequest struct {
	ctx context.Context
	ApiService *GenomeApiService
	v2AssemblyRevisionHistoryRequest *V2AssemblyRevisionHistoryRequest
}

func (r GenomeApiAssemblyRevisionHistoryByPostRequest) V2AssemblyRevisionHistoryRequest(v2AssemblyRevisionHistoryRequest V2AssemblyRevisionHistoryRequest) GenomeApiAssemblyRevisionHistoryByPostRequest {
	r.v2AssemblyRevisionHistoryRequest = &v2AssemblyRevisionHistoryRequest
	return r
}

func (r GenomeApiAssemblyRevisionHistoryByPostRequest) Execute() (*V2AssemblyRevisionHistory, *http.Response, error) {
	return r.ApiService.AssemblyRevisionHistoryByPostExecute(r)
}

/*
AssemblyRevisionHistoryByPost Get revision history for assembly by accession



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return GenomeApiAssemblyRevisionHistoryByPostRequest
*/
func (a *GenomeApiService) AssemblyRevisionHistoryByPost(ctx context.Context) GenomeApiAssemblyRevisionHistoryByPostRequest {
	return GenomeApiAssemblyRevisionHistoryByPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V2AssemblyRevisionHistory
func (a *GenomeApiService) AssemblyRevisionHistoryByPostExecute(r GenomeApiAssemblyRevisionHistoryByPostRequest) (*V2AssemblyRevisionHistory, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V2AssemblyRevisionHistory
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GenomeApiService.AssemblyRevisionHistoryByPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/genome/revision_history"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.v2AssemblyRevisionHistoryRequest == nil {
		return localVarReturnValue, nil, reportError("v2AssemblyRevisionHistoryRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.v2AssemblyRevisionHistoryRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuthHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v RpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type GenomeApiCheckAssemblyAvailabilityRequest struct {
	ctx context.Context
	ApiService *GenomeApiService
	accessions []string
	expDebugValues *string
}

// Supports debugging, e.g. by controlling data download speeds
func (r GenomeApiCheckAssemblyAvailabilityRequest) ExpDebugValues(expDebugValues string) GenomeApiCheckAssemblyAvailabilityRequest {
	r.expDebugValues = &expDebugValues
	return r
}

func (r GenomeApiCheckAssemblyAvailabilityRequest) Execute() (*V2AssemblyDatasetAvailability, *http.Response, error) {
	return r.ApiService.CheckAssemblyAvailabilityExecute(r)
}

/*
CheckAssemblyAvailability Check the validity of genome accessions

The 'GET' version of check is limited by the size of the GET URL (2KB, which works out to about 140 genomic accessions).  The POST operation is provided to allow users to supply a larger number of accessions in a single request.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accessions NCBI genome assembly accessions
 @return GenomeApiCheckAssemblyAvailabilityRequest
*/
func (a *GenomeApiService) CheckAssemblyAvailability(ctx context.Context, accessions []string) GenomeApiCheckAssemblyAvailabilityRequest {
	return GenomeApiCheckAssemblyAvailabilityRequest{
		ApiService: a,
		ctx: ctx,
		accessions: accessions,
	}
}

// Execute executes the request
//  @return V2AssemblyDatasetAvailability
func (a *GenomeApiService) CheckAssemblyAvailabilityExecute(r GenomeApiCheckAssemblyAvailabilityRequest) (*V2AssemblyDatasetAvailability, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V2AssemblyDatasetAvailability
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GenomeApiService.CheckAssemblyAvailability")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/genome/accession/{accessions}/check"
	localVarPath = strings.Replace(localVarPath, "{"+"accessions"+"}", url.PathEscape(parameterToString(r.accessions, "csv")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.expDebugValues != nil {
		localVarQueryParams.Add("_exp_debug_values", parameterToString(*r.expDebugValues, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuthHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v RpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type GenomeApiCheckAssemblyAvailabilityPostRequest struct {
	ctx context.Context
	ApiService *GenomeApiService
	v2AssemblyDatasetRequest *V2AssemblyDatasetRequest
}

func (r GenomeApiCheckAssemblyAvailabilityPostRequest) V2AssemblyDatasetRequest(v2AssemblyDatasetRequest V2AssemblyDatasetRequest) GenomeApiCheckAssemblyAvailabilityPostRequest {
	r.v2AssemblyDatasetRequest = &v2AssemblyDatasetRequest
	return r
}

func (r GenomeApiCheckAssemblyAvailabilityPostRequest) Execute() (*V2AssemblyDatasetAvailability, *http.Response, error) {
	return r.ApiService.CheckAssemblyAvailabilityPostExecute(r)
}

/*
CheckAssemblyAvailabilityPost Check the validity of many genome accessions in a single request

The 'GET' version of check is limited by the size of the GET URL (2KB, which works out to about 140 genomic accessions).  The POST operation is provided to allow users to supply a larger number of accessions in a single request.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return GenomeApiCheckAssemblyAvailabilityPostRequest
*/
func (a *GenomeApiService) CheckAssemblyAvailabilityPost(ctx context.Context) GenomeApiCheckAssemblyAvailabilityPostRequest {
	return GenomeApiCheckAssemblyAvailabilityPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V2AssemblyDatasetAvailability
func (a *GenomeApiService) CheckAssemblyAvailabilityPostExecute(r GenomeApiCheckAssemblyAvailabilityPostRequest) (*V2AssemblyDatasetAvailability, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V2AssemblyDatasetAvailability
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GenomeApiService.CheckAssemblyAvailabilityPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/genome/check"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.v2AssemblyDatasetRequest == nil {
		return localVarReturnValue, nil, reportError("v2AssemblyDatasetRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.v2AssemblyDatasetRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuthHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v RpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type GenomeApiCheckmHistogramByTaxonRequest struct {
	ctx context.Context
	ApiService *GenomeApiService
	speciesTaxon string
}

func (r GenomeApiCheckmHistogramByTaxonRequest) Execute() (*V2AssemblyCheckMHistogramReply, *http.Response, error) {
	return r.ApiService.CheckmHistogramByTaxonExecute(r)
}

/*
CheckmHistogramByTaxon Get CheckM histogram by species taxon

Get CheckM histogram by species taxon. CheckM histograms are only available for certain bacterial species.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param speciesTaxon
 @return GenomeApiCheckmHistogramByTaxonRequest
*/
func (a *GenomeApiService) CheckmHistogramByTaxon(ctx context.Context, speciesTaxon string) GenomeApiCheckmHistogramByTaxonRequest {
	return GenomeApiCheckmHistogramByTaxonRequest{
		ApiService: a,
		ctx: ctx,
		speciesTaxon: speciesTaxon,
	}
}

// Execute executes the request
//  @return V2AssemblyCheckMHistogramReply
func (a *GenomeApiService) CheckmHistogramByTaxonExecute(r GenomeApiCheckmHistogramByTaxonRequest) (*V2AssemblyCheckMHistogramReply, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V2AssemblyCheckMHistogramReply
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GenomeApiService.CheckmHistogramByTaxon")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/genome/taxon/{species_taxon}/checkm_histogram"
	localVarPath = strings.Replace(localVarPath, "{"+"species_taxon"+"}", url.PathEscape(parameterToString(r.speciesTaxon, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuthHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v RpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type GenomeApiCheckmHistogramByTaxonByPostRequest struct {
	ctx context.Context
	ApiService *GenomeApiService
	v2AssemblyCheckMHistogramRequest *V2AssemblyCheckMHistogramRequest
}

func (r GenomeApiCheckmHistogramByTaxonByPostRequest) V2AssemblyCheckMHistogramRequest(v2AssemblyCheckMHistogramRequest V2AssemblyCheckMHistogramRequest) GenomeApiCheckmHistogramByTaxonByPostRequest {
	r.v2AssemblyCheckMHistogramRequest = &v2AssemblyCheckMHistogramRequest
	return r
}

func (r GenomeApiCheckmHistogramByTaxonByPostRequest) Execute() (*V2AssemblyCheckMHistogramReply, *http.Response, error) {
	return r.ApiService.CheckmHistogramByTaxonByPostExecute(r)
}

/*
CheckmHistogramByTaxonByPost Get CheckM histogram by species taxon

Get CheckM histogram by species taxon. CheckM histograms are only available for certain bacterial species.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return GenomeApiCheckmHistogramByTaxonByPostRequest
*/
func (a *GenomeApiService) CheckmHistogramByTaxonByPost(ctx context.Context) GenomeApiCheckmHistogramByTaxonByPostRequest {
	return GenomeApiCheckmHistogramByTaxonByPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V2AssemblyCheckMHistogramReply
func (a *GenomeApiService) CheckmHistogramByTaxonByPostExecute(r GenomeApiCheckmHistogramByTaxonByPostRequest) (*V2AssemblyCheckMHistogramReply, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V2AssemblyCheckMHistogramReply
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GenomeApiService.CheckmHistogramByTaxonByPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/genome/checkm_histogram"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.v2AssemblyCheckMHistogramRequest == nil {
		return localVarReturnValue, nil, reportError("v2AssemblyCheckMHistogramRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.v2AssemblyCheckMHistogramRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuthHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v RpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type GenomeApiDownloadAssemblyPackageRequest struct {
	ctx context.Context
	ApiService *GenomeApiService
	accessions []string
	chromosomes *[]string
	includeAnnotationType *[]V2AnnotationForAssemblyType
	hydrated *V2AssemblyDatasetRequestResolution
	expDebugValues *string
	filename *string
}

// The default setting is all chromosome. Specify individual chromosome by string (1,2,MT or chr1,chr2.chrMT). Unplaced sequences are treated like their own chromosome (&#39;Un&#39;). The filter only applies to fasta sequence.
func (r GenomeApiDownloadAssemblyPackageRequest) Chromosomes(chromosomes []string) GenomeApiDownloadAssemblyPackageRequest {
	r.chromosomes = &chromosomes
	return r
}

// Select additional types of annotation to include in the data package.  If unset, no annotation is provided.
func (r GenomeApiDownloadAssemblyPackageRequest) IncludeAnnotationType(includeAnnotationType []V2AnnotationForAssemblyType) GenomeApiDownloadAssemblyPackageRequest {
	r.includeAnnotationType = &includeAnnotationType
	return r
}

// Set to DATA_REPORT_ONLY, to only retrieve data-reports.
func (r GenomeApiDownloadAssemblyPackageRequest) Hydrated(hydrated V2AssemblyDatasetRequestResolution) GenomeApiDownloadAssemblyPackageRequest {
	r.hydrated = &hydrated
	return r
}

// Supports debugging, e.g. by controlling data download speeds
func (r GenomeApiDownloadAssemblyPackageRequest) ExpDebugValues(expDebugValues string) GenomeApiDownloadAssemblyPackageRequest {
	r.expDebugValues = &expDebugValues
	return r
}

// Output file name.
func (r GenomeApiDownloadAssemblyPackageRequest) Filename(filename string) GenomeApiDownloadAssemblyPackageRequest {
	r.filename = &filename
	return r
}

func (r GenomeApiDownloadAssemblyPackageRequest) Execute() (**os.File, *http.Response, error) {
	return r.ApiService.DownloadAssemblyPackageExecute(r)
}

/*
DownloadAssemblyPackage Get a genome dataset by accession

Download a genome dataset including fasta sequence, annotation and a detailed data report by accession.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accessions NCBI genome assembly accessions
 @return GenomeApiDownloadAssemblyPackageRequest
*/
func (a *GenomeApiService) DownloadAssemblyPackage(ctx context.Context, accessions []string) GenomeApiDownloadAssemblyPackageRequest {
	return GenomeApiDownloadAssemblyPackageRequest{
		ApiService: a,
		ctx: ctx,
		accessions: accessions,
	}
}

// Execute executes the request
//  @return *os.File
func (a *GenomeApiService) DownloadAssemblyPackageExecute(r GenomeApiDownloadAssemblyPackageRequest) (**os.File, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  **os.File
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GenomeApiService.DownloadAssemblyPackage")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/genome/accession/{accessions}/download"
	localVarPath = strings.Replace(localVarPath, "{"+"accessions"+"}", url.PathEscape(parameterToString(r.accessions, "csv")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.chromosomes != nil {
		t := *r.chromosomes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("chromosomes", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("chromosomes", parameterToString(t, "multi"))
		}
	}
	if r.includeAnnotationType != nil {
		t := *r.includeAnnotationType
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("include_annotation_type", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("include_annotation_type", parameterToString(t, "multi"))
		}
	}
	if r.hydrated != nil {
		localVarQueryParams.Add("hydrated", parameterToString(*r.hydrated, ""))
	}
	if r.expDebugValues != nil {
		localVarQueryParams.Add("_exp_debug_values", parameterToString(*r.expDebugValues, ""))
	}
	if r.filename != nil {
		localVarQueryParams.Add("filename", parameterToString(*r.filename, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/zip"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuthHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v RpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type GenomeApiDownloadAssemblyPackagePostRequest struct {
	ctx context.Context
	ApiService *GenomeApiService
	v2AssemblyDatasetRequest *V2AssemblyDatasetRequest
	filename *string
}

func (r GenomeApiDownloadAssemblyPackagePostRequest) V2AssemblyDatasetRequest(v2AssemblyDatasetRequest V2AssemblyDatasetRequest) GenomeApiDownloadAssemblyPackagePostRequest {
	r.v2AssemblyDatasetRequest = &v2AssemblyDatasetRequest
	return r
}

// Output file name.
func (r GenomeApiDownloadAssemblyPackagePostRequest) Filename(filename string) GenomeApiDownloadAssemblyPackagePostRequest {
	r.filename = &filename
	return r
}

func (r GenomeApiDownloadAssemblyPackagePostRequest) Execute() (**os.File, *http.Response, error) {
	return r.ApiService.DownloadAssemblyPackagePostExecute(r)
}

/*
DownloadAssemblyPackagePost Get a genome dataset by post

The 'GET' version of download is limited by the size of the GET URL (2KB, which works out to about 140 genomic accessions).  The POST operation is provided to allow users to supply a larger number of accessions in a single request.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return GenomeApiDownloadAssemblyPackagePostRequest
*/
func (a *GenomeApiService) DownloadAssemblyPackagePost(ctx context.Context) GenomeApiDownloadAssemblyPackagePostRequest {
	return GenomeApiDownloadAssemblyPackagePostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return *os.File
func (a *GenomeApiService) DownloadAssemblyPackagePostExecute(r GenomeApiDownloadAssemblyPackagePostRequest) (**os.File, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  **os.File
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GenomeApiService.DownloadAssemblyPackagePost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/genome/download"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.v2AssemblyDatasetRequest == nil {
		return localVarReturnValue, nil, reportError("v2AssemblyDatasetRequest is required and must be specified")
	}

	if r.filename != nil {
		localVarQueryParams.Add("filename", parameterToString(*r.filename, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/zip"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.v2AssemblyDatasetRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuthHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v RpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type GenomeApiDownloadGenomeAnnotationPackageRequest struct {
	ctx context.Context
	ApiService *GenomeApiService
	accession string
	annotationIds *[]string
	symbols *[]string
	locations *[]string
	geneTypes *[]string
	searchText *[]string
	sortField *string
	sortDirection *V2SortDirection
	includeAnnotationType *[]V2GenomeAnnotationRequestAnnotationType
	pageSize *int32
	tableFields *[]string
	tableFormat *V2GenomeAnnotationRequestGenomeAnnotationTableFormat
	includeTabularHeader *V2IncludeTabularHeader
	pageToken *string
	filename *string
}

// Limit the reports by internal, unstable annotation ids.
func (r GenomeApiDownloadGenomeAnnotationPackageRequest) AnnotationIds(annotationIds []string) GenomeApiDownloadGenomeAnnotationPackageRequest {
	r.annotationIds = &annotationIds
	return r
}

// Filter parameters
func (r GenomeApiDownloadGenomeAnnotationPackageRequest) Symbols(symbols []string) GenomeApiDownloadGenomeAnnotationPackageRequest {
	r.symbols = &symbols
	return r
}

// Locations with a chromosome or accession and optional start-stop range: chromosome|accession[:start-end]
func (r GenomeApiDownloadGenomeAnnotationPackageRequest) Locations(locations []string) GenomeApiDownloadGenomeAnnotationPackageRequest {
	r.locations = &locations
	return r
}

// granular gene_types
func (r GenomeApiDownloadGenomeAnnotationPackageRequest) GeneTypes(geneTypes []string) GenomeApiDownloadGenomeAnnotationPackageRequest {
	r.geneTypes = &geneTypes
	return r
}

func (r GenomeApiDownloadGenomeAnnotationPackageRequest) SearchText(searchText []string) GenomeApiDownloadGenomeAnnotationPackageRequest {
	r.searchText = &searchText
	return r
}

func (r GenomeApiDownloadGenomeAnnotationPackageRequest) SortField(sortField string) GenomeApiDownloadGenomeAnnotationPackageRequest {
	r.sortField = &sortField
	return r
}

func (r GenomeApiDownloadGenomeAnnotationPackageRequest) SortDirection(sortDirection V2SortDirection) GenomeApiDownloadGenomeAnnotationPackageRequest {
	r.sortDirection = &sortDirection
	return r
}

func (r GenomeApiDownloadGenomeAnnotationPackageRequest) IncludeAnnotationType(includeAnnotationType []V2GenomeAnnotationRequestAnnotationType) GenomeApiDownloadGenomeAnnotationPackageRequest {
	r.includeAnnotationType = &includeAnnotationType
	return r
}

// The maximum number of features to return. Default is 20 and maximum is 1000. If the number of results exceeds the page size, &#x60;page_token&#x60; can be used to retrieve the remaining results.
func (r GenomeApiDownloadGenomeAnnotationPackageRequest) PageSize(pageSize int32) GenomeApiDownloadGenomeAnnotationPackageRequest {
	r.pageSize = &pageSize
	return r
}

// Specify which fields to include in the tabular report
func (r GenomeApiDownloadGenomeAnnotationPackageRequest) TableFields(tableFields []string) GenomeApiDownloadGenomeAnnotationPackageRequest {
	r.tableFields = &tableFields
	return r
}

// Optional pre-defined template for processing a tabular data request
func (r GenomeApiDownloadGenomeAnnotationPackageRequest) TableFormat(tableFormat V2GenomeAnnotationRequestGenomeAnnotationTableFormat) GenomeApiDownloadGenomeAnnotationPackageRequest {
	r.tableFormat = &tableFormat
	return r
}

// Whether this request for tabular data should include the header row
func (r GenomeApiDownloadGenomeAnnotationPackageRequest) IncludeTabularHeader(includeTabularHeader V2IncludeTabularHeader) GenomeApiDownloadGenomeAnnotationPackageRequest {
	r.includeTabularHeader = &includeTabularHeader
	return r
}

// A page token is returned from a &#x60;GetFeatures&#x60; call with more than &#x60;page_size&#x60; results. Use this token, along with the previous &#x60;FeatureRequest&#x60; parameters, to retrieve the next page of results. When &#x60;page_token&#x60; is empty, all results have been retrieved.
func (r GenomeApiDownloadGenomeAnnotationPackageRequest) PageToken(pageToken string) GenomeApiDownloadGenomeAnnotationPackageRequest {
	r.pageToken = &pageToken
	return r
}

// Output file name.
func (r GenomeApiDownloadGenomeAnnotationPackageRequest) Filename(filename string) GenomeApiDownloadGenomeAnnotationPackageRequest {
	r.filename = &filename
	return r
}

func (r GenomeApiDownloadGenomeAnnotationPackageRequest) Execute() (**os.File, *http.Response, error) {
	return r.ApiService.DownloadGenomeAnnotationPackageExecute(r)
}

/*
DownloadGenomeAnnotationPackage Get an annotation report dataset by accession

Download an annotation report including fasta sequence and a detailed annotation report by genomic accession.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accession
 @return GenomeApiDownloadGenomeAnnotationPackageRequest
*/
func (a *GenomeApiService) DownloadGenomeAnnotationPackage(ctx context.Context, accession string) GenomeApiDownloadGenomeAnnotationPackageRequest {
	return GenomeApiDownloadGenomeAnnotationPackageRequest{
		ApiService: a,
		ctx: ctx,
		accession: accession,
	}
}

// Execute executes the request
//  @return *os.File
func (a *GenomeApiService) DownloadGenomeAnnotationPackageExecute(r GenomeApiDownloadGenomeAnnotationPackageRequest) (**os.File, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  **os.File
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GenomeApiService.DownloadGenomeAnnotationPackage")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/genome/accession/{accession}/annotation_report/download"
	localVarPath = strings.Replace(localVarPath, "{"+"accession"+"}", url.PathEscape(parameterToString(r.accession, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.annotationIds != nil {
		t := *r.annotationIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("annotation_ids", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("annotation_ids", parameterToString(t, "multi"))
		}
	}
	if r.symbols != nil {
		t := *r.symbols
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("symbols", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("symbols", parameterToString(t, "multi"))
		}
	}
	if r.locations != nil {
		t := *r.locations
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("locations", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("locations", parameterToString(t, "multi"))
		}
	}
	if r.geneTypes != nil {
		t := *r.geneTypes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("gene_types", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("gene_types", parameterToString(t, "multi"))
		}
	}
	if r.searchText != nil {
		t := *r.searchText
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("search_text", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("search_text", parameterToString(t, "multi"))
		}
	}
	if r.sortField != nil {
		localVarQueryParams.Add("sort.field", parameterToString(*r.sortField, ""))
	}
	if r.sortDirection != nil {
		localVarQueryParams.Add("sort.direction", parameterToString(*r.sortDirection, ""))
	}
	if r.includeAnnotationType != nil {
		t := *r.includeAnnotationType
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("include_annotation_type", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("include_annotation_type", parameterToString(t, "multi"))
		}
	}
	if r.pageSize != nil {
		localVarQueryParams.Add("page_size", parameterToString(*r.pageSize, ""))
	}
	if r.tableFields != nil {
		t := *r.tableFields
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("table_fields", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("table_fields", parameterToString(t, "multi"))
		}
	}
	if r.tableFormat != nil {
		localVarQueryParams.Add("table_format", parameterToString(*r.tableFormat, ""))
	}
	if r.includeTabularHeader != nil {
		localVarQueryParams.Add("include_tabular_header", parameterToString(*r.includeTabularHeader, ""))
	}
	if r.pageToken != nil {
		localVarQueryParams.Add("page_token", parameterToString(*r.pageToken, ""))
	}
	if r.filename != nil {
		localVarQueryParams.Add("filename", parameterToString(*r.filename, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/zip"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuthHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v RpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type GenomeApiDownloadGenomeAnnotationPackageByPostRequest struct {
	ctx context.Context
	ApiService *GenomeApiService
	v2GenomeAnnotationRequest *V2GenomeAnnotationRequest
	filename *string
}

func (r GenomeApiDownloadGenomeAnnotationPackageByPostRequest) V2GenomeAnnotationRequest(v2GenomeAnnotationRequest V2GenomeAnnotationRequest) GenomeApiDownloadGenomeAnnotationPackageByPostRequest {
	r.v2GenomeAnnotationRequest = &v2GenomeAnnotationRequest
	return r
}

// Output file name.
func (r GenomeApiDownloadGenomeAnnotationPackageByPostRequest) Filename(filename string) GenomeApiDownloadGenomeAnnotationPackageByPostRequest {
	r.filename = &filename
	return r
}

func (r GenomeApiDownloadGenomeAnnotationPackageByPostRequest) Execute() (**os.File, *http.Response, error) {
	return r.ApiService.DownloadGenomeAnnotationPackageByPostExecute(r)
}

/*
DownloadGenomeAnnotationPackageByPost Get an annotation report dataset by accession

Download an annotation report including fasta sequence and a detailed annotation report by genomic accession.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return GenomeApiDownloadGenomeAnnotationPackageByPostRequest
*/
func (a *GenomeApiService) DownloadGenomeAnnotationPackageByPost(ctx context.Context) GenomeApiDownloadGenomeAnnotationPackageByPostRequest {
	return GenomeApiDownloadGenomeAnnotationPackageByPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return *os.File
func (a *GenomeApiService) DownloadGenomeAnnotationPackageByPostExecute(r GenomeApiDownloadGenomeAnnotationPackageByPostRequest) (**os.File, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  **os.File
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GenomeApiService.DownloadGenomeAnnotationPackageByPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/genome/annotation_report/download"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.v2GenomeAnnotationRequest == nil {
		return localVarReturnValue, nil, reportError("v2GenomeAnnotationRequest is required and must be specified")
	}

	if r.filename != nil {
		localVarQueryParams.Add("filename", parameterToString(*r.filename, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/zip"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.v2GenomeAnnotationRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuthHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v RpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type GenomeApiGenomeAnnotationDownloadSummaryRequest struct {
	ctx context.Context
	ApiService *GenomeApiService
	accession string
	annotationIds *[]string
	symbols *[]string
	locations *[]string
	geneTypes *[]string
	searchText *[]string
	sortField *string
	sortDirection *V2SortDirection
	includeAnnotationType *[]V2GenomeAnnotationRequestAnnotationType
	tableFields *[]string
	tableFormat *V2GenomeAnnotationRequestGenomeAnnotationTableFormat
	includeTabularHeader *V2IncludeTabularHeader
}

// Limit the reports by internal, unstable annotation ids.
func (r GenomeApiGenomeAnnotationDownloadSummaryRequest) AnnotationIds(annotationIds []string) GenomeApiGenomeAnnotationDownloadSummaryRequest {
	r.annotationIds = &annotationIds
	return r
}

// Filter parameters
func (r GenomeApiGenomeAnnotationDownloadSummaryRequest) Symbols(symbols []string) GenomeApiGenomeAnnotationDownloadSummaryRequest {
	r.symbols = &symbols
	return r
}

// Locations with a chromosome or accession and optional start-stop range: chromosome|accession[:start-end]
func (r GenomeApiGenomeAnnotationDownloadSummaryRequest) Locations(locations []string) GenomeApiGenomeAnnotationDownloadSummaryRequest {
	r.locations = &locations
	return r
}

// granular gene_types
func (r GenomeApiGenomeAnnotationDownloadSummaryRequest) GeneTypes(geneTypes []string) GenomeApiGenomeAnnotationDownloadSummaryRequest {
	r.geneTypes = &geneTypes
	return r
}

func (r GenomeApiGenomeAnnotationDownloadSummaryRequest) SearchText(searchText []string) GenomeApiGenomeAnnotationDownloadSummaryRequest {
	r.searchText = &searchText
	return r
}

func (r GenomeApiGenomeAnnotationDownloadSummaryRequest) SortField(sortField string) GenomeApiGenomeAnnotationDownloadSummaryRequest {
	r.sortField = &sortField
	return r
}

func (r GenomeApiGenomeAnnotationDownloadSummaryRequest) SortDirection(sortDirection V2SortDirection) GenomeApiGenomeAnnotationDownloadSummaryRequest {
	r.sortDirection = &sortDirection
	return r
}

func (r GenomeApiGenomeAnnotationDownloadSummaryRequest) IncludeAnnotationType(includeAnnotationType []V2GenomeAnnotationRequestAnnotationType) GenomeApiGenomeAnnotationDownloadSummaryRequest {
	r.includeAnnotationType = &includeAnnotationType
	return r
}

// Specify which fields to include in the tabular report
func (r GenomeApiGenomeAnnotationDownloadSummaryRequest) TableFields(tableFields []string) GenomeApiGenomeAnnotationDownloadSummaryRequest {
	r.tableFields = &tableFields
	return r
}

// Optional pre-defined template for processing a tabular data request
func (r GenomeApiGenomeAnnotationDownloadSummaryRequest) TableFormat(tableFormat V2GenomeAnnotationRequestGenomeAnnotationTableFormat) GenomeApiGenomeAnnotationDownloadSummaryRequest {
	r.tableFormat = &tableFormat
	return r
}

// Whether this request for tabular data should include the header row
func (r GenomeApiGenomeAnnotationDownloadSummaryRequest) IncludeTabularHeader(includeTabularHeader V2IncludeTabularHeader) GenomeApiGenomeAnnotationDownloadSummaryRequest {
	r.includeTabularHeader = &includeTabularHeader
	return r
}

func (r GenomeApiGenomeAnnotationDownloadSummaryRequest) Execute() (*V2DownloadSummary, *http.Response, error) {
	return r.ApiService.GenomeAnnotationDownloadSummaryExecute(r)
}

/*
GenomeAnnotationDownloadSummary Preview feature dataset download

Get a download feature summary by accession in a JSON output format.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accession
 @return GenomeApiGenomeAnnotationDownloadSummaryRequest
*/
func (a *GenomeApiService) GenomeAnnotationDownloadSummary(ctx context.Context, accession string) GenomeApiGenomeAnnotationDownloadSummaryRequest {
	return GenomeApiGenomeAnnotationDownloadSummaryRequest{
		ApiService: a,
		ctx: ctx,
		accession: accession,
	}
}

// Execute executes the request
//  @return V2DownloadSummary
func (a *GenomeApiService) GenomeAnnotationDownloadSummaryExecute(r GenomeApiGenomeAnnotationDownloadSummaryRequest) (*V2DownloadSummary, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V2DownloadSummary
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GenomeApiService.GenomeAnnotationDownloadSummary")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/genome/accession/{accession}/annotation_report/download_summary"
	localVarPath = strings.Replace(localVarPath, "{"+"accession"+"}", url.PathEscape(parameterToString(r.accession, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.annotationIds != nil {
		t := *r.annotationIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("annotation_ids", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("annotation_ids", parameterToString(t, "multi"))
		}
	}
	if r.symbols != nil {
		t := *r.symbols
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("symbols", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("symbols", parameterToString(t, "multi"))
		}
	}
	if r.locations != nil {
		t := *r.locations
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("locations", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("locations", parameterToString(t, "multi"))
		}
	}
	if r.geneTypes != nil {
		t := *r.geneTypes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("gene_types", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("gene_types", parameterToString(t, "multi"))
		}
	}
	if r.searchText != nil {
		t := *r.searchText
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("search_text", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("search_text", parameterToString(t, "multi"))
		}
	}
	if r.sortField != nil {
		localVarQueryParams.Add("sort.field", parameterToString(*r.sortField, ""))
	}
	if r.sortDirection != nil {
		localVarQueryParams.Add("sort.direction", parameterToString(*r.sortDirection, ""))
	}
	if r.includeAnnotationType != nil {
		t := *r.includeAnnotationType
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("include_annotation_type", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("include_annotation_type", parameterToString(t, "multi"))
		}
	}
	if r.tableFields != nil {
		t := *r.tableFields
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("table_fields", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("table_fields", parameterToString(t, "multi"))
		}
	}
	if r.tableFormat != nil {
		localVarQueryParams.Add("table_format", parameterToString(*r.tableFormat, ""))
	}
	if r.includeTabularHeader != nil {
		localVarQueryParams.Add("include_tabular_header", parameterToString(*r.includeTabularHeader, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuthHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v RpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type GenomeApiGenomeAnnotationDownloadSummaryByPostRequest struct {
	ctx context.Context
	ApiService *GenomeApiService
	v2GenomeAnnotationRequest *V2GenomeAnnotationRequest
}

func (r GenomeApiGenomeAnnotationDownloadSummaryByPostRequest) V2GenomeAnnotationRequest(v2GenomeAnnotationRequest V2GenomeAnnotationRequest) GenomeApiGenomeAnnotationDownloadSummaryByPostRequest {
	r.v2GenomeAnnotationRequest = &v2GenomeAnnotationRequest
	return r
}

func (r GenomeApiGenomeAnnotationDownloadSummaryByPostRequest) Execute() (*V2DownloadSummary, *http.Response, error) {
	return r.ApiService.GenomeAnnotationDownloadSummaryByPostExecute(r)
}

/*
GenomeAnnotationDownloadSummaryByPost Preview feature download by POST

The 'GET' version of feature download summary is limited by the size of the GET URL (2KB).  The POST operation is provided to allow users to supply a larger number of annotation_ids in a single request.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return GenomeApiGenomeAnnotationDownloadSummaryByPostRequest
*/
func (a *GenomeApiService) GenomeAnnotationDownloadSummaryByPost(ctx context.Context) GenomeApiGenomeAnnotationDownloadSummaryByPostRequest {
	return GenomeApiGenomeAnnotationDownloadSummaryByPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V2DownloadSummary
func (a *GenomeApiService) GenomeAnnotationDownloadSummaryByPostExecute(r GenomeApiGenomeAnnotationDownloadSummaryByPostRequest) (*V2DownloadSummary, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V2DownloadSummary
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GenomeApiService.GenomeAnnotationDownloadSummaryByPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/genome/annotation_report/download_summary"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.v2GenomeAnnotationRequest == nil {
		return localVarReturnValue, nil, reportError("v2GenomeAnnotationRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.v2GenomeAnnotationRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuthHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v RpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type GenomeApiGenomeAnnotationReportRequest struct {
	ctx context.Context
	ApiService *GenomeApiService
	accession string
	annotationIds *[]string
	symbols *[]string
	locations *[]string
	geneTypes *[]string
	searchText *[]string
	sortField *string
	sortDirection *V2SortDirection
	pageSize *int32
	tableFields *[]string
	tableFormat *V2GenomeAnnotationRequestGenomeAnnotationTableFormat
	includeTabularHeader *V2IncludeTabularHeader
	pageToken *string
}

// Limit the reports by internal, unstable annotation ids.
func (r GenomeApiGenomeAnnotationReportRequest) AnnotationIds(annotationIds []string) GenomeApiGenomeAnnotationReportRequest {
	r.annotationIds = &annotationIds
	return r
}

// Filter parameters
func (r GenomeApiGenomeAnnotationReportRequest) Symbols(symbols []string) GenomeApiGenomeAnnotationReportRequest {
	r.symbols = &symbols
	return r
}

// Locations with a chromosome or accession and optional start-stop range: chromosome|accession[:start-end]
func (r GenomeApiGenomeAnnotationReportRequest) Locations(locations []string) GenomeApiGenomeAnnotationReportRequest {
	r.locations = &locations
	return r
}

// granular gene_types
func (r GenomeApiGenomeAnnotationReportRequest) GeneTypes(geneTypes []string) GenomeApiGenomeAnnotationReportRequest {
	r.geneTypes = &geneTypes
	return r
}

func (r GenomeApiGenomeAnnotationReportRequest) SearchText(searchText []string) GenomeApiGenomeAnnotationReportRequest {
	r.searchText = &searchText
	return r
}

func (r GenomeApiGenomeAnnotationReportRequest) SortField(sortField string) GenomeApiGenomeAnnotationReportRequest {
	r.sortField = &sortField
	return r
}

func (r GenomeApiGenomeAnnotationReportRequest) SortDirection(sortDirection V2SortDirection) GenomeApiGenomeAnnotationReportRequest {
	r.sortDirection = &sortDirection
	return r
}

// The maximum number of features to return. Default is 20 and maximum is 1000. If the number of results exceeds the page size, &#x60;page_token&#x60; can be used to retrieve the remaining results.
func (r GenomeApiGenomeAnnotationReportRequest) PageSize(pageSize int32) GenomeApiGenomeAnnotationReportRequest {
	r.pageSize = &pageSize
	return r
}

// Specify which fields to include in the tabular report
func (r GenomeApiGenomeAnnotationReportRequest) TableFields(tableFields []string) GenomeApiGenomeAnnotationReportRequest {
	r.tableFields = &tableFields
	return r
}

// Optional pre-defined template for processing a tabular data request
func (r GenomeApiGenomeAnnotationReportRequest) TableFormat(tableFormat V2GenomeAnnotationRequestGenomeAnnotationTableFormat) GenomeApiGenomeAnnotationReportRequest {
	r.tableFormat = &tableFormat
	return r
}

// Whether this request for tabular data should include the header row
func (r GenomeApiGenomeAnnotationReportRequest) IncludeTabularHeader(includeTabularHeader V2IncludeTabularHeader) GenomeApiGenomeAnnotationReportRequest {
	r.includeTabularHeader = &includeTabularHeader
	return r
}

// A page token is returned from a &#x60;GetFeatures&#x60; call with more than &#x60;page_size&#x60; results. Use this token, along with the previous &#x60;FeatureRequest&#x60; parameters, to retrieve the next page of results. When &#x60;page_token&#x60; is empty, all results have been retrieved.
func (r GenomeApiGenomeAnnotationReportRequest) PageToken(pageToken string) GenomeApiGenomeAnnotationReportRequest {
	r.pageToken = &pageToken
	return r
}

func (r GenomeApiGenomeAnnotationReportRequest) Execute() (*V2reportsGenomeAnnotationReportPage, *http.Response, error) {
	return r.ApiService.GenomeAnnotationReportExecute(r)
}

/*
GenomeAnnotationReport Get genome annotation reports by genome accession

Get genome annotation reports by genome accession.  By default, in paged JSON format, but also available as tabular (accept: text/tab-separated-values) or json-lines (accept: application/x-ndjson)

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accession
 @return GenomeApiGenomeAnnotationReportRequest
*/
func (a *GenomeApiService) GenomeAnnotationReport(ctx context.Context, accession string) GenomeApiGenomeAnnotationReportRequest {
	return GenomeApiGenomeAnnotationReportRequest{
		ApiService: a,
		ctx: ctx,
		accession: accession,
	}
}

// Execute executes the request
//  @return V2reportsGenomeAnnotationReportPage
func (a *GenomeApiService) GenomeAnnotationReportExecute(r GenomeApiGenomeAnnotationReportRequest) (*V2reportsGenomeAnnotationReportPage, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V2reportsGenomeAnnotationReportPage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GenomeApiService.GenomeAnnotationReport")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/genome/accession/{accession}/annotation_report"
	localVarPath = strings.Replace(localVarPath, "{"+"accession"+"}", url.PathEscape(parameterToString(r.accession, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.annotationIds != nil {
		t := *r.annotationIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("annotation_ids", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("annotation_ids", parameterToString(t, "multi"))
		}
	}
	if r.symbols != nil {
		t := *r.symbols
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("symbols", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("symbols", parameterToString(t, "multi"))
		}
	}
	if r.locations != nil {
		t := *r.locations
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("locations", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("locations", parameterToString(t, "multi"))
		}
	}
	if r.geneTypes != nil {
		t := *r.geneTypes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("gene_types", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("gene_types", parameterToString(t, "multi"))
		}
	}
	if r.searchText != nil {
		t := *r.searchText
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("search_text", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("search_text", parameterToString(t, "multi"))
		}
	}
	if r.sortField != nil {
		localVarQueryParams.Add("sort.field", parameterToString(*r.sortField, ""))
	}
	if r.sortDirection != nil {
		localVarQueryParams.Add("sort.direction", parameterToString(*r.sortDirection, ""))
	}
	if r.pageSize != nil {
		localVarQueryParams.Add("page_size", parameterToString(*r.pageSize, ""))
	}
	if r.tableFields != nil {
		t := *r.tableFields
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("table_fields", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("table_fields", parameterToString(t, "multi"))
		}
	}
	if r.tableFormat != nil {
		localVarQueryParams.Add("table_format", parameterToString(*r.tableFormat, ""))
	}
	if r.includeTabularHeader != nil {
		localVarQueryParams.Add("include_tabular_header", parameterToString(*r.includeTabularHeader, ""))
	}
	if r.pageToken != nil {
		localVarQueryParams.Add("page_token", parameterToString(*r.pageToken, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "application/x-ndjson", "text/tab-separated-values"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuthHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v RpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type GenomeApiGenomeAnnotationReportByPostRequest struct {
	ctx context.Context
	ApiService *GenomeApiService
	v2GenomeAnnotationRequest *V2GenomeAnnotationRequest
}

func (r GenomeApiGenomeAnnotationReportByPostRequest) V2GenomeAnnotationRequest(v2GenomeAnnotationRequest V2GenomeAnnotationRequest) GenomeApiGenomeAnnotationReportByPostRequest {
	r.v2GenomeAnnotationRequest = &v2GenomeAnnotationRequest
	return r
}

func (r GenomeApiGenomeAnnotationReportByPostRequest) Execute() (*V2reportsGenomeAnnotationReportPage, *http.Response, error) {
	return r.ApiService.GenomeAnnotationReportByPostExecute(r)
}

/*
GenomeAnnotationReportByPost Get genome annotation reports by genome accession

Get genome annotation reports by genome accession.  By default, in paged JSON format, but also available as tabular (accept: text/tab-separated-values) or json-lines (accept: application/x-ndjson)

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return GenomeApiGenomeAnnotationReportByPostRequest
*/
func (a *GenomeApiService) GenomeAnnotationReportByPost(ctx context.Context) GenomeApiGenomeAnnotationReportByPostRequest {
	return GenomeApiGenomeAnnotationReportByPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V2reportsGenomeAnnotationReportPage
func (a *GenomeApiService) GenomeAnnotationReportByPostExecute(r GenomeApiGenomeAnnotationReportByPostRequest) (*V2reportsGenomeAnnotationReportPage, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V2reportsGenomeAnnotationReportPage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GenomeApiService.GenomeAnnotationReportByPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/genome/annotation_report"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.v2GenomeAnnotationRequest == nil {
		return localVarReturnValue, nil, reportError("v2GenomeAnnotationRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "application/x-ndjson", "text/tab-separated-values"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.v2GenomeAnnotationRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuthHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v RpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type GenomeApiGenomeDatasetReportRequest struct {
	ctx context.Context
	ApiService *GenomeApiService
	accessions []string
	filtersReferenceOnly *bool
	filtersAssemblySource *V2AssemblyDatasetDescriptorsFilterAssemblySource
	filtersHasAnnotation *bool
	filtersExcludePairedReports *bool
	filtersExcludeAtypical *bool
	filtersAssemblyVersion *V2AssemblyDatasetDescriptorsFilterAssemblyVersion
	filtersAssemblyLevel *[]V2reportsAssemblyLevel
	filtersFirstReleaseDate *time.Time
	filtersLastReleaseDate *time.Time
	filtersSearchText *[]string
	filtersIsMetagenomeDerived *V2AssemblyDatasetDescriptorsFilterMetagenomeDerivedFilter
	filtersIsTypeMaterial *bool
	filtersIsIctvExemplar *bool
	filtersExcludeMultiIsolate *bool
	filtersTypeMaterialCategory *V2AssemblyDatasetDescriptorsFilterTypeMaterialCategory
	taxExactMatch *bool
	tableFields *[]string
	returnedContent *V2AssemblyDatasetReportsRequestContentType
	pageSize *int32
	pageToken *string
	sortField *string
	sortDirection *V2SortDirection
	includeTabularHeader *V2IncludeTabularHeader
}

// If true, only return reference and representative (GCF_ and GCA_) genome assemblies.
func (r GenomeApiGenomeDatasetReportRequest) FiltersReferenceOnly(filtersReferenceOnly bool) GenomeApiGenomeDatasetReportRequest {
	r.filtersReferenceOnly = &filtersReferenceOnly
	return r
}

// Return only RefSeq (GCF_) or GenBank (GCA_) genome assemblies
func (r GenomeApiGenomeDatasetReportRequest) FiltersAssemblySource(filtersAssemblySource V2AssemblyDatasetDescriptorsFilterAssemblySource) GenomeApiGenomeDatasetReportRequest {
	r.filtersAssemblySource = &filtersAssemblySource
	return r
}

// Return only annotated genome assemblies
func (r GenomeApiGenomeDatasetReportRequest) FiltersHasAnnotation(filtersHasAnnotation bool) GenomeApiGenomeDatasetReportRequest {
	r.filtersHasAnnotation = &filtersHasAnnotation
	return r
}

// For paired (GCA/GCF) records, only return the primary record
func (r GenomeApiGenomeDatasetReportRequest) FiltersExcludePairedReports(filtersExcludePairedReports bool) GenomeApiGenomeDatasetReportRequest {
	r.filtersExcludePairedReports = &filtersExcludePairedReports
	return r
}

// If true, exclude atypical genomes, i.e. genomes that have assembly issues or are otherwise atypical
func (r GenomeApiGenomeDatasetReportRequest) FiltersExcludeAtypical(filtersExcludeAtypical bool) GenomeApiGenomeDatasetReportRequest {
	r.filtersExcludeAtypical = &filtersExcludeAtypical
	return r
}

// Return all assemblies, including replaced and suppressed, or only current assemblies
func (r GenomeApiGenomeDatasetReportRequest) FiltersAssemblyVersion(filtersAssemblyVersion V2AssemblyDatasetDescriptorsFilterAssemblyVersion) GenomeApiGenomeDatasetReportRequest {
	r.filtersAssemblyVersion = &filtersAssemblyVersion
	return r
}

// Only return genome assemblies that have one of the specified assembly levels. By default, do not filter.
func (r GenomeApiGenomeDatasetReportRequest) FiltersAssemblyLevel(filtersAssemblyLevel []V2reportsAssemblyLevel) GenomeApiGenomeDatasetReportRequest {
	r.filtersAssemblyLevel = &filtersAssemblyLevel
	return r
}

// Only return genome assemblies that were released on or after the specified date By default, do not filter.
func (r GenomeApiGenomeDatasetReportRequest) FiltersFirstReleaseDate(filtersFirstReleaseDate time.Time) GenomeApiGenomeDatasetReportRequest {
	r.filtersFirstReleaseDate = &filtersFirstReleaseDate
	return r
}

// Only return genome assemblies that were released on or before to the specified date By default, do not filter.
func (r GenomeApiGenomeDatasetReportRequest) FiltersLastReleaseDate(filtersLastReleaseDate time.Time) GenomeApiGenomeDatasetReportRequest {
	r.filtersLastReleaseDate = &filtersLastReleaseDate
	return r
}

// Only return results whose fields contain the specified search terms in their taxon, infraspecific, assembly name or submitter fields By default, do not filter
func (r GenomeApiGenomeDatasetReportRequest) FiltersSearchText(filtersSearchText []string) GenomeApiGenomeDatasetReportRequest {
	r.filtersSearchText = &filtersSearchText
	return r
}

func (r GenomeApiGenomeDatasetReportRequest) FiltersIsMetagenomeDerived(filtersIsMetagenomeDerived V2AssemblyDatasetDescriptorsFilterMetagenomeDerivedFilter) GenomeApiGenomeDatasetReportRequest {
	r.filtersIsMetagenomeDerived = &filtersIsMetagenomeDerived
	return r
}

// If true, include only type materials
func (r GenomeApiGenomeDatasetReportRequest) FiltersIsTypeMaterial(filtersIsTypeMaterial bool) GenomeApiGenomeDatasetReportRequest {
	r.filtersIsTypeMaterial = &filtersIsTypeMaterial
	return r
}

// If true, include only ICTV Exemplars
func (r GenomeApiGenomeDatasetReportRequest) FiltersIsIctvExemplar(filtersIsIctvExemplar bool) GenomeApiGenomeDatasetReportRequest {
	r.filtersIsIctvExemplar = &filtersIsIctvExemplar
	return r
}

// If true, exclude large multi-isolate projects
func (r GenomeApiGenomeDatasetReportRequest) FiltersExcludeMultiIsolate(filtersExcludeMultiIsolate bool) GenomeApiGenomeDatasetReportRequest {
	r.filtersExcludeMultiIsolate = &filtersExcludeMultiIsolate
	return r
}

func (r GenomeApiGenomeDatasetReportRequest) FiltersTypeMaterialCategory(filtersTypeMaterialCategory V2AssemblyDatasetDescriptorsFilterTypeMaterialCategory) GenomeApiGenomeDatasetReportRequest {
	r.filtersTypeMaterialCategory = &filtersTypeMaterialCategory
	return r
}

// If true, only return assemblies with the given NCBI Taxonomy ID, or name. Otherwise, assemblies from taxonomy subtree are included, too.
func (r GenomeApiGenomeDatasetReportRequest) TaxExactMatch(taxExactMatch bool) GenomeApiGenomeDatasetReportRequest {
	r.taxExactMatch = &taxExactMatch
	return r
}

func (r GenomeApiGenomeDatasetReportRequest) TableFields(tableFields []string) GenomeApiGenomeDatasetReportRequest {
	r.tableFields = &tableFields
	return r
}

// Return either assembly accessions, or complete assembly reports
func (r GenomeApiGenomeDatasetReportRequest) ReturnedContent(returnedContent V2AssemblyDatasetReportsRequestContentType) GenomeApiGenomeDatasetReportRequest {
	r.returnedContent = &returnedContent
	return r
}

// The maximum number of genome assembly reports to return. Default is 20 and maximum is 1000. If the number of results exceeds the page size, &#x60;page_token&#x60; can be used to retrieve the remaining results.
func (r GenomeApiGenomeDatasetReportRequest) PageSize(pageSize int32) GenomeApiGenomeDatasetReportRequest {
	r.pageSize = &pageSize
	return r
}

// A page token is returned from an &#x60;AssemblyDatasetReportsRequest&#x60; call with more than &#x60;page_size&#x60; results. Use this token, along with the previous &#x60;AssemblyDatasetReportsRequest&#x60; parameters, to retrieve the next page of results. When &#x60;page_token&#x60; is empty, all results have been retrieved.
func (r GenomeApiGenomeDatasetReportRequest) PageToken(pageToken string) GenomeApiGenomeDatasetReportRequest {
	r.pageToken = &pageToken
	return r
}

func (r GenomeApiGenomeDatasetReportRequest) SortField(sortField string) GenomeApiGenomeDatasetReportRequest {
	r.sortField = &sortField
	return r
}

func (r GenomeApiGenomeDatasetReportRequest) SortDirection(sortDirection V2SortDirection) GenomeApiGenomeDatasetReportRequest {
	r.sortDirection = &sortDirection
	return r
}

// Whether this request for tabular data should include the header row
func (r GenomeApiGenomeDatasetReportRequest) IncludeTabularHeader(includeTabularHeader V2IncludeTabularHeader) GenomeApiGenomeDatasetReportRequest {
	r.includeTabularHeader = &includeTabularHeader
	return r
}

func (r GenomeApiGenomeDatasetReportRequest) Execute() (*V2reportsAssemblyDataReportPage, *http.Response, error) {
	return r.ApiService.GenomeDatasetReportExecute(r)
}

/*
GenomeDatasetReport Get dataset reports by accessions

Get dataset reports by accessions.  By default, in paged JSON format, but also available as tabular (accept: text/tab-separated-values) or json-lines (accept: application/x-ndjson)

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accessions
 @return GenomeApiGenomeDatasetReportRequest
*/
func (a *GenomeApiService) GenomeDatasetReport(ctx context.Context, accessions []string) GenomeApiGenomeDatasetReportRequest {
	return GenomeApiGenomeDatasetReportRequest{
		ApiService: a,
		ctx: ctx,
		accessions: accessions,
	}
}

// Execute executes the request
//  @return V2reportsAssemblyDataReportPage
func (a *GenomeApiService) GenomeDatasetReportExecute(r GenomeApiGenomeDatasetReportRequest) (*V2reportsAssemblyDataReportPage, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V2reportsAssemblyDataReportPage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GenomeApiService.GenomeDatasetReport")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/genome/accession/{accessions}/dataset_report"
	localVarPath = strings.Replace(localVarPath, "{"+"accessions"+"}", url.PathEscape(parameterToString(r.accessions, "csv")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.filtersReferenceOnly != nil {
		localVarQueryParams.Add("filters.reference_only", parameterToString(*r.filtersReferenceOnly, ""))
	}
	if r.filtersAssemblySource != nil {
		localVarQueryParams.Add("filters.assembly_source", parameterToString(*r.filtersAssemblySource, ""))
	}
	if r.filtersHasAnnotation != nil {
		localVarQueryParams.Add("filters.has_annotation", parameterToString(*r.filtersHasAnnotation, ""))
	}
	if r.filtersExcludePairedReports != nil {
		localVarQueryParams.Add("filters.exclude_paired_reports", parameterToString(*r.filtersExcludePairedReports, ""))
	}
	if r.filtersExcludeAtypical != nil {
		localVarQueryParams.Add("filters.exclude_atypical", parameterToString(*r.filtersExcludeAtypical, ""))
	}
	if r.filtersAssemblyVersion != nil {
		localVarQueryParams.Add("filters.assembly_version", parameterToString(*r.filtersAssemblyVersion, ""))
	}
	if r.filtersAssemblyLevel != nil {
		t := *r.filtersAssemblyLevel
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("filters.assembly_level", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("filters.assembly_level", parameterToString(t, "multi"))
		}
	}
	if r.filtersFirstReleaseDate != nil {
		localVarQueryParams.Add("filters.first_release_date", parameterToString(*r.filtersFirstReleaseDate, ""))
	}
	if r.filtersLastReleaseDate != nil {
		localVarQueryParams.Add("filters.last_release_date", parameterToString(*r.filtersLastReleaseDate, ""))
	}
	if r.filtersSearchText != nil {
		t := *r.filtersSearchText
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("filters.search_text", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("filters.search_text", parameterToString(t, "multi"))
		}
	}
	if r.filtersIsMetagenomeDerived != nil {
		localVarQueryParams.Add("filters.is_metagenome_derived", parameterToString(*r.filtersIsMetagenomeDerived, ""))
	}
	if r.filtersIsTypeMaterial != nil {
		localVarQueryParams.Add("filters.is_type_material", parameterToString(*r.filtersIsTypeMaterial, ""))
	}
	if r.filtersIsIctvExemplar != nil {
		localVarQueryParams.Add("filters.is_ictv_exemplar", parameterToString(*r.filtersIsIctvExemplar, ""))
	}
	if r.filtersExcludeMultiIsolate != nil {
		localVarQueryParams.Add("filters.exclude_multi_isolate", parameterToString(*r.filtersExcludeMultiIsolate, ""))
	}
	if r.filtersTypeMaterialCategory != nil {
		localVarQueryParams.Add("filters.type_material_category", parameterToString(*r.filtersTypeMaterialCategory, ""))
	}
	if r.taxExactMatch != nil {
		localVarQueryParams.Add("tax_exact_match", parameterToString(*r.taxExactMatch, ""))
	}
	if r.tableFields != nil {
		t := *r.tableFields
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("table_fields", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("table_fields", parameterToString(t, "multi"))
		}
	}
	if r.returnedContent != nil {
		localVarQueryParams.Add("returned_content", parameterToString(*r.returnedContent, ""))
	}
	if r.pageSize != nil {
		localVarQueryParams.Add("page_size", parameterToString(*r.pageSize, ""))
	}
	if r.pageToken != nil {
		localVarQueryParams.Add("page_token", parameterToString(*r.pageToken, ""))
	}
	if r.sortField != nil {
		localVarQueryParams.Add("sort.field", parameterToString(*r.sortField, ""))
	}
	if r.sortDirection != nil {
		localVarQueryParams.Add("sort.direction", parameterToString(*r.sortDirection, ""))
	}
	if r.includeTabularHeader != nil {
		localVarQueryParams.Add("include_tabular_header", parameterToString(*r.includeTabularHeader, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "application/x-ndjson", "text/tab-separated-values"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuthHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v RpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type GenomeApiGenomeDatasetReportByPostRequest struct {
	ctx context.Context
	ApiService *GenomeApiService
	v2AssemblyDatasetReportsRequest *V2AssemblyDatasetReportsRequest
}

func (r GenomeApiGenomeDatasetReportByPostRequest) V2AssemblyDatasetReportsRequest(v2AssemblyDatasetReportsRequest V2AssemblyDatasetReportsRequest) GenomeApiGenomeDatasetReportByPostRequest {
	r.v2AssemblyDatasetReportsRequest = &v2AssemblyDatasetReportsRequest
	return r
}

func (r GenomeApiGenomeDatasetReportByPostRequest) Execute() (*V2reportsAssemblyDataReportPage, *http.Response, error) {
	return r.ApiService.GenomeDatasetReportByPostExecute(r)
}

/*
GenomeDatasetReportByPost Get dataset reports by accessions

Get a dataset report by accession.  By default, in paged JSON format, but also available as tabular (accept: text/tab-separated-values) or json-lines (accept: application/x-ndjson)

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return GenomeApiGenomeDatasetReportByPostRequest
*/
func (a *GenomeApiService) GenomeDatasetReportByPost(ctx context.Context) GenomeApiGenomeDatasetReportByPostRequest {
	return GenomeApiGenomeDatasetReportByPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V2reportsAssemblyDataReportPage
func (a *GenomeApiService) GenomeDatasetReportByPostExecute(r GenomeApiGenomeDatasetReportByPostRequest) (*V2reportsAssemblyDataReportPage, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V2reportsAssemblyDataReportPage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GenomeApiService.GenomeDatasetReportByPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/genome/dataset_report"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.v2AssemblyDatasetReportsRequest == nil {
		return localVarReturnValue, nil, reportError("v2AssemblyDatasetReportsRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "application/x-ndjson", "text/tab-separated-values"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.v2AssemblyDatasetReportsRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuthHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v RpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type GenomeApiGenomeDatasetReportsByAssemblyNameRequest struct {
	ctx context.Context
	ApiService *GenomeApiService
	assemblyNames []string
	filtersReferenceOnly *bool
	filtersAssemblySource *V2AssemblyDatasetDescriptorsFilterAssemblySource
	filtersHasAnnotation *bool
	filtersExcludePairedReports *bool
	filtersExcludeAtypical *bool
	filtersAssemblyVersion *V2AssemblyDatasetDescriptorsFilterAssemblyVersion
	filtersAssemblyLevel *[]V2reportsAssemblyLevel
	filtersFirstReleaseDate *time.Time
	filtersLastReleaseDate *time.Time
	filtersSearchText *[]string
	filtersIsMetagenomeDerived *V2AssemblyDatasetDescriptorsFilterMetagenomeDerivedFilter
	filtersIsTypeMaterial *bool
	filtersIsIctvExemplar *bool
	filtersExcludeMultiIsolate *bool
	filtersTypeMaterialCategory *V2AssemblyDatasetDescriptorsFilterTypeMaterialCategory
	taxExactMatch *bool
	tableFields *[]string
	returnedContent *V2AssemblyDatasetReportsRequestContentType
	pageSize *int32
	pageToken *string
	sortField *string
	sortDirection *V2SortDirection
	includeTabularHeader *V2IncludeTabularHeader
}

// If true, only return reference and representative (GCF_ and GCA_) genome assemblies.
func (r GenomeApiGenomeDatasetReportsByAssemblyNameRequest) FiltersReferenceOnly(filtersReferenceOnly bool) GenomeApiGenomeDatasetReportsByAssemblyNameRequest {
	r.filtersReferenceOnly = &filtersReferenceOnly
	return r
}

// Return only RefSeq (GCF_) or GenBank (GCA_) genome assemblies
func (r GenomeApiGenomeDatasetReportsByAssemblyNameRequest) FiltersAssemblySource(filtersAssemblySource V2AssemblyDatasetDescriptorsFilterAssemblySource) GenomeApiGenomeDatasetReportsByAssemblyNameRequest {
	r.filtersAssemblySource = &filtersAssemblySource
	return r
}

// Return only annotated genome assemblies
func (r GenomeApiGenomeDatasetReportsByAssemblyNameRequest) FiltersHasAnnotation(filtersHasAnnotation bool) GenomeApiGenomeDatasetReportsByAssemblyNameRequest {
	r.filtersHasAnnotation = &filtersHasAnnotation
	return r
}

// For paired (GCA/GCF) records, only return the primary record
func (r GenomeApiGenomeDatasetReportsByAssemblyNameRequest) FiltersExcludePairedReports(filtersExcludePairedReports bool) GenomeApiGenomeDatasetReportsByAssemblyNameRequest {
	r.filtersExcludePairedReports = &filtersExcludePairedReports
	return r
}

// If true, exclude atypical genomes, i.e. genomes that have assembly issues or are otherwise atypical
func (r GenomeApiGenomeDatasetReportsByAssemblyNameRequest) FiltersExcludeAtypical(filtersExcludeAtypical bool) GenomeApiGenomeDatasetReportsByAssemblyNameRequest {
	r.filtersExcludeAtypical = &filtersExcludeAtypical
	return r
}

// Return all assemblies, including replaced and suppressed, or only current assemblies
func (r GenomeApiGenomeDatasetReportsByAssemblyNameRequest) FiltersAssemblyVersion(filtersAssemblyVersion V2AssemblyDatasetDescriptorsFilterAssemblyVersion) GenomeApiGenomeDatasetReportsByAssemblyNameRequest {
	r.filtersAssemblyVersion = &filtersAssemblyVersion
	return r
}

// Only return genome assemblies that have one of the specified assembly levels. By default, do not filter.
func (r GenomeApiGenomeDatasetReportsByAssemblyNameRequest) FiltersAssemblyLevel(filtersAssemblyLevel []V2reportsAssemblyLevel) GenomeApiGenomeDatasetReportsByAssemblyNameRequest {
	r.filtersAssemblyLevel = &filtersAssemblyLevel
	return r
}

// Only return genome assemblies that were released on or after the specified date By default, do not filter.
func (r GenomeApiGenomeDatasetReportsByAssemblyNameRequest) FiltersFirstReleaseDate(filtersFirstReleaseDate time.Time) GenomeApiGenomeDatasetReportsByAssemblyNameRequest {
	r.filtersFirstReleaseDate = &filtersFirstReleaseDate
	return r
}

// Only return genome assemblies that were released on or before to the specified date By default, do not filter.
func (r GenomeApiGenomeDatasetReportsByAssemblyNameRequest) FiltersLastReleaseDate(filtersLastReleaseDate time.Time) GenomeApiGenomeDatasetReportsByAssemblyNameRequest {
	r.filtersLastReleaseDate = &filtersLastReleaseDate
	return r
}

// Only return results whose fields contain the specified search terms in their taxon, infraspecific, assembly name or submitter fields By default, do not filter
func (r GenomeApiGenomeDatasetReportsByAssemblyNameRequest) FiltersSearchText(filtersSearchText []string) GenomeApiGenomeDatasetReportsByAssemblyNameRequest {
	r.filtersSearchText = &filtersSearchText
	return r
}

func (r GenomeApiGenomeDatasetReportsByAssemblyNameRequest) FiltersIsMetagenomeDerived(filtersIsMetagenomeDerived V2AssemblyDatasetDescriptorsFilterMetagenomeDerivedFilter) GenomeApiGenomeDatasetReportsByAssemblyNameRequest {
	r.filtersIsMetagenomeDerived = &filtersIsMetagenomeDerived
	return r
}

// If true, include only type materials
func (r GenomeApiGenomeDatasetReportsByAssemblyNameRequest) FiltersIsTypeMaterial(filtersIsTypeMaterial bool) GenomeApiGenomeDatasetReportsByAssemblyNameRequest {
	r.filtersIsTypeMaterial = &filtersIsTypeMaterial
	return r
}

// If true, include only ICTV Exemplars
func (r GenomeApiGenomeDatasetReportsByAssemblyNameRequest) FiltersIsIctvExemplar(filtersIsIctvExemplar bool) GenomeApiGenomeDatasetReportsByAssemblyNameRequest {
	r.filtersIsIctvExemplar = &filtersIsIctvExemplar
	return r
}

// If true, exclude large multi-isolate projects
func (r GenomeApiGenomeDatasetReportsByAssemblyNameRequest) FiltersExcludeMultiIsolate(filtersExcludeMultiIsolate bool) GenomeApiGenomeDatasetReportsByAssemblyNameRequest {
	r.filtersExcludeMultiIsolate = &filtersExcludeMultiIsolate
	return r
}

func (r GenomeApiGenomeDatasetReportsByAssemblyNameRequest) FiltersTypeMaterialCategory(filtersTypeMaterialCategory V2AssemblyDatasetDescriptorsFilterTypeMaterialCategory) GenomeApiGenomeDatasetReportsByAssemblyNameRequest {
	r.filtersTypeMaterialCategory = &filtersTypeMaterialCategory
	return r
}

// If true, only return assemblies with the given NCBI Taxonomy ID, or name. Otherwise, assemblies from taxonomy subtree are included, too.
func (r GenomeApiGenomeDatasetReportsByAssemblyNameRequest) TaxExactMatch(taxExactMatch bool) GenomeApiGenomeDatasetReportsByAssemblyNameRequest {
	r.taxExactMatch = &taxExactMatch
	return r
}

func (r GenomeApiGenomeDatasetReportsByAssemblyNameRequest) TableFields(tableFields []string) GenomeApiGenomeDatasetReportsByAssemblyNameRequest {
	r.tableFields = &tableFields
	return r
}

// Return either assembly accessions, or complete assembly reports
func (r GenomeApiGenomeDatasetReportsByAssemblyNameRequest) ReturnedContent(returnedContent V2AssemblyDatasetReportsRequestContentType) GenomeApiGenomeDatasetReportsByAssemblyNameRequest {
	r.returnedContent = &returnedContent
	return r
}

// The maximum number of genome assembly reports to return. Default is 20 and maximum is 1000. If the number of results exceeds the page size, &#x60;page_token&#x60; can be used to retrieve the remaining results.
func (r GenomeApiGenomeDatasetReportsByAssemblyNameRequest) PageSize(pageSize int32) GenomeApiGenomeDatasetReportsByAssemblyNameRequest {
	r.pageSize = &pageSize
	return r
}

// A page token is returned from an &#x60;AssemblyDatasetReportsRequest&#x60; call with more than &#x60;page_size&#x60; results. Use this token, along with the previous &#x60;AssemblyDatasetReportsRequest&#x60; parameters, to retrieve the next page of results. When &#x60;page_token&#x60; is empty, all results have been retrieved.
func (r GenomeApiGenomeDatasetReportsByAssemblyNameRequest) PageToken(pageToken string) GenomeApiGenomeDatasetReportsByAssemblyNameRequest {
	r.pageToken = &pageToken
	return r
}

func (r GenomeApiGenomeDatasetReportsByAssemblyNameRequest) SortField(sortField string) GenomeApiGenomeDatasetReportsByAssemblyNameRequest {
	r.sortField = &sortField
	return r
}

func (r GenomeApiGenomeDatasetReportsByAssemblyNameRequest) SortDirection(sortDirection V2SortDirection) GenomeApiGenomeDatasetReportsByAssemblyNameRequest {
	r.sortDirection = &sortDirection
	return r
}

// Whether this request for tabular data should include the header row
func (r GenomeApiGenomeDatasetReportsByAssemblyNameRequest) IncludeTabularHeader(includeTabularHeader V2IncludeTabularHeader) GenomeApiGenomeDatasetReportsByAssemblyNameRequest {
	r.includeTabularHeader = &includeTabularHeader
	return r
}

func (r GenomeApiGenomeDatasetReportsByAssemblyNameRequest) Execute() (*V2reportsAssemblyDataReportPage, *http.Response, error) {
	return r.ApiService.GenomeDatasetReportsByAssemblyNameExecute(r)
}

/*
GenomeDatasetReportsByAssemblyName Get dataset reports by assembly name (exact)

Get dataset reports by assembly name (exact).  By default, in paged JSON format, but also available as tabular (accept: text/tab-separated-values) or json-lines (accept: application/x-ndjson)

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param assemblyNames
 @return GenomeApiGenomeDatasetReportsByAssemblyNameRequest
*/
func (a *GenomeApiService) GenomeDatasetReportsByAssemblyName(ctx context.Context, assemblyNames []string) GenomeApiGenomeDatasetReportsByAssemblyNameRequest {
	return GenomeApiGenomeDatasetReportsByAssemblyNameRequest{
		ApiService: a,
		ctx: ctx,
		assemblyNames: assemblyNames,
	}
}

// Execute executes the request
//  @return V2reportsAssemblyDataReportPage
func (a *GenomeApiService) GenomeDatasetReportsByAssemblyNameExecute(r GenomeApiGenomeDatasetReportsByAssemblyNameRequest) (*V2reportsAssemblyDataReportPage, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V2reportsAssemblyDataReportPage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GenomeApiService.GenomeDatasetReportsByAssemblyName")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/genome/assembly_name/{assembly_names}/dataset_report"
	localVarPath = strings.Replace(localVarPath, "{"+"assembly_names"+"}", url.PathEscape(parameterToString(r.assemblyNames, "csv")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.filtersReferenceOnly != nil {
		localVarQueryParams.Add("filters.reference_only", parameterToString(*r.filtersReferenceOnly, ""))
	}
	if r.filtersAssemblySource != nil {
		localVarQueryParams.Add("filters.assembly_source", parameterToString(*r.filtersAssemblySource, ""))
	}
	if r.filtersHasAnnotation != nil {
		localVarQueryParams.Add("filters.has_annotation", parameterToString(*r.filtersHasAnnotation, ""))
	}
	if r.filtersExcludePairedReports != nil {
		localVarQueryParams.Add("filters.exclude_paired_reports", parameterToString(*r.filtersExcludePairedReports, ""))
	}
	if r.filtersExcludeAtypical != nil {
		localVarQueryParams.Add("filters.exclude_atypical", parameterToString(*r.filtersExcludeAtypical, ""))
	}
	if r.filtersAssemblyVersion != nil {
		localVarQueryParams.Add("filters.assembly_version", parameterToString(*r.filtersAssemblyVersion, ""))
	}
	if r.filtersAssemblyLevel != nil {
		t := *r.filtersAssemblyLevel
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("filters.assembly_level", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("filters.assembly_level", parameterToString(t, "multi"))
		}
	}
	if r.filtersFirstReleaseDate != nil {
		localVarQueryParams.Add("filters.first_release_date", parameterToString(*r.filtersFirstReleaseDate, ""))
	}
	if r.filtersLastReleaseDate != nil {
		localVarQueryParams.Add("filters.last_release_date", parameterToString(*r.filtersLastReleaseDate, ""))
	}
	if r.filtersSearchText != nil {
		t := *r.filtersSearchText
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("filters.search_text", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("filters.search_text", parameterToString(t, "multi"))
		}
	}
	if r.filtersIsMetagenomeDerived != nil {
		localVarQueryParams.Add("filters.is_metagenome_derived", parameterToString(*r.filtersIsMetagenomeDerived, ""))
	}
	if r.filtersIsTypeMaterial != nil {
		localVarQueryParams.Add("filters.is_type_material", parameterToString(*r.filtersIsTypeMaterial, ""))
	}
	if r.filtersIsIctvExemplar != nil {
		localVarQueryParams.Add("filters.is_ictv_exemplar", parameterToString(*r.filtersIsIctvExemplar, ""))
	}
	if r.filtersExcludeMultiIsolate != nil {
		localVarQueryParams.Add("filters.exclude_multi_isolate", parameterToString(*r.filtersExcludeMultiIsolate, ""))
	}
	if r.filtersTypeMaterialCategory != nil {
		localVarQueryParams.Add("filters.type_material_category", parameterToString(*r.filtersTypeMaterialCategory, ""))
	}
	if r.taxExactMatch != nil {
		localVarQueryParams.Add("tax_exact_match", parameterToString(*r.taxExactMatch, ""))
	}
	if r.tableFields != nil {
		t := *r.tableFields
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("table_fields", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("table_fields", parameterToString(t, "multi"))
		}
	}
	if r.returnedContent != nil {
		localVarQueryParams.Add("returned_content", parameterToString(*r.returnedContent, ""))
	}
	if r.pageSize != nil {
		localVarQueryParams.Add("page_size", parameterToString(*r.pageSize, ""))
	}
	if r.pageToken != nil {
		localVarQueryParams.Add("page_token", parameterToString(*r.pageToken, ""))
	}
	if r.sortField != nil {
		localVarQueryParams.Add("sort.field", parameterToString(*r.sortField, ""))
	}
	if r.sortDirection != nil {
		localVarQueryParams.Add("sort.direction", parameterToString(*r.sortDirection, ""))
	}
	if r.includeTabularHeader != nil {
		localVarQueryParams.Add("include_tabular_header", parameterToString(*r.includeTabularHeader, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "application/x-ndjson", "text/tab-separated-values"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuthHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v RpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type GenomeApiGenomeDatasetReportsByBioprojectRequest struct {
	ctx context.Context
	ApiService *GenomeApiService
	bioprojects []string
	filtersReferenceOnly *bool
	filtersAssemblySource *V2AssemblyDatasetDescriptorsFilterAssemblySource
	filtersHasAnnotation *bool
	filtersExcludePairedReports *bool
	filtersExcludeAtypical *bool
	filtersAssemblyVersion *V2AssemblyDatasetDescriptorsFilterAssemblyVersion
	filtersAssemblyLevel *[]V2reportsAssemblyLevel
	filtersFirstReleaseDate *time.Time
	filtersLastReleaseDate *time.Time
	filtersSearchText *[]string
	filtersIsMetagenomeDerived *V2AssemblyDatasetDescriptorsFilterMetagenomeDerivedFilter
	filtersIsTypeMaterial *bool
	filtersIsIctvExemplar *bool
	filtersExcludeMultiIsolate *bool
	filtersTypeMaterialCategory *V2AssemblyDatasetDescriptorsFilterTypeMaterialCategory
	taxExactMatch *bool
	tableFields *[]string
	returnedContent *V2AssemblyDatasetReportsRequestContentType
	pageSize *int32
	pageToken *string
	sortField *string
	sortDirection *V2SortDirection
	includeTabularHeader *V2IncludeTabularHeader
}

// If true, only return reference and representative (GCF_ and GCA_) genome assemblies.
func (r GenomeApiGenomeDatasetReportsByBioprojectRequest) FiltersReferenceOnly(filtersReferenceOnly bool) GenomeApiGenomeDatasetReportsByBioprojectRequest {
	r.filtersReferenceOnly = &filtersReferenceOnly
	return r
}

// Return only RefSeq (GCF_) or GenBank (GCA_) genome assemblies
func (r GenomeApiGenomeDatasetReportsByBioprojectRequest) FiltersAssemblySource(filtersAssemblySource V2AssemblyDatasetDescriptorsFilterAssemblySource) GenomeApiGenomeDatasetReportsByBioprojectRequest {
	r.filtersAssemblySource = &filtersAssemblySource
	return r
}

// Return only annotated genome assemblies
func (r GenomeApiGenomeDatasetReportsByBioprojectRequest) FiltersHasAnnotation(filtersHasAnnotation bool) GenomeApiGenomeDatasetReportsByBioprojectRequest {
	r.filtersHasAnnotation = &filtersHasAnnotation
	return r
}

// For paired (GCA/GCF) records, only return the primary record
func (r GenomeApiGenomeDatasetReportsByBioprojectRequest) FiltersExcludePairedReports(filtersExcludePairedReports bool) GenomeApiGenomeDatasetReportsByBioprojectRequest {
	r.filtersExcludePairedReports = &filtersExcludePairedReports
	return r
}

// If true, exclude atypical genomes, i.e. genomes that have assembly issues or are otherwise atypical
func (r GenomeApiGenomeDatasetReportsByBioprojectRequest) FiltersExcludeAtypical(filtersExcludeAtypical bool) GenomeApiGenomeDatasetReportsByBioprojectRequest {
	r.filtersExcludeAtypical = &filtersExcludeAtypical
	return r
}

// Return all assemblies, including replaced and suppressed, or only current assemblies
func (r GenomeApiGenomeDatasetReportsByBioprojectRequest) FiltersAssemblyVersion(filtersAssemblyVersion V2AssemblyDatasetDescriptorsFilterAssemblyVersion) GenomeApiGenomeDatasetReportsByBioprojectRequest {
	r.filtersAssemblyVersion = &filtersAssemblyVersion
	return r
}

// Only return genome assemblies that have one of the specified assembly levels. By default, do not filter.
func (r GenomeApiGenomeDatasetReportsByBioprojectRequest) FiltersAssemblyLevel(filtersAssemblyLevel []V2reportsAssemblyLevel) GenomeApiGenomeDatasetReportsByBioprojectRequest {
	r.filtersAssemblyLevel = &filtersAssemblyLevel
	return r
}

// Only return genome assemblies that were released on or after the specified date By default, do not filter.
func (r GenomeApiGenomeDatasetReportsByBioprojectRequest) FiltersFirstReleaseDate(filtersFirstReleaseDate time.Time) GenomeApiGenomeDatasetReportsByBioprojectRequest {
	r.filtersFirstReleaseDate = &filtersFirstReleaseDate
	return r
}

// Only return genome assemblies that were released on or before to the specified date By default, do not filter.
func (r GenomeApiGenomeDatasetReportsByBioprojectRequest) FiltersLastReleaseDate(filtersLastReleaseDate time.Time) GenomeApiGenomeDatasetReportsByBioprojectRequest {
	r.filtersLastReleaseDate = &filtersLastReleaseDate
	return r
}

// Only return results whose fields contain the specified search terms in their taxon, infraspecific, assembly name or submitter fields By default, do not filter
func (r GenomeApiGenomeDatasetReportsByBioprojectRequest) FiltersSearchText(filtersSearchText []string) GenomeApiGenomeDatasetReportsByBioprojectRequest {
	r.filtersSearchText = &filtersSearchText
	return r
}

func (r GenomeApiGenomeDatasetReportsByBioprojectRequest) FiltersIsMetagenomeDerived(filtersIsMetagenomeDerived V2AssemblyDatasetDescriptorsFilterMetagenomeDerivedFilter) GenomeApiGenomeDatasetReportsByBioprojectRequest {
	r.filtersIsMetagenomeDerived = &filtersIsMetagenomeDerived
	return r
}

// If true, include only type materials
func (r GenomeApiGenomeDatasetReportsByBioprojectRequest) FiltersIsTypeMaterial(filtersIsTypeMaterial bool) GenomeApiGenomeDatasetReportsByBioprojectRequest {
	r.filtersIsTypeMaterial = &filtersIsTypeMaterial
	return r
}

// If true, include only ICTV Exemplars
func (r GenomeApiGenomeDatasetReportsByBioprojectRequest) FiltersIsIctvExemplar(filtersIsIctvExemplar bool) GenomeApiGenomeDatasetReportsByBioprojectRequest {
	r.filtersIsIctvExemplar = &filtersIsIctvExemplar
	return r
}

// If true, exclude large multi-isolate projects
func (r GenomeApiGenomeDatasetReportsByBioprojectRequest) FiltersExcludeMultiIsolate(filtersExcludeMultiIsolate bool) GenomeApiGenomeDatasetReportsByBioprojectRequest {
	r.filtersExcludeMultiIsolate = &filtersExcludeMultiIsolate
	return r
}

func (r GenomeApiGenomeDatasetReportsByBioprojectRequest) FiltersTypeMaterialCategory(filtersTypeMaterialCategory V2AssemblyDatasetDescriptorsFilterTypeMaterialCategory) GenomeApiGenomeDatasetReportsByBioprojectRequest {
	r.filtersTypeMaterialCategory = &filtersTypeMaterialCategory
	return r
}

// If true, only return assemblies with the given NCBI Taxonomy ID, or name. Otherwise, assemblies from taxonomy subtree are included, too.
func (r GenomeApiGenomeDatasetReportsByBioprojectRequest) TaxExactMatch(taxExactMatch bool) GenomeApiGenomeDatasetReportsByBioprojectRequest {
	r.taxExactMatch = &taxExactMatch
	return r
}

func (r GenomeApiGenomeDatasetReportsByBioprojectRequest) TableFields(tableFields []string) GenomeApiGenomeDatasetReportsByBioprojectRequest {
	r.tableFields = &tableFields
	return r
}

// Return either assembly accessions, or complete assembly reports
func (r GenomeApiGenomeDatasetReportsByBioprojectRequest) ReturnedContent(returnedContent V2AssemblyDatasetReportsRequestContentType) GenomeApiGenomeDatasetReportsByBioprojectRequest {
	r.returnedContent = &returnedContent
	return r
}

// The maximum number of genome assembly reports to return. Default is 20 and maximum is 1000. If the number of results exceeds the page size, &#x60;page_token&#x60; can be used to retrieve the remaining results.
func (r GenomeApiGenomeDatasetReportsByBioprojectRequest) PageSize(pageSize int32) GenomeApiGenomeDatasetReportsByBioprojectRequest {
	r.pageSize = &pageSize
	return r
}

// A page token is returned from an &#x60;AssemblyDatasetReportsRequest&#x60; call with more than &#x60;page_size&#x60; results. Use this token, along with the previous &#x60;AssemblyDatasetReportsRequest&#x60; parameters, to retrieve the next page of results. When &#x60;page_token&#x60; is empty, all results have been retrieved.
func (r GenomeApiGenomeDatasetReportsByBioprojectRequest) PageToken(pageToken string) GenomeApiGenomeDatasetReportsByBioprojectRequest {
	r.pageToken = &pageToken
	return r
}

func (r GenomeApiGenomeDatasetReportsByBioprojectRequest) SortField(sortField string) GenomeApiGenomeDatasetReportsByBioprojectRequest {
	r.sortField = &sortField
	return r
}

func (r GenomeApiGenomeDatasetReportsByBioprojectRequest) SortDirection(sortDirection V2SortDirection) GenomeApiGenomeDatasetReportsByBioprojectRequest {
	r.sortDirection = &sortDirection
	return r
}

// Whether this request for tabular data should include the header row
func (r GenomeApiGenomeDatasetReportsByBioprojectRequest) IncludeTabularHeader(includeTabularHeader V2IncludeTabularHeader) GenomeApiGenomeDatasetReportsByBioprojectRequest {
	r.includeTabularHeader = &includeTabularHeader
	return r
}

func (r GenomeApiGenomeDatasetReportsByBioprojectRequest) Execute() (*V2reportsAssemblyDataReportPage, *http.Response, error) {
	return r.ApiService.GenomeDatasetReportsByBioprojectExecute(r)
}

/*
GenomeDatasetReportsByBioproject Get dataset reports by bioproject

Get dataset reports by bioprojects.  By default, in paged JSON format, but also available as tabular (accept: text/tab-separated-values) or json-lines (accept: application/x-ndjson)

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param bioprojects
 @return GenomeApiGenomeDatasetReportsByBioprojectRequest
*/
func (a *GenomeApiService) GenomeDatasetReportsByBioproject(ctx context.Context, bioprojects []string) GenomeApiGenomeDatasetReportsByBioprojectRequest {
	return GenomeApiGenomeDatasetReportsByBioprojectRequest{
		ApiService: a,
		ctx: ctx,
		bioprojects: bioprojects,
	}
}

// Execute executes the request
//  @return V2reportsAssemblyDataReportPage
func (a *GenomeApiService) GenomeDatasetReportsByBioprojectExecute(r GenomeApiGenomeDatasetReportsByBioprojectRequest) (*V2reportsAssemblyDataReportPage, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V2reportsAssemblyDataReportPage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GenomeApiService.GenomeDatasetReportsByBioproject")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/genome/bioproject/{bioprojects}/dataset_report"
	localVarPath = strings.Replace(localVarPath, "{"+"bioprojects"+"}", url.PathEscape(parameterToString(r.bioprojects, "csv")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.filtersReferenceOnly != nil {
		localVarQueryParams.Add("filters.reference_only", parameterToString(*r.filtersReferenceOnly, ""))
	}
	if r.filtersAssemblySource != nil {
		localVarQueryParams.Add("filters.assembly_source", parameterToString(*r.filtersAssemblySource, ""))
	}
	if r.filtersHasAnnotation != nil {
		localVarQueryParams.Add("filters.has_annotation", parameterToString(*r.filtersHasAnnotation, ""))
	}
	if r.filtersExcludePairedReports != nil {
		localVarQueryParams.Add("filters.exclude_paired_reports", parameterToString(*r.filtersExcludePairedReports, ""))
	}
	if r.filtersExcludeAtypical != nil {
		localVarQueryParams.Add("filters.exclude_atypical", parameterToString(*r.filtersExcludeAtypical, ""))
	}
	if r.filtersAssemblyVersion != nil {
		localVarQueryParams.Add("filters.assembly_version", parameterToString(*r.filtersAssemblyVersion, ""))
	}
	if r.filtersAssemblyLevel != nil {
		t := *r.filtersAssemblyLevel
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("filters.assembly_level", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("filters.assembly_level", parameterToString(t, "multi"))
		}
	}
	if r.filtersFirstReleaseDate != nil {
		localVarQueryParams.Add("filters.first_release_date", parameterToString(*r.filtersFirstReleaseDate, ""))
	}
	if r.filtersLastReleaseDate != nil {
		localVarQueryParams.Add("filters.last_release_date", parameterToString(*r.filtersLastReleaseDate, ""))
	}
	if r.filtersSearchText != nil {
		t := *r.filtersSearchText
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("filters.search_text", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("filters.search_text", parameterToString(t, "multi"))
		}
	}
	if r.filtersIsMetagenomeDerived != nil {
		localVarQueryParams.Add("filters.is_metagenome_derived", parameterToString(*r.filtersIsMetagenomeDerived, ""))
	}
	if r.filtersIsTypeMaterial != nil {
		localVarQueryParams.Add("filters.is_type_material", parameterToString(*r.filtersIsTypeMaterial, ""))
	}
	if r.filtersIsIctvExemplar != nil {
		localVarQueryParams.Add("filters.is_ictv_exemplar", parameterToString(*r.filtersIsIctvExemplar, ""))
	}
	if r.filtersExcludeMultiIsolate != nil {
		localVarQueryParams.Add("filters.exclude_multi_isolate", parameterToString(*r.filtersExcludeMultiIsolate, ""))
	}
	if r.filtersTypeMaterialCategory != nil {
		localVarQueryParams.Add("filters.type_material_category", parameterToString(*r.filtersTypeMaterialCategory, ""))
	}
	if r.taxExactMatch != nil {
		localVarQueryParams.Add("tax_exact_match", parameterToString(*r.taxExactMatch, ""))
	}
	if r.tableFields != nil {
		t := *r.tableFields
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("table_fields", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("table_fields", parameterToString(t, "multi"))
		}
	}
	if r.returnedContent != nil {
		localVarQueryParams.Add("returned_content", parameterToString(*r.returnedContent, ""))
	}
	if r.pageSize != nil {
		localVarQueryParams.Add("page_size", parameterToString(*r.pageSize, ""))
	}
	if r.pageToken != nil {
		localVarQueryParams.Add("page_token", parameterToString(*r.pageToken, ""))
	}
	if r.sortField != nil {
		localVarQueryParams.Add("sort.field", parameterToString(*r.sortField, ""))
	}
	if r.sortDirection != nil {
		localVarQueryParams.Add("sort.direction", parameterToString(*r.sortDirection, ""))
	}
	if r.includeTabularHeader != nil {
		localVarQueryParams.Add("include_tabular_header", parameterToString(*r.includeTabularHeader, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "application/x-ndjson", "text/tab-separated-values"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuthHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v RpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type GenomeApiGenomeDatasetReportsByBiosampleIdRequest struct {
	ctx context.Context
	ApiService *GenomeApiService
	biosampleIds []string
	filtersReferenceOnly *bool
	filtersAssemblySource *V2AssemblyDatasetDescriptorsFilterAssemblySource
	filtersHasAnnotation *bool
	filtersExcludePairedReports *bool
	filtersExcludeAtypical *bool
	filtersAssemblyVersion *V2AssemblyDatasetDescriptorsFilterAssemblyVersion
	filtersAssemblyLevel *[]V2reportsAssemblyLevel
	filtersFirstReleaseDate *time.Time
	filtersLastReleaseDate *time.Time
	filtersSearchText *[]string
	filtersIsMetagenomeDerived *V2AssemblyDatasetDescriptorsFilterMetagenomeDerivedFilter
	filtersIsTypeMaterial *bool
	filtersIsIctvExemplar *bool
	filtersExcludeMultiIsolate *bool
	filtersTypeMaterialCategory *V2AssemblyDatasetDescriptorsFilterTypeMaterialCategory
	taxExactMatch *bool
	tableFields *[]string
	returnedContent *V2AssemblyDatasetReportsRequestContentType
	pageSize *int32
	pageToken *string
	sortField *string
	sortDirection *V2SortDirection
	includeTabularHeader *V2IncludeTabularHeader
}

// If true, only return reference and representative (GCF_ and GCA_) genome assemblies.
func (r GenomeApiGenomeDatasetReportsByBiosampleIdRequest) FiltersReferenceOnly(filtersReferenceOnly bool) GenomeApiGenomeDatasetReportsByBiosampleIdRequest {
	r.filtersReferenceOnly = &filtersReferenceOnly
	return r
}

// Return only RefSeq (GCF_) or GenBank (GCA_) genome assemblies
func (r GenomeApiGenomeDatasetReportsByBiosampleIdRequest) FiltersAssemblySource(filtersAssemblySource V2AssemblyDatasetDescriptorsFilterAssemblySource) GenomeApiGenomeDatasetReportsByBiosampleIdRequest {
	r.filtersAssemblySource = &filtersAssemblySource
	return r
}

// Return only annotated genome assemblies
func (r GenomeApiGenomeDatasetReportsByBiosampleIdRequest) FiltersHasAnnotation(filtersHasAnnotation bool) GenomeApiGenomeDatasetReportsByBiosampleIdRequest {
	r.filtersHasAnnotation = &filtersHasAnnotation
	return r
}

// For paired (GCA/GCF) records, only return the primary record
func (r GenomeApiGenomeDatasetReportsByBiosampleIdRequest) FiltersExcludePairedReports(filtersExcludePairedReports bool) GenomeApiGenomeDatasetReportsByBiosampleIdRequest {
	r.filtersExcludePairedReports = &filtersExcludePairedReports
	return r
}

// If true, exclude atypical genomes, i.e. genomes that have assembly issues or are otherwise atypical
func (r GenomeApiGenomeDatasetReportsByBiosampleIdRequest) FiltersExcludeAtypical(filtersExcludeAtypical bool) GenomeApiGenomeDatasetReportsByBiosampleIdRequest {
	r.filtersExcludeAtypical = &filtersExcludeAtypical
	return r
}

// Return all assemblies, including replaced and suppressed, or only current assemblies
func (r GenomeApiGenomeDatasetReportsByBiosampleIdRequest) FiltersAssemblyVersion(filtersAssemblyVersion V2AssemblyDatasetDescriptorsFilterAssemblyVersion) GenomeApiGenomeDatasetReportsByBiosampleIdRequest {
	r.filtersAssemblyVersion = &filtersAssemblyVersion
	return r
}

// Only return genome assemblies that have one of the specified assembly levels. By default, do not filter.
func (r GenomeApiGenomeDatasetReportsByBiosampleIdRequest) FiltersAssemblyLevel(filtersAssemblyLevel []V2reportsAssemblyLevel) GenomeApiGenomeDatasetReportsByBiosampleIdRequest {
	r.filtersAssemblyLevel = &filtersAssemblyLevel
	return r
}

// Only return genome assemblies that were released on or after the specified date By default, do not filter.
func (r GenomeApiGenomeDatasetReportsByBiosampleIdRequest) FiltersFirstReleaseDate(filtersFirstReleaseDate time.Time) GenomeApiGenomeDatasetReportsByBiosampleIdRequest {
	r.filtersFirstReleaseDate = &filtersFirstReleaseDate
	return r
}

// Only return genome assemblies that were released on or before to the specified date By default, do not filter.
func (r GenomeApiGenomeDatasetReportsByBiosampleIdRequest) FiltersLastReleaseDate(filtersLastReleaseDate time.Time) GenomeApiGenomeDatasetReportsByBiosampleIdRequest {
	r.filtersLastReleaseDate = &filtersLastReleaseDate
	return r
}

// Only return results whose fields contain the specified search terms in their taxon, infraspecific, assembly name or submitter fields By default, do not filter
func (r GenomeApiGenomeDatasetReportsByBiosampleIdRequest) FiltersSearchText(filtersSearchText []string) GenomeApiGenomeDatasetReportsByBiosampleIdRequest {
	r.filtersSearchText = &filtersSearchText
	return r
}

func (r GenomeApiGenomeDatasetReportsByBiosampleIdRequest) FiltersIsMetagenomeDerived(filtersIsMetagenomeDerived V2AssemblyDatasetDescriptorsFilterMetagenomeDerivedFilter) GenomeApiGenomeDatasetReportsByBiosampleIdRequest {
	r.filtersIsMetagenomeDerived = &filtersIsMetagenomeDerived
	return r
}

// If true, include only type materials
func (r GenomeApiGenomeDatasetReportsByBiosampleIdRequest) FiltersIsTypeMaterial(filtersIsTypeMaterial bool) GenomeApiGenomeDatasetReportsByBiosampleIdRequest {
	r.filtersIsTypeMaterial = &filtersIsTypeMaterial
	return r
}

// If true, include only ICTV Exemplars
func (r GenomeApiGenomeDatasetReportsByBiosampleIdRequest) FiltersIsIctvExemplar(filtersIsIctvExemplar bool) GenomeApiGenomeDatasetReportsByBiosampleIdRequest {
	r.filtersIsIctvExemplar = &filtersIsIctvExemplar
	return r
}

// If true, exclude large multi-isolate projects
func (r GenomeApiGenomeDatasetReportsByBiosampleIdRequest) FiltersExcludeMultiIsolate(filtersExcludeMultiIsolate bool) GenomeApiGenomeDatasetReportsByBiosampleIdRequest {
	r.filtersExcludeMultiIsolate = &filtersExcludeMultiIsolate
	return r
}

func (r GenomeApiGenomeDatasetReportsByBiosampleIdRequest) FiltersTypeMaterialCategory(filtersTypeMaterialCategory V2AssemblyDatasetDescriptorsFilterTypeMaterialCategory) GenomeApiGenomeDatasetReportsByBiosampleIdRequest {
	r.filtersTypeMaterialCategory = &filtersTypeMaterialCategory
	return r
}

// If true, only return assemblies with the given NCBI Taxonomy ID, or name. Otherwise, assemblies from taxonomy subtree are included, too.
func (r GenomeApiGenomeDatasetReportsByBiosampleIdRequest) TaxExactMatch(taxExactMatch bool) GenomeApiGenomeDatasetReportsByBiosampleIdRequest {
	r.taxExactMatch = &taxExactMatch
	return r
}

func (r GenomeApiGenomeDatasetReportsByBiosampleIdRequest) TableFields(tableFields []string) GenomeApiGenomeDatasetReportsByBiosampleIdRequest {
	r.tableFields = &tableFields
	return r
}

// Return either assembly accessions, or complete assembly reports
func (r GenomeApiGenomeDatasetReportsByBiosampleIdRequest) ReturnedContent(returnedContent V2AssemblyDatasetReportsRequestContentType) GenomeApiGenomeDatasetReportsByBiosampleIdRequest {
	r.returnedContent = &returnedContent
	return r
}

// The maximum number of genome assembly reports to return. Default is 20 and maximum is 1000. If the number of results exceeds the page size, &#x60;page_token&#x60; can be used to retrieve the remaining results.
func (r GenomeApiGenomeDatasetReportsByBiosampleIdRequest) PageSize(pageSize int32) GenomeApiGenomeDatasetReportsByBiosampleIdRequest {
	r.pageSize = &pageSize
	return r
}

// A page token is returned from an &#x60;AssemblyDatasetReportsRequest&#x60; call with more than &#x60;page_size&#x60; results. Use this token, along with the previous &#x60;AssemblyDatasetReportsRequest&#x60; parameters, to retrieve the next page of results. When &#x60;page_token&#x60; is empty, all results have been retrieved.
func (r GenomeApiGenomeDatasetReportsByBiosampleIdRequest) PageToken(pageToken string) GenomeApiGenomeDatasetReportsByBiosampleIdRequest {
	r.pageToken = &pageToken
	return r
}

func (r GenomeApiGenomeDatasetReportsByBiosampleIdRequest) SortField(sortField string) GenomeApiGenomeDatasetReportsByBiosampleIdRequest {
	r.sortField = &sortField
	return r
}

func (r GenomeApiGenomeDatasetReportsByBiosampleIdRequest) SortDirection(sortDirection V2SortDirection) GenomeApiGenomeDatasetReportsByBiosampleIdRequest {
	r.sortDirection = &sortDirection
	return r
}

// Whether this request for tabular data should include the header row
func (r GenomeApiGenomeDatasetReportsByBiosampleIdRequest) IncludeTabularHeader(includeTabularHeader V2IncludeTabularHeader) GenomeApiGenomeDatasetReportsByBiosampleIdRequest {
	r.includeTabularHeader = &includeTabularHeader
	return r
}

func (r GenomeApiGenomeDatasetReportsByBiosampleIdRequest) Execute() (*V2reportsAssemblyDataReportPage, *http.Response, error) {
	return r.ApiService.GenomeDatasetReportsByBiosampleIdExecute(r)
}

/*
GenomeDatasetReportsByBiosampleId Get dataset reports by biosample id

Get dataset reports by biosample id.  By default, in paged JSON format, but also available as tabular (accept: text/tab-separated-values) or json-lines (accept: application/x-ndjson)

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param biosampleIds
 @return GenomeApiGenomeDatasetReportsByBiosampleIdRequest
*/
func (a *GenomeApiService) GenomeDatasetReportsByBiosampleId(ctx context.Context, biosampleIds []string) GenomeApiGenomeDatasetReportsByBiosampleIdRequest {
	return GenomeApiGenomeDatasetReportsByBiosampleIdRequest{
		ApiService: a,
		ctx: ctx,
		biosampleIds: biosampleIds,
	}
}

// Execute executes the request
//  @return V2reportsAssemblyDataReportPage
func (a *GenomeApiService) GenomeDatasetReportsByBiosampleIdExecute(r GenomeApiGenomeDatasetReportsByBiosampleIdRequest) (*V2reportsAssemblyDataReportPage, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V2reportsAssemblyDataReportPage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GenomeApiService.GenomeDatasetReportsByBiosampleId")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/genome/biosample/{biosample_ids}/dataset_report"
	localVarPath = strings.Replace(localVarPath, "{"+"biosample_ids"+"}", url.PathEscape(parameterToString(r.biosampleIds, "csv")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.filtersReferenceOnly != nil {
		localVarQueryParams.Add("filters.reference_only", parameterToString(*r.filtersReferenceOnly, ""))
	}
	if r.filtersAssemblySource != nil {
		localVarQueryParams.Add("filters.assembly_source", parameterToString(*r.filtersAssemblySource, ""))
	}
	if r.filtersHasAnnotation != nil {
		localVarQueryParams.Add("filters.has_annotation", parameterToString(*r.filtersHasAnnotation, ""))
	}
	if r.filtersExcludePairedReports != nil {
		localVarQueryParams.Add("filters.exclude_paired_reports", parameterToString(*r.filtersExcludePairedReports, ""))
	}
	if r.filtersExcludeAtypical != nil {
		localVarQueryParams.Add("filters.exclude_atypical", parameterToString(*r.filtersExcludeAtypical, ""))
	}
	if r.filtersAssemblyVersion != nil {
		localVarQueryParams.Add("filters.assembly_version", parameterToString(*r.filtersAssemblyVersion, ""))
	}
	if r.filtersAssemblyLevel != nil {
		t := *r.filtersAssemblyLevel
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("filters.assembly_level", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("filters.assembly_level", parameterToString(t, "multi"))
		}
	}
	if r.filtersFirstReleaseDate != nil {
		localVarQueryParams.Add("filters.first_release_date", parameterToString(*r.filtersFirstReleaseDate, ""))
	}
	if r.filtersLastReleaseDate != nil {
		localVarQueryParams.Add("filters.last_release_date", parameterToString(*r.filtersLastReleaseDate, ""))
	}
	if r.filtersSearchText != nil {
		t := *r.filtersSearchText
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("filters.search_text", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("filters.search_text", parameterToString(t, "multi"))
		}
	}
	if r.filtersIsMetagenomeDerived != nil {
		localVarQueryParams.Add("filters.is_metagenome_derived", parameterToString(*r.filtersIsMetagenomeDerived, ""))
	}
	if r.filtersIsTypeMaterial != nil {
		localVarQueryParams.Add("filters.is_type_material", parameterToString(*r.filtersIsTypeMaterial, ""))
	}
	if r.filtersIsIctvExemplar != nil {
		localVarQueryParams.Add("filters.is_ictv_exemplar", parameterToString(*r.filtersIsIctvExemplar, ""))
	}
	if r.filtersExcludeMultiIsolate != nil {
		localVarQueryParams.Add("filters.exclude_multi_isolate", parameterToString(*r.filtersExcludeMultiIsolate, ""))
	}
	if r.filtersTypeMaterialCategory != nil {
		localVarQueryParams.Add("filters.type_material_category", parameterToString(*r.filtersTypeMaterialCategory, ""))
	}
	if r.taxExactMatch != nil {
		localVarQueryParams.Add("tax_exact_match", parameterToString(*r.taxExactMatch, ""))
	}
	if r.tableFields != nil {
		t := *r.tableFields
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("table_fields", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("table_fields", parameterToString(t, "multi"))
		}
	}
	if r.returnedContent != nil {
		localVarQueryParams.Add("returned_content", parameterToString(*r.returnedContent, ""))
	}
	if r.pageSize != nil {
		localVarQueryParams.Add("page_size", parameterToString(*r.pageSize, ""))
	}
	if r.pageToken != nil {
		localVarQueryParams.Add("page_token", parameterToString(*r.pageToken, ""))
	}
	if r.sortField != nil {
		localVarQueryParams.Add("sort.field", parameterToString(*r.sortField, ""))
	}
	if r.sortDirection != nil {
		localVarQueryParams.Add("sort.direction", parameterToString(*r.sortDirection, ""))
	}
	if r.includeTabularHeader != nil {
		localVarQueryParams.Add("include_tabular_header", parameterToString(*r.includeTabularHeader, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "application/x-ndjson", "text/tab-separated-values"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuthHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v RpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type GenomeApiGenomeDatasetReportsByTaxonRequest struct {
	ctx context.Context
	ApiService *GenomeApiService
	taxons []string
	filtersReferenceOnly *bool
	filtersAssemblySource *V2AssemblyDatasetDescriptorsFilterAssemblySource
	filtersHasAnnotation *bool
	filtersExcludePairedReports *bool
	filtersExcludeAtypical *bool
	filtersAssemblyVersion *V2AssemblyDatasetDescriptorsFilterAssemblyVersion
	filtersAssemblyLevel *[]V2reportsAssemblyLevel
	filtersFirstReleaseDate *time.Time
	filtersLastReleaseDate *time.Time
	filtersSearchText *[]string
	filtersIsMetagenomeDerived *V2AssemblyDatasetDescriptorsFilterMetagenomeDerivedFilter
	filtersIsTypeMaterial *bool
	filtersIsIctvExemplar *bool
	filtersExcludeMultiIsolate *bool
	filtersTypeMaterialCategory *V2AssemblyDatasetDescriptorsFilterTypeMaterialCategory
	taxExactMatch *bool
	tableFields *[]string
	returnedContent *V2AssemblyDatasetReportsRequestContentType
	pageSize *int32
	pageToken *string
	sortField *string
	sortDirection *V2SortDirection
	includeTabularHeader *V2IncludeTabularHeader
}

// If true, only return reference and representative (GCF_ and GCA_) genome assemblies.
func (r GenomeApiGenomeDatasetReportsByTaxonRequest) FiltersReferenceOnly(filtersReferenceOnly bool) GenomeApiGenomeDatasetReportsByTaxonRequest {
	r.filtersReferenceOnly = &filtersReferenceOnly
	return r
}

// Return only RefSeq (GCF_) or GenBank (GCA_) genome assemblies
func (r GenomeApiGenomeDatasetReportsByTaxonRequest) FiltersAssemblySource(filtersAssemblySource V2AssemblyDatasetDescriptorsFilterAssemblySource) GenomeApiGenomeDatasetReportsByTaxonRequest {
	r.filtersAssemblySource = &filtersAssemblySource
	return r
}

// Return only annotated genome assemblies
func (r GenomeApiGenomeDatasetReportsByTaxonRequest) FiltersHasAnnotation(filtersHasAnnotation bool) GenomeApiGenomeDatasetReportsByTaxonRequest {
	r.filtersHasAnnotation = &filtersHasAnnotation
	return r
}

// For paired (GCA/GCF) records, only return the primary record
func (r GenomeApiGenomeDatasetReportsByTaxonRequest) FiltersExcludePairedReports(filtersExcludePairedReports bool) GenomeApiGenomeDatasetReportsByTaxonRequest {
	r.filtersExcludePairedReports = &filtersExcludePairedReports
	return r
}

// If true, exclude atypical genomes, i.e. genomes that have assembly issues or are otherwise atypical
func (r GenomeApiGenomeDatasetReportsByTaxonRequest) FiltersExcludeAtypical(filtersExcludeAtypical bool) GenomeApiGenomeDatasetReportsByTaxonRequest {
	r.filtersExcludeAtypical = &filtersExcludeAtypical
	return r
}

// Return all assemblies, including replaced and suppressed, or only current assemblies
func (r GenomeApiGenomeDatasetReportsByTaxonRequest) FiltersAssemblyVersion(filtersAssemblyVersion V2AssemblyDatasetDescriptorsFilterAssemblyVersion) GenomeApiGenomeDatasetReportsByTaxonRequest {
	r.filtersAssemblyVersion = &filtersAssemblyVersion
	return r
}

// Only return genome assemblies that have one of the specified assembly levels. By default, do not filter.
func (r GenomeApiGenomeDatasetReportsByTaxonRequest) FiltersAssemblyLevel(filtersAssemblyLevel []V2reportsAssemblyLevel) GenomeApiGenomeDatasetReportsByTaxonRequest {
	r.filtersAssemblyLevel = &filtersAssemblyLevel
	return r
}

// Only return genome assemblies that were released on or after the specified date By default, do not filter.
func (r GenomeApiGenomeDatasetReportsByTaxonRequest) FiltersFirstReleaseDate(filtersFirstReleaseDate time.Time) GenomeApiGenomeDatasetReportsByTaxonRequest {
	r.filtersFirstReleaseDate = &filtersFirstReleaseDate
	return r
}

// Only return genome assemblies that were released on or before to the specified date By default, do not filter.
func (r GenomeApiGenomeDatasetReportsByTaxonRequest) FiltersLastReleaseDate(filtersLastReleaseDate time.Time) GenomeApiGenomeDatasetReportsByTaxonRequest {
	r.filtersLastReleaseDate = &filtersLastReleaseDate
	return r
}

// Only return results whose fields contain the specified search terms in their taxon, infraspecific, assembly name or submitter fields By default, do not filter
func (r GenomeApiGenomeDatasetReportsByTaxonRequest) FiltersSearchText(filtersSearchText []string) GenomeApiGenomeDatasetReportsByTaxonRequest {
	r.filtersSearchText = &filtersSearchText
	return r
}

func (r GenomeApiGenomeDatasetReportsByTaxonRequest) FiltersIsMetagenomeDerived(filtersIsMetagenomeDerived V2AssemblyDatasetDescriptorsFilterMetagenomeDerivedFilter) GenomeApiGenomeDatasetReportsByTaxonRequest {
	r.filtersIsMetagenomeDerived = &filtersIsMetagenomeDerived
	return r
}

// If true, include only type materials
func (r GenomeApiGenomeDatasetReportsByTaxonRequest) FiltersIsTypeMaterial(filtersIsTypeMaterial bool) GenomeApiGenomeDatasetReportsByTaxonRequest {
	r.filtersIsTypeMaterial = &filtersIsTypeMaterial
	return r
}

// If true, include only ICTV Exemplars
func (r GenomeApiGenomeDatasetReportsByTaxonRequest) FiltersIsIctvExemplar(filtersIsIctvExemplar bool) GenomeApiGenomeDatasetReportsByTaxonRequest {
	r.filtersIsIctvExemplar = &filtersIsIctvExemplar
	return r
}

// If true, exclude large multi-isolate projects
func (r GenomeApiGenomeDatasetReportsByTaxonRequest) FiltersExcludeMultiIsolate(filtersExcludeMultiIsolate bool) GenomeApiGenomeDatasetReportsByTaxonRequest {
	r.filtersExcludeMultiIsolate = &filtersExcludeMultiIsolate
	return r
}

func (r GenomeApiGenomeDatasetReportsByTaxonRequest) FiltersTypeMaterialCategory(filtersTypeMaterialCategory V2AssemblyDatasetDescriptorsFilterTypeMaterialCategory) GenomeApiGenomeDatasetReportsByTaxonRequest {
	r.filtersTypeMaterialCategory = &filtersTypeMaterialCategory
	return r
}

// If true, only return assemblies with the given NCBI Taxonomy ID, or name. Otherwise, assemblies from taxonomy subtree are included, too.
func (r GenomeApiGenomeDatasetReportsByTaxonRequest) TaxExactMatch(taxExactMatch bool) GenomeApiGenomeDatasetReportsByTaxonRequest {
	r.taxExactMatch = &taxExactMatch
	return r
}

func (r GenomeApiGenomeDatasetReportsByTaxonRequest) TableFields(tableFields []string) GenomeApiGenomeDatasetReportsByTaxonRequest {
	r.tableFields = &tableFields
	return r
}

// Return either assembly accessions, or complete assembly reports
func (r GenomeApiGenomeDatasetReportsByTaxonRequest) ReturnedContent(returnedContent V2AssemblyDatasetReportsRequestContentType) GenomeApiGenomeDatasetReportsByTaxonRequest {
	r.returnedContent = &returnedContent
	return r
}

// The maximum number of genome assembly reports to return. Default is 20 and maximum is 1000. If the number of results exceeds the page size, &#x60;page_token&#x60; can be used to retrieve the remaining results.
func (r GenomeApiGenomeDatasetReportsByTaxonRequest) PageSize(pageSize int32) GenomeApiGenomeDatasetReportsByTaxonRequest {
	r.pageSize = &pageSize
	return r
}

// A page token is returned from an &#x60;AssemblyDatasetReportsRequest&#x60; call with more than &#x60;page_size&#x60; results. Use this token, along with the previous &#x60;AssemblyDatasetReportsRequest&#x60; parameters, to retrieve the next page of results. When &#x60;page_token&#x60; is empty, all results have been retrieved.
func (r GenomeApiGenomeDatasetReportsByTaxonRequest) PageToken(pageToken string) GenomeApiGenomeDatasetReportsByTaxonRequest {
	r.pageToken = &pageToken
	return r
}

func (r GenomeApiGenomeDatasetReportsByTaxonRequest) SortField(sortField string) GenomeApiGenomeDatasetReportsByTaxonRequest {
	r.sortField = &sortField
	return r
}

func (r GenomeApiGenomeDatasetReportsByTaxonRequest) SortDirection(sortDirection V2SortDirection) GenomeApiGenomeDatasetReportsByTaxonRequest {
	r.sortDirection = &sortDirection
	return r
}

// Whether this request for tabular data should include the header row
func (r GenomeApiGenomeDatasetReportsByTaxonRequest) IncludeTabularHeader(includeTabularHeader V2IncludeTabularHeader) GenomeApiGenomeDatasetReportsByTaxonRequest {
	r.includeTabularHeader = &includeTabularHeader
	return r
}

func (r GenomeApiGenomeDatasetReportsByTaxonRequest) Execute() (*V2reportsAssemblyDataReportPage, *http.Response, error) {
	return r.ApiService.GenomeDatasetReportsByTaxonExecute(r)
}

/*
GenomeDatasetReportsByTaxon Get dataset reports by taxons

Get dataset reports by taxons.  By default, in paged JSON format, but also available as tabular (accept: text/tab-separated-values) or json-lines (accept: application/x-ndjson)

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param taxons NCBI Taxonomy ID or name (common or scientific) at any taxonomic rank
 @return GenomeApiGenomeDatasetReportsByTaxonRequest
*/
func (a *GenomeApiService) GenomeDatasetReportsByTaxon(ctx context.Context, taxons []string) GenomeApiGenomeDatasetReportsByTaxonRequest {
	return GenomeApiGenomeDatasetReportsByTaxonRequest{
		ApiService: a,
		ctx: ctx,
		taxons: taxons,
	}
}

// Execute executes the request
//  @return V2reportsAssemblyDataReportPage
func (a *GenomeApiService) GenomeDatasetReportsByTaxonExecute(r GenomeApiGenomeDatasetReportsByTaxonRequest) (*V2reportsAssemblyDataReportPage, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V2reportsAssemblyDataReportPage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GenomeApiService.GenomeDatasetReportsByTaxon")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/genome/taxon/{taxons}/dataset_report"
	localVarPath = strings.Replace(localVarPath, "{"+"taxons"+"}", url.PathEscape(parameterToString(r.taxons, "csv")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.filtersReferenceOnly != nil {
		localVarQueryParams.Add("filters.reference_only", parameterToString(*r.filtersReferenceOnly, ""))
	}
	if r.filtersAssemblySource != nil {
		localVarQueryParams.Add("filters.assembly_source", parameterToString(*r.filtersAssemblySource, ""))
	}
	if r.filtersHasAnnotation != nil {
		localVarQueryParams.Add("filters.has_annotation", parameterToString(*r.filtersHasAnnotation, ""))
	}
	if r.filtersExcludePairedReports != nil {
		localVarQueryParams.Add("filters.exclude_paired_reports", parameterToString(*r.filtersExcludePairedReports, ""))
	}
	if r.filtersExcludeAtypical != nil {
		localVarQueryParams.Add("filters.exclude_atypical", parameterToString(*r.filtersExcludeAtypical, ""))
	}
	if r.filtersAssemblyVersion != nil {
		localVarQueryParams.Add("filters.assembly_version", parameterToString(*r.filtersAssemblyVersion, ""))
	}
	if r.filtersAssemblyLevel != nil {
		t := *r.filtersAssemblyLevel
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("filters.assembly_level", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("filters.assembly_level", parameterToString(t, "multi"))
		}
	}
	if r.filtersFirstReleaseDate != nil {
		localVarQueryParams.Add("filters.first_release_date", parameterToString(*r.filtersFirstReleaseDate, ""))
	}
	if r.filtersLastReleaseDate != nil {
		localVarQueryParams.Add("filters.last_release_date", parameterToString(*r.filtersLastReleaseDate, ""))
	}
	if r.filtersSearchText != nil {
		t := *r.filtersSearchText
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("filters.search_text", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("filters.search_text", parameterToString(t, "multi"))
		}
	}
	if r.filtersIsMetagenomeDerived != nil {
		localVarQueryParams.Add("filters.is_metagenome_derived", parameterToString(*r.filtersIsMetagenomeDerived, ""))
	}
	if r.filtersIsTypeMaterial != nil {
		localVarQueryParams.Add("filters.is_type_material", parameterToString(*r.filtersIsTypeMaterial, ""))
	}
	if r.filtersIsIctvExemplar != nil {
		localVarQueryParams.Add("filters.is_ictv_exemplar", parameterToString(*r.filtersIsIctvExemplar, ""))
	}
	if r.filtersExcludeMultiIsolate != nil {
		localVarQueryParams.Add("filters.exclude_multi_isolate", parameterToString(*r.filtersExcludeMultiIsolate, ""))
	}
	if r.filtersTypeMaterialCategory != nil {
		localVarQueryParams.Add("filters.type_material_category", parameterToString(*r.filtersTypeMaterialCategory, ""))
	}
	if r.taxExactMatch != nil {
		localVarQueryParams.Add("tax_exact_match", parameterToString(*r.taxExactMatch, ""))
	}
	if r.tableFields != nil {
		t := *r.tableFields
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("table_fields", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("table_fields", parameterToString(t, "multi"))
		}
	}
	if r.returnedContent != nil {
		localVarQueryParams.Add("returned_content", parameterToString(*r.returnedContent, ""))
	}
	if r.pageSize != nil {
		localVarQueryParams.Add("page_size", parameterToString(*r.pageSize, ""))
	}
	if r.pageToken != nil {
		localVarQueryParams.Add("page_token", parameterToString(*r.pageToken, ""))
	}
	if r.sortField != nil {
		localVarQueryParams.Add("sort.field", parameterToString(*r.sortField, ""))
	}
	if r.sortDirection != nil {
		localVarQueryParams.Add("sort.direction", parameterToString(*r.sortDirection, ""))
	}
	if r.includeTabularHeader != nil {
		localVarQueryParams.Add("include_tabular_header", parameterToString(*r.includeTabularHeader, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "application/x-ndjson", "text/tab-separated-values"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuthHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v RpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type GenomeApiGenomeDatasetReportsByWgsRequest struct {
	ctx context.Context
	ApiService *GenomeApiService
	wgsAccessions []string
	filtersReferenceOnly *bool
	filtersAssemblySource *V2AssemblyDatasetDescriptorsFilterAssemblySource
	filtersHasAnnotation *bool
	filtersExcludePairedReports *bool
	filtersExcludeAtypical *bool
	filtersAssemblyVersion *V2AssemblyDatasetDescriptorsFilterAssemblyVersion
	filtersAssemblyLevel *[]V2reportsAssemblyLevel
	filtersFirstReleaseDate *time.Time
	filtersLastReleaseDate *time.Time
	filtersSearchText *[]string
	filtersIsMetagenomeDerived *V2AssemblyDatasetDescriptorsFilterMetagenomeDerivedFilter
	filtersIsTypeMaterial *bool
	filtersIsIctvExemplar *bool
	filtersExcludeMultiIsolate *bool
	filtersTypeMaterialCategory *V2AssemblyDatasetDescriptorsFilterTypeMaterialCategory
	taxExactMatch *bool
	tableFields *[]string
	returnedContent *V2AssemblyDatasetReportsRequestContentType
	pageSize *int32
	pageToken *string
	sortField *string
	sortDirection *V2SortDirection
	includeTabularHeader *V2IncludeTabularHeader
}

// If true, only return reference and representative (GCF_ and GCA_) genome assemblies.
func (r GenomeApiGenomeDatasetReportsByWgsRequest) FiltersReferenceOnly(filtersReferenceOnly bool) GenomeApiGenomeDatasetReportsByWgsRequest {
	r.filtersReferenceOnly = &filtersReferenceOnly
	return r
}

// Return only RefSeq (GCF_) or GenBank (GCA_) genome assemblies
func (r GenomeApiGenomeDatasetReportsByWgsRequest) FiltersAssemblySource(filtersAssemblySource V2AssemblyDatasetDescriptorsFilterAssemblySource) GenomeApiGenomeDatasetReportsByWgsRequest {
	r.filtersAssemblySource = &filtersAssemblySource
	return r
}

// Return only annotated genome assemblies
func (r GenomeApiGenomeDatasetReportsByWgsRequest) FiltersHasAnnotation(filtersHasAnnotation bool) GenomeApiGenomeDatasetReportsByWgsRequest {
	r.filtersHasAnnotation = &filtersHasAnnotation
	return r
}

// For paired (GCA/GCF) records, only return the primary record
func (r GenomeApiGenomeDatasetReportsByWgsRequest) FiltersExcludePairedReports(filtersExcludePairedReports bool) GenomeApiGenomeDatasetReportsByWgsRequest {
	r.filtersExcludePairedReports = &filtersExcludePairedReports
	return r
}

// If true, exclude atypical genomes, i.e. genomes that have assembly issues or are otherwise atypical
func (r GenomeApiGenomeDatasetReportsByWgsRequest) FiltersExcludeAtypical(filtersExcludeAtypical bool) GenomeApiGenomeDatasetReportsByWgsRequest {
	r.filtersExcludeAtypical = &filtersExcludeAtypical
	return r
}

// Return all assemblies, including replaced and suppressed, or only current assemblies
func (r GenomeApiGenomeDatasetReportsByWgsRequest) FiltersAssemblyVersion(filtersAssemblyVersion V2AssemblyDatasetDescriptorsFilterAssemblyVersion) GenomeApiGenomeDatasetReportsByWgsRequest {
	r.filtersAssemblyVersion = &filtersAssemblyVersion
	return r
}

// Only return genome assemblies that have one of the specified assembly levels. By default, do not filter.
func (r GenomeApiGenomeDatasetReportsByWgsRequest) FiltersAssemblyLevel(filtersAssemblyLevel []V2reportsAssemblyLevel) GenomeApiGenomeDatasetReportsByWgsRequest {
	r.filtersAssemblyLevel = &filtersAssemblyLevel
	return r
}

// Only return genome assemblies that were released on or after the specified date By default, do not filter.
func (r GenomeApiGenomeDatasetReportsByWgsRequest) FiltersFirstReleaseDate(filtersFirstReleaseDate time.Time) GenomeApiGenomeDatasetReportsByWgsRequest {
	r.filtersFirstReleaseDate = &filtersFirstReleaseDate
	return r
}

// Only return genome assemblies that were released on or before to the specified date By default, do not filter.
func (r GenomeApiGenomeDatasetReportsByWgsRequest) FiltersLastReleaseDate(filtersLastReleaseDate time.Time) GenomeApiGenomeDatasetReportsByWgsRequest {
	r.filtersLastReleaseDate = &filtersLastReleaseDate
	return r
}

// Only return results whose fields contain the specified search terms in their taxon, infraspecific, assembly name or submitter fields By default, do not filter
func (r GenomeApiGenomeDatasetReportsByWgsRequest) FiltersSearchText(filtersSearchText []string) GenomeApiGenomeDatasetReportsByWgsRequest {
	r.filtersSearchText = &filtersSearchText
	return r
}

func (r GenomeApiGenomeDatasetReportsByWgsRequest) FiltersIsMetagenomeDerived(filtersIsMetagenomeDerived V2AssemblyDatasetDescriptorsFilterMetagenomeDerivedFilter) GenomeApiGenomeDatasetReportsByWgsRequest {
	r.filtersIsMetagenomeDerived = &filtersIsMetagenomeDerived
	return r
}

// If true, include only type materials
func (r GenomeApiGenomeDatasetReportsByWgsRequest) FiltersIsTypeMaterial(filtersIsTypeMaterial bool) GenomeApiGenomeDatasetReportsByWgsRequest {
	r.filtersIsTypeMaterial = &filtersIsTypeMaterial
	return r
}

// If true, include only ICTV Exemplars
func (r GenomeApiGenomeDatasetReportsByWgsRequest) FiltersIsIctvExemplar(filtersIsIctvExemplar bool) GenomeApiGenomeDatasetReportsByWgsRequest {
	r.filtersIsIctvExemplar = &filtersIsIctvExemplar
	return r
}

// If true, exclude large multi-isolate projects
func (r GenomeApiGenomeDatasetReportsByWgsRequest) FiltersExcludeMultiIsolate(filtersExcludeMultiIsolate bool) GenomeApiGenomeDatasetReportsByWgsRequest {
	r.filtersExcludeMultiIsolate = &filtersExcludeMultiIsolate
	return r
}

func (r GenomeApiGenomeDatasetReportsByWgsRequest) FiltersTypeMaterialCategory(filtersTypeMaterialCategory V2AssemblyDatasetDescriptorsFilterTypeMaterialCategory) GenomeApiGenomeDatasetReportsByWgsRequest {
	r.filtersTypeMaterialCategory = &filtersTypeMaterialCategory
	return r
}

// If true, only return assemblies with the given NCBI Taxonomy ID, or name. Otherwise, assemblies from taxonomy subtree are included, too.
func (r GenomeApiGenomeDatasetReportsByWgsRequest) TaxExactMatch(taxExactMatch bool) GenomeApiGenomeDatasetReportsByWgsRequest {
	r.taxExactMatch = &taxExactMatch
	return r
}

func (r GenomeApiGenomeDatasetReportsByWgsRequest) TableFields(tableFields []string) GenomeApiGenomeDatasetReportsByWgsRequest {
	r.tableFields = &tableFields
	return r
}

// Return either assembly accessions, or complete assembly reports
func (r GenomeApiGenomeDatasetReportsByWgsRequest) ReturnedContent(returnedContent V2AssemblyDatasetReportsRequestContentType) GenomeApiGenomeDatasetReportsByWgsRequest {
	r.returnedContent = &returnedContent
	return r
}

// The maximum number of genome assembly reports to return. Default is 20 and maximum is 1000. If the number of results exceeds the page size, &#x60;page_token&#x60; can be used to retrieve the remaining results.
func (r GenomeApiGenomeDatasetReportsByWgsRequest) PageSize(pageSize int32) GenomeApiGenomeDatasetReportsByWgsRequest {
	r.pageSize = &pageSize
	return r
}

// A page token is returned from an &#x60;AssemblyDatasetReportsRequest&#x60; call with more than &#x60;page_size&#x60; results. Use this token, along with the previous &#x60;AssemblyDatasetReportsRequest&#x60; parameters, to retrieve the next page of results. When &#x60;page_token&#x60; is empty, all results have been retrieved.
func (r GenomeApiGenomeDatasetReportsByWgsRequest) PageToken(pageToken string) GenomeApiGenomeDatasetReportsByWgsRequest {
	r.pageToken = &pageToken
	return r
}

func (r GenomeApiGenomeDatasetReportsByWgsRequest) SortField(sortField string) GenomeApiGenomeDatasetReportsByWgsRequest {
	r.sortField = &sortField
	return r
}

func (r GenomeApiGenomeDatasetReportsByWgsRequest) SortDirection(sortDirection V2SortDirection) GenomeApiGenomeDatasetReportsByWgsRequest {
	r.sortDirection = &sortDirection
	return r
}

// Whether this request for tabular data should include the header row
func (r GenomeApiGenomeDatasetReportsByWgsRequest) IncludeTabularHeader(includeTabularHeader V2IncludeTabularHeader) GenomeApiGenomeDatasetReportsByWgsRequest {
	r.includeTabularHeader = &includeTabularHeader
	return r
}

func (r GenomeApiGenomeDatasetReportsByWgsRequest) Execute() (*V2reportsAssemblyDataReportPage, *http.Response, error) {
	return r.ApiService.GenomeDatasetReportsByWgsExecute(r)
}

/*
GenomeDatasetReportsByWgs Get dataset reports by wgs accession

Get dataset reports by wgs accession.  By default, in paged JSON format, but also available as tabular (accept: text/tab-separated-values) or json-lines (accept: application/x-ndjson)

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param wgsAccessions
 @return GenomeApiGenomeDatasetReportsByWgsRequest
*/
func (a *GenomeApiService) GenomeDatasetReportsByWgs(ctx context.Context, wgsAccessions []string) GenomeApiGenomeDatasetReportsByWgsRequest {
	return GenomeApiGenomeDatasetReportsByWgsRequest{
		ApiService: a,
		ctx: ctx,
		wgsAccessions: wgsAccessions,
	}
}

// Execute executes the request
//  @return V2reportsAssemblyDataReportPage
func (a *GenomeApiService) GenomeDatasetReportsByWgsExecute(r GenomeApiGenomeDatasetReportsByWgsRequest) (*V2reportsAssemblyDataReportPage, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V2reportsAssemblyDataReportPage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GenomeApiService.GenomeDatasetReportsByWgs")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/genome/wgs/{wgs_accessions}/dataset_report"
	localVarPath = strings.Replace(localVarPath, "{"+"wgs_accessions"+"}", url.PathEscape(parameterToString(r.wgsAccessions, "csv")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.filtersReferenceOnly != nil {
		localVarQueryParams.Add("filters.reference_only", parameterToString(*r.filtersReferenceOnly, ""))
	}
	if r.filtersAssemblySource != nil {
		localVarQueryParams.Add("filters.assembly_source", parameterToString(*r.filtersAssemblySource, ""))
	}
	if r.filtersHasAnnotation != nil {
		localVarQueryParams.Add("filters.has_annotation", parameterToString(*r.filtersHasAnnotation, ""))
	}
	if r.filtersExcludePairedReports != nil {
		localVarQueryParams.Add("filters.exclude_paired_reports", parameterToString(*r.filtersExcludePairedReports, ""))
	}
	if r.filtersExcludeAtypical != nil {
		localVarQueryParams.Add("filters.exclude_atypical", parameterToString(*r.filtersExcludeAtypical, ""))
	}
	if r.filtersAssemblyVersion != nil {
		localVarQueryParams.Add("filters.assembly_version", parameterToString(*r.filtersAssemblyVersion, ""))
	}
	if r.filtersAssemblyLevel != nil {
		t := *r.filtersAssemblyLevel
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("filters.assembly_level", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("filters.assembly_level", parameterToString(t, "multi"))
		}
	}
	if r.filtersFirstReleaseDate != nil {
		localVarQueryParams.Add("filters.first_release_date", parameterToString(*r.filtersFirstReleaseDate, ""))
	}
	if r.filtersLastReleaseDate != nil {
		localVarQueryParams.Add("filters.last_release_date", parameterToString(*r.filtersLastReleaseDate, ""))
	}
	if r.filtersSearchText != nil {
		t := *r.filtersSearchText
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("filters.search_text", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("filters.search_text", parameterToString(t, "multi"))
		}
	}
	if r.filtersIsMetagenomeDerived != nil {
		localVarQueryParams.Add("filters.is_metagenome_derived", parameterToString(*r.filtersIsMetagenomeDerived, ""))
	}
	if r.filtersIsTypeMaterial != nil {
		localVarQueryParams.Add("filters.is_type_material", parameterToString(*r.filtersIsTypeMaterial, ""))
	}
	if r.filtersIsIctvExemplar != nil {
		localVarQueryParams.Add("filters.is_ictv_exemplar", parameterToString(*r.filtersIsIctvExemplar, ""))
	}
	if r.filtersExcludeMultiIsolate != nil {
		localVarQueryParams.Add("filters.exclude_multi_isolate", parameterToString(*r.filtersExcludeMultiIsolate, ""))
	}
	if r.filtersTypeMaterialCategory != nil {
		localVarQueryParams.Add("filters.type_material_category", parameterToString(*r.filtersTypeMaterialCategory, ""))
	}
	if r.taxExactMatch != nil {
		localVarQueryParams.Add("tax_exact_match", parameterToString(*r.taxExactMatch, ""))
	}
	if r.tableFields != nil {
		t := *r.tableFields
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("table_fields", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("table_fields", parameterToString(t, "multi"))
		}
	}
	if r.returnedContent != nil {
		localVarQueryParams.Add("returned_content", parameterToString(*r.returnedContent, ""))
	}
	if r.pageSize != nil {
		localVarQueryParams.Add("page_size", parameterToString(*r.pageSize, ""))
	}
	if r.pageToken != nil {
		localVarQueryParams.Add("page_token", parameterToString(*r.pageToken, ""))
	}
	if r.sortField != nil {
		localVarQueryParams.Add("sort.field", parameterToString(*r.sortField, ""))
	}
	if r.sortDirection != nil {
		localVarQueryParams.Add("sort.direction", parameterToString(*r.sortDirection, ""))
	}
	if r.includeTabularHeader != nil {
		localVarQueryParams.Add("include_tabular_header", parameterToString(*r.includeTabularHeader, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "application/x-ndjson", "text/tab-separated-values"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuthHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v RpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type GenomeApiGenomeDownloadSummaryRequest struct {
	ctx context.Context
	ApiService *GenomeApiService
	accessions []string
	chromosomes *[]string
	includeAnnotationType *[]V2AnnotationForAssemblyType
	expDebugValues *string
}

// The default setting is all chromosome. Specify individual chromosome by string (1,2,MT or chr1,chr2.chrMT). Unplaced sequences are treated like their own chromosome (&#39;Un&#39;). The filter only applies to fasta sequence.
func (r GenomeApiGenomeDownloadSummaryRequest) Chromosomes(chromosomes []string) GenomeApiGenomeDownloadSummaryRequest {
	r.chromosomes = &chromosomes
	return r
}

// Select additional types of annotation to include in the data package.  If unset, no annotation is provided.
func (r GenomeApiGenomeDownloadSummaryRequest) IncludeAnnotationType(includeAnnotationType []V2AnnotationForAssemblyType) GenomeApiGenomeDownloadSummaryRequest {
	r.includeAnnotationType = &includeAnnotationType
	return r
}

// Supports debugging, e.g. by controlling data download speeds
func (r GenomeApiGenomeDownloadSummaryRequest) ExpDebugValues(expDebugValues string) GenomeApiGenomeDownloadSummaryRequest {
	r.expDebugValues = &expDebugValues
	return r
}

func (r GenomeApiGenomeDownloadSummaryRequest) Execute() (*V2DownloadSummary, *http.Response, error) {
	return r.ApiService.GenomeDownloadSummaryExecute(r)
}

/*
GenomeDownloadSummary Preview genome dataset download

Get a download summary by accession in a JSON output format.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accessions NCBI genome assembly accessions
 @return GenomeApiGenomeDownloadSummaryRequest
*/
func (a *GenomeApiService) GenomeDownloadSummary(ctx context.Context, accessions []string) GenomeApiGenomeDownloadSummaryRequest {
	return GenomeApiGenomeDownloadSummaryRequest{
		ApiService: a,
		ctx: ctx,
		accessions: accessions,
	}
}

// Execute executes the request
//  @return V2DownloadSummary
func (a *GenomeApiService) GenomeDownloadSummaryExecute(r GenomeApiGenomeDownloadSummaryRequest) (*V2DownloadSummary, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V2DownloadSummary
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GenomeApiService.GenomeDownloadSummary")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/genome/accession/{accessions}/download_summary"
	localVarPath = strings.Replace(localVarPath, "{"+"accessions"+"}", url.PathEscape(parameterToString(r.accessions, "csv")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.chromosomes != nil {
		t := *r.chromosomes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("chromosomes", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("chromosomes", parameterToString(t, "multi"))
		}
	}
	if r.includeAnnotationType != nil {
		t := *r.includeAnnotationType
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("include_annotation_type", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("include_annotation_type", parameterToString(t, "multi"))
		}
	}
	if r.expDebugValues != nil {
		localVarQueryParams.Add("_exp_debug_values", parameterToString(*r.expDebugValues, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuthHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v RpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type GenomeApiGenomeDownloadSummaryByPostRequest struct {
	ctx context.Context
	ApiService *GenomeApiService
	v2AssemblyDatasetRequest *V2AssemblyDatasetRequest
}

func (r GenomeApiGenomeDownloadSummaryByPostRequest) V2AssemblyDatasetRequest(v2AssemblyDatasetRequest V2AssemblyDatasetRequest) GenomeApiGenomeDownloadSummaryByPostRequest {
	r.v2AssemblyDatasetRequest = &v2AssemblyDatasetRequest
	return r
}

func (r GenomeApiGenomeDownloadSummaryByPostRequest) Execute() (*V2DownloadSummary, *http.Response, error) {
	return r.ApiService.GenomeDownloadSummaryByPostExecute(r)
}

/*
GenomeDownloadSummaryByPost Preview genome dataset download by POST

The 'GET' version of download summary is limited by the size of the GET URL (2KB, which works out to about 140 genomic accessions).  The POST operation is provided to allow users to supply a larger number of accessions in a single request.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return GenomeApiGenomeDownloadSummaryByPostRequest
*/
func (a *GenomeApiService) GenomeDownloadSummaryByPost(ctx context.Context) GenomeApiGenomeDownloadSummaryByPostRequest {
	return GenomeApiGenomeDownloadSummaryByPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V2DownloadSummary
func (a *GenomeApiService) GenomeDownloadSummaryByPostExecute(r GenomeApiGenomeDownloadSummaryByPostRequest) (*V2DownloadSummary, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V2DownloadSummary
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GenomeApiService.GenomeDownloadSummaryByPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/genome/download_summary"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.v2AssemblyDatasetRequest == nil {
		return localVarReturnValue, nil, reportError("v2AssemblyDatasetRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.v2AssemblyDatasetRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuthHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v RpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type GenomeApiGenomeLinksByAccessionRequest struct {
	ctx context.Context
	ApiService *GenomeApiService
	accessions []string
}

func (r GenomeApiGenomeLinksByAccessionRequest) Execute() (*V2AssemblyLinksReply, *http.Response, error) {
	return r.ApiService.GenomeLinksByAccessionExecute(r)
}

/*
GenomeLinksByAccession Get assembly links by accessions

Get links to available assembly resources by accessions.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accessions NCBI genome assembly accessions, limited to 1000
 @return GenomeApiGenomeLinksByAccessionRequest
*/
func (a *GenomeApiService) GenomeLinksByAccession(ctx context.Context, accessions []string) GenomeApiGenomeLinksByAccessionRequest {
	return GenomeApiGenomeLinksByAccessionRequest{
		ApiService: a,
		ctx: ctx,
		accessions: accessions,
	}
}

// Execute executes the request
//  @return V2AssemblyLinksReply
func (a *GenomeApiService) GenomeLinksByAccessionExecute(r GenomeApiGenomeLinksByAccessionRequest) (*V2AssemblyLinksReply, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V2AssemblyLinksReply
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GenomeApiService.GenomeLinksByAccession")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/genome/accession/{accessions}/links"
	localVarPath = strings.Replace(localVarPath, "{"+"accessions"+"}", url.PathEscape(parameterToString(r.accessions, "csv")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuthHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v RpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type GenomeApiGenomeLinksByAccessionByPostRequest struct {
	ctx context.Context
	ApiService *GenomeApiService
	v2AssemblyLinksRequest *V2AssemblyLinksRequest
}

func (r GenomeApiGenomeLinksByAccessionByPostRequest) V2AssemblyLinksRequest(v2AssemblyLinksRequest V2AssemblyLinksRequest) GenomeApiGenomeLinksByAccessionByPostRequest {
	r.v2AssemblyLinksRequest = &v2AssemblyLinksRequest
	return r
}

func (r GenomeApiGenomeLinksByAccessionByPostRequest) Execute() (*V2AssemblyLinksReply, *http.Response, error) {
	return r.ApiService.GenomeLinksByAccessionByPostExecute(r)
}

/*
GenomeLinksByAccessionByPost Get assembly links by accessions

Get links to available assembly resources by accessions.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return GenomeApiGenomeLinksByAccessionByPostRequest
*/
func (a *GenomeApiService) GenomeLinksByAccessionByPost(ctx context.Context) GenomeApiGenomeLinksByAccessionByPostRequest {
	return GenomeApiGenomeLinksByAccessionByPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V2AssemblyLinksReply
func (a *GenomeApiService) GenomeLinksByAccessionByPostExecute(r GenomeApiGenomeLinksByAccessionByPostRequest) (*V2AssemblyLinksReply, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V2AssemblyLinksReply
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GenomeApiService.GenomeLinksByAccessionByPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/genome/links"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.v2AssemblyLinksRequest == nil {
		return localVarReturnValue, nil, reportError("v2AssemblyLinksRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.v2AssemblyLinksRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuthHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v RpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type GenomeApiGenomeSequenceReportRequest struct {
	ctx context.Context
	ApiService *GenomeApiService
	accession string
	chromosomes *[]string
	roleFilters *[]string
	tableFields *[]string
	countAssemblyUnplaced *bool
	pageSize *int32
	pageToken *string
	includeTabularHeader *V2IncludeTabularHeader
}

func (r GenomeApiGenomeSequenceReportRequest) Chromosomes(chromosomes []string) GenomeApiGenomeSequenceReportRequest {
	r.chromosomes = &chromosomes
	return r
}

func (r GenomeApiGenomeSequenceReportRequest) RoleFilters(roleFilters []string) GenomeApiGenomeSequenceReportRequest {
	r.roleFilters = &roleFilters
	return r
}

func (r GenomeApiGenomeSequenceReportRequest) TableFields(tableFields []string) GenomeApiGenomeSequenceReportRequest {
	r.tableFields = &tableFields
	return r
}

func (r GenomeApiGenomeSequenceReportRequest) CountAssemblyUnplaced(countAssemblyUnplaced bool) GenomeApiGenomeSequenceReportRequest {
	r.countAssemblyUnplaced = &countAssemblyUnplaced
	return r
}

// The maximum number of genome assemblies to return. Default is 20 and maximum is 1000. If the number of results exceeds the page size, &#x60;page_token&#x60; can be used to retrieve the remaining results.
func (r GenomeApiGenomeSequenceReportRequest) PageSize(pageSize int32) GenomeApiGenomeSequenceReportRequest {
	r.pageSize = &pageSize
	return r
}

// A page token is returned from an &#x60;GetSequenceReports&#x60; call with more than &#x60;page_size&#x60; results. Use this token, along with the previous &#x60;AssemblyMetadataRequest&#x60; parameters, to retrieve the next page of results. When &#x60;page_token&#x60; is empty, all results have been retrieved.
func (r GenomeApiGenomeSequenceReportRequest) PageToken(pageToken string) GenomeApiGenomeSequenceReportRequest {
	r.pageToken = &pageToken
	return r
}

func (r GenomeApiGenomeSequenceReportRequest) IncludeTabularHeader(includeTabularHeader V2IncludeTabularHeader) GenomeApiGenomeSequenceReportRequest {
	r.includeTabularHeader = &includeTabularHeader
	return r
}

func (r GenomeApiGenomeSequenceReportRequest) Execute() (*V2SequenceReportPage, *http.Response, error) {
	return r.ApiService.GenomeSequenceReportExecute(r)
}

/*
GenomeSequenceReport Get sequence reports by accessions

Get a sequence report by accession.  By default, in paged JSON format, but also available as tabular (accept: text/tab-separated-values) or json-lines (accept: application/x-ndjson)

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accession
 @return GenomeApiGenomeSequenceReportRequest
*/
func (a *GenomeApiService) GenomeSequenceReport(ctx context.Context, accession string) GenomeApiGenomeSequenceReportRequest {
	return GenomeApiGenomeSequenceReportRequest{
		ApiService: a,
		ctx: ctx,
		accession: accession,
	}
}

// Execute executes the request
//  @return V2SequenceReportPage
func (a *GenomeApiService) GenomeSequenceReportExecute(r GenomeApiGenomeSequenceReportRequest) (*V2SequenceReportPage, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V2SequenceReportPage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GenomeApiService.GenomeSequenceReport")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/genome/accession/{accession}/sequence_reports"
	localVarPath = strings.Replace(localVarPath, "{"+"accession"+"}", url.PathEscape(parameterToString(r.accession, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.chromosomes != nil {
		t := *r.chromosomes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("chromosomes", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("chromosomes", parameterToString(t, "multi"))
		}
	}
	if r.roleFilters != nil {
		t := *r.roleFilters
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("role_filters", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("role_filters", parameterToString(t, "multi"))
		}
	}
	if r.tableFields != nil {
		t := *r.tableFields
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("table_fields", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("table_fields", parameterToString(t, "multi"))
		}
	}
	if r.countAssemblyUnplaced != nil {
		localVarQueryParams.Add("count_assembly_unplaced", parameterToString(*r.countAssemblyUnplaced, ""))
	}
	if r.pageSize != nil {
		localVarQueryParams.Add("page_size", parameterToString(*r.pageSize, ""))
	}
	if r.pageToken != nil {
		localVarQueryParams.Add("page_token", parameterToString(*r.pageToken, ""))
	}
	if r.includeTabularHeader != nil {
		localVarQueryParams.Add("include_tabular_header", parameterToString(*r.includeTabularHeader, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet", "text/tab-separated-values", "application/x-ndjson"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuthHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v RpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type GenomeApiGenomeSequenceReportByPostRequest struct {
	ctx context.Context
	ApiService *GenomeApiService
	v2AssemblySequenceReportsRequest *V2AssemblySequenceReportsRequest
}

func (r GenomeApiGenomeSequenceReportByPostRequest) V2AssemblySequenceReportsRequest(v2AssemblySequenceReportsRequest V2AssemblySequenceReportsRequest) GenomeApiGenomeSequenceReportByPostRequest {
	r.v2AssemblySequenceReportsRequest = &v2AssemblySequenceReportsRequest
	return r
}

func (r GenomeApiGenomeSequenceReportByPostRequest) Execute() (*V2SequenceReportPage, *http.Response, error) {
	return r.ApiService.GenomeSequenceReportByPostExecute(r)
}

/*
GenomeSequenceReportByPost Get sequence reports by accessions

Get a sequence report by accession.  By default, in paged JSON format, but also available as tabular (accept: text/tab-separated-values) or json-lines (accept: application/x-ndjson)

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return GenomeApiGenomeSequenceReportByPostRequest
*/
func (a *GenomeApiService) GenomeSequenceReportByPost(ctx context.Context) GenomeApiGenomeSequenceReportByPostRequest {
	return GenomeApiGenomeSequenceReportByPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V2SequenceReportPage
func (a *GenomeApiService) GenomeSequenceReportByPostExecute(r GenomeApiGenomeSequenceReportByPostRequest) (*V2SequenceReportPage, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V2SequenceReportPage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GenomeApiService.GenomeSequenceReportByPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/genome/sequence_reports"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.v2AssemblySequenceReportsRequest == nil {
		return localVarReturnValue, nil, reportError("v2AssemblySequenceReportsRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet", "text/tab-separated-values", "application/x-ndjson"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.v2AssemblySequenceReportsRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuthHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v RpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
