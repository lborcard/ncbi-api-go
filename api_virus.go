/*
NCBI Datasets API

### NCBI Datasets is a resource that lets you easily gather data from NCBI. The Datasets version 2 API is still in alpha, and we're updating it often to add new functionality, iron out bugs and enhance usability. For some larger downloads, you may want to download a [dehydrated zip archive](https://www.ncbi.nlm.nih.gov/datasets/docs/v2/how-tos/genomes/large-download/), and retrieve the individual data files at a later time. 

API version: v2alpha
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
	"os"
	"time"
	"reflect"
)


// VirusApiService VirusApi service
type VirusApiService service

type VirusApiSars2ProteinDownloadRequest struct {
	ctx context.Context
	ApiService *VirusApiService
	proteins []string
	refseqOnly *bool
	annotatedOnly *bool
	releasedSince *time.Time
	updatedSince *time.Time
	host *string
	geoLocation *string
	completeOnly *bool
	includeSequence *[]V2ViralSequenceType
	auxReport *[]V2VirusDatasetReportType
	filename *string
}

// If true, limit results to RefSeq genomes.
func (r VirusApiSars2ProteinDownloadRequest) RefseqOnly(refseqOnly bool) VirusApiSars2ProteinDownloadRequest {
	r.refseqOnly = &refseqOnly
	return r
}

// If true, limit results to annotated genomes.
func (r VirusApiSars2ProteinDownloadRequest) AnnotatedOnly(annotatedOnly bool) VirusApiSars2ProteinDownloadRequest {
	r.annotatedOnly = &annotatedOnly
	return r
}

// If set, limit results to viral genomes that have been released after a specified date (and optionally, time). April 1, 2020 midnight UTC should be formatted as &#39;2020-04-01T00:00:00.000Z&#39;
func (r VirusApiSars2ProteinDownloadRequest) ReleasedSince(releasedSince time.Time) VirusApiSars2ProteinDownloadRequest {
	r.releasedSince = &releasedSince
	return r
}

func (r VirusApiSars2ProteinDownloadRequest) UpdatedSince(updatedSince time.Time) VirusApiSars2ProteinDownloadRequest {
	r.updatedSince = &updatedSince
	return r
}

// If set, limit results to genomes extracted from this host (Taxonomy ID or name) All hosts by default
func (r VirusApiSars2ProteinDownloadRequest) Host(host string) VirusApiSars2ProteinDownloadRequest {
	r.host = &host
	return r
}

// Assemblies from this location (country and state, or continent)
func (r VirusApiSars2ProteinDownloadRequest) GeoLocation(geoLocation string) VirusApiSars2ProteinDownloadRequest {
	r.geoLocation = &geoLocation
	return r
}

// only include complete genomes.
func (r VirusApiSars2ProteinDownloadRequest) CompleteOnly(completeOnly bool) VirusApiSars2ProteinDownloadRequest {
	r.completeOnly = &completeOnly
	return r
}

// Specify which sequence files to include in the download
func (r VirusApiSars2ProteinDownloadRequest) IncludeSequence(includeSequence []V2ViralSequenceType) VirusApiSars2ProteinDownloadRequest {
	r.includeSequence = &includeSequence
	return r
}

// List additional reports to include with download. Data report is included by default.
func (r VirusApiSars2ProteinDownloadRequest) AuxReport(auxReport []V2VirusDatasetReportType) VirusApiSars2ProteinDownloadRequest {
	r.auxReport = &auxReport
	return r
}

// Output file name.
func (r VirusApiSars2ProteinDownloadRequest) Filename(filename string) VirusApiSars2ProteinDownloadRequest {
	r.filename = &filename
	return r
}

func (r VirusApiSars2ProteinDownloadRequest) Execute() (**os.File, *http.Response, error) {
	return r.ApiService.Sars2ProteinDownloadExecute(r)
}

/*
Sars2ProteinDownload Download SARS-CoV-2 protein and CDS datasets by protein name

Download SARS-CoV-2 protein datasets

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param proteins Which proteins to retrieve in the data package
 @return VirusApiSars2ProteinDownloadRequest
*/
func (a *VirusApiService) Sars2ProteinDownload(ctx context.Context, proteins []string) VirusApiSars2ProteinDownloadRequest {
	return VirusApiSars2ProteinDownloadRequest{
		ApiService: a,
		ctx: ctx,
		proteins: proteins,
	}
}

// Execute executes the request
//  @return *os.File
func (a *VirusApiService) Sars2ProteinDownloadExecute(r VirusApiSars2ProteinDownloadRequest) (**os.File, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  **os.File
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VirusApiService.Sars2ProteinDownload")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/virus/taxon/sars2/protein/{proteins}/download"
	localVarPath = strings.Replace(localVarPath, "{"+"proteins"+"}", url.PathEscape(parameterToString(r.proteins, "csv")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.refseqOnly != nil {
		localVarQueryParams.Add("refseq_only", parameterToString(*r.refseqOnly, ""))
	}
	if r.annotatedOnly != nil {
		localVarQueryParams.Add("annotated_only", parameterToString(*r.annotatedOnly, ""))
	}
	if r.releasedSince != nil {
		localVarQueryParams.Add("released_since", parameterToString(*r.releasedSince, ""))
	}
	if r.updatedSince != nil {
		localVarQueryParams.Add("updated_since", parameterToString(*r.updatedSince, ""))
	}
	if r.host != nil {
		localVarQueryParams.Add("host", parameterToString(*r.host, ""))
	}
	if r.geoLocation != nil {
		localVarQueryParams.Add("geo_location", parameterToString(*r.geoLocation, ""))
	}
	if r.completeOnly != nil {
		localVarQueryParams.Add("complete_only", parameterToString(*r.completeOnly, ""))
	}
	if r.includeSequence != nil {
		t := *r.includeSequence
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("include_sequence", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("include_sequence", parameterToString(t, "multi"))
		}
	}
	if r.auxReport != nil {
		t := *r.auxReport
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("aux_report", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("aux_report", parameterToString(t, "multi"))
		}
	}
	if r.filename != nil {
		localVarQueryParams.Add("filename", parameterToString(*r.filename, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/zip"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuthHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v RpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type VirusApiSars2ProteinDownloadPostRequest struct {
	ctx context.Context
	ApiService *VirusApiService
	v2Sars2ProteinDatasetRequest *V2Sars2ProteinDatasetRequest
	filename *string
}

func (r VirusApiSars2ProteinDownloadPostRequest) V2Sars2ProteinDatasetRequest(v2Sars2ProteinDatasetRequest V2Sars2ProteinDatasetRequest) VirusApiSars2ProteinDownloadPostRequest {
	r.v2Sars2ProteinDatasetRequest = &v2Sars2ProteinDatasetRequest
	return r
}

// Output file name.
func (r VirusApiSars2ProteinDownloadPostRequest) Filename(filename string) VirusApiSars2ProteinDownloadPostRequest {
	r.filename = &filename
	return r
}

func (r VirusApiSars2ProteinDownloadPostRequest) Execute() (**os.File, *http.Response, error) {
	return r.ApiService.Sars2ProteinDownloadPostExecute(r)
}

/*
Sars2ProteinDownloadPost Download SARS-CoV-2 protein and CDS datasets by protein name by POST request

Download SARS-CoV-2 protein datasets POST request

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return VirusApiSars2ProteinDownloadPostRequest
*/
func (a *VirusApiService) Sars2ProteinDownloadPost(ctx context.Context) VirusApiSars2ProteinDownloadPostRequest {
	return VirusApiSars2ProteinDownloadPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return *os.File
func (a *VirusApiService) Sars2ProteinDownloadPostExecute(r VirusApiSars2ProteinDownloadPostRequest) (**os.File, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  **os.File
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VirusApiService.Sars2ProteinDownloadPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/virus/taxon/sars2/protein/download"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.v2Sars2ProteinDatasetRequest == nil {
		return localVarReturnValue, nil, reportError("v2Sars2ProteinDatasetRequest is required and must be specified")
	}

	if r.filename != nil {
		localVarQueryParams.Add("filename", parameterToString(*r.filename, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/zip"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.v2Sars2ProteinDatasetRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuthHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v RpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type VirusApiSars2ProteinSummaryRequest struct {
	ctx context.Context
	ApiService *VirusApiService
	proteins []string
	refseqOnly *bool
	annotatedOnly *bool
	releasedSince *time.Time
	updatedSince *time.Time
	host *string
	geoLocation *string
	completeOnly *bool
	includeSequence *[]V2ViralSequenceType
	auxReport *[]V2VirusDatasetReportType
}

// If true, limit results to RefSeq genomes.
func (r VirusApiSars2ProteinSummaryRequest) RefseqOnly(refseqOnly bool) VirusApiSars2ProteinSummaryRequest {
	r.refseqOnly = &refseqOnly
	return r
}

// If true, limit results to annotated genomes.
func (r VirusApiSars2ProteinSummaryRequest) AnnotatedOnly(annotatedOnly bool) VirusApiSars2ProteinSummaryRequest {
	r.annotatedOnly = &annotatedOnly
	return r
}

// If set, limit results to viral genomes that have been released after a specified date (and optionally, time). April 1, 2020 midnight UTC should be formatted as &#39;2020-04-01T00:00:00.000Z&#39;
func (r VirusApiSars2ProteinSummaryRequest) ReleasedSince(releasedSince time.Time) VirusApiSars2ProteinSummaryRequest {
	r.releasedSince = &releasedSince
	return r
}

func (r VirusApiSars2ProteinSummaryRequest) UpdatedSince(updatedSince time.Time) VirusApiSars2ProteinSummaryRequest {
	r.updatedSince = &updatedSince
	return r
}

// If set, limit results to genomes extracted from this host (Taxonomy ID or name) All hosts by default
func (r VirusApiSars2ProteinSummaryRequest) Host(host string) VirusApiSars2ProteinSummaryRequest {
	r.host = &host
	return r
}

// Assemblies from this location (country and state, or continent)
func (r VirusApiSars2ProteinSummaryRequest) GeoLocation(geoLocation string) VirusApiSars2ProteinSummaryRequest {
	r.geoLocation = &geoLocation
	return r
}

// only include complete genomes.
func (r VirusApiSars2ProteinSummaryRequest) CompleteOnly(completeOnly bool) VirusApiSars2ProteinSummaryRequest {
	r.completeOnly = &completeOnly
	return r
}

// Specify which sequence files to include in the download
func (r VirusApiSars2ProteinSummaryRequest) IncludeSequence(includeSequence []V2ViralSequenceType) VirusApiSars2ProteinSummaryRequest {
	r.includeSequence = &includeSequence
	return r
}

// List additional reports to include with download. Data report is included by default.
func (r VirusApiSars2ProteinSummaryRequest) AuxReport(auxReport []V2VirusDatasetReportType) VirusApiSars2ProteinSummaryRequest {
	r.auxReport = &auxReport
	return r
}

func (r VirusApiSars2ProteinSummaryRequest) Execute() (*V2DownloadSummary, *http.Response, error) {
	return r.ApiService.Sars2ProteinSummaryExecute(r)
}

/*
Sars2ProteinSummary Summary of SARS-CoV-2 protein and CDS datasets by protein name

Download a summary of available SARS-CoV-2 protein datasets

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param proteins Which proteins to retrieve in the data package
 @return VirusApiSars2ProteinSummaryRequest
*/
func (a *VirusApiService) Sars2ProteinSummary(ctx context.Context, proteins []string) VirusApiSars2ProteinSummaryRequest {
	return VirusApiSars2ProteinSummaryRequest{
		ApiService: a,
		ctx: ctx,
		proteins: proteins,
	}
}

// Execute executes the request
//  @return V2DownloadSummary
func (a *VirusApiService) Sars2ProteinSummaryExecute(r VirusApiSars2ProteinSummaryRequest) (*V2DownloadSummary, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V2DownloadSummary
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VirusApiService.Sars2ProteinSummary")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/virus/taxon/sars2/protein/{proteins}"
	localVarPath = strings.Replace(localVarPath, "{"+"proteins"+"}", url.PathEscape(parameterToString(r.proteins, "csv")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.refseqOnly != nil {
		localVarQueryParams.Add("refseq_only", parameterToString(*r.refseqOnly, ""))
	}
	if r.annotatedOnly != nil {
		localVarQueryParams.Add("annotated_only", parameterToString(*r.annotatedOnly, ""))
	}
	if r.releasedSince != nil {
		localVarQueryParams.Add("released_since", parameterToString(*r.releasedSince, ""))
	}
	if r.updatedSince != nil {
		localVarQueryParams.Add("updated_since", parameterToString(*r.updatedSince, ""))
	}
	if r.host != nil {
		localVarQueryParams.Add("host", parameterToString(*r.host, ""))
	}
	if r.geoLocation != nil {
		localVarQueryParams.Add("geo_location", parameterToString(*r.geoLocation, ""))
	}
	if r.completeOnly != nil {
		localVarQueryParams.Add("complete_only", parameterToString(*r.completeOnly, ""))
	}
	if r.includeSequence != nil {
		t := *r.includeSequence
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("include_sequence", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("include_sequence", parameterToString(t, "multi"))
		}
	}
	if r.auxReport != nil {
		t := *r.auxReport
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("aux_report", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("aux_report", parameterToString(t, "multi"))
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuthHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v RpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type VirusApiSars2ProteinSummaryByPostRequest struct {
	ctx context.Context
	ApiService *VirusApiService
	v2Sars2ProteinDatasetRequest *V2Sars2ProteinDatasetRequest
}

func (r VirusApiSars2ProteinSummaryByPostRequest) V2Sars2ProteinDatasetRequest(v2Sars2ProteinDatasetRequest V2Sars2ProteinDatasetRequest) VirusApiSars2ProteinSummaryByPostRequest {
	r.v2Sars2ProteinDatasetRequest = &v2Sars2ProteinDatasetRequest
	return r
}

func (r VirusApiSars2ProteinSummaryByPostRequest) Execute() (*V2DownloadSummary, *http.Response, error) {
	return r.ApiService.Sars2ProteinSummaryByPostExecute(r)
}

/*
Sars2ProteinSummaryByPost Summary of SARS-CoV-2 protein and CDS datasets by protein name

Download a summary of available SARS-CoV-2 protein datasets

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return VirusApiSars2ProteinSummaryByPostRequest
*/
func (a *VirusApiService) Sars2ProteinSummaryByPost(ctx context.Context) VirusApiSars2ProteinSummaryByPostRequest {
	return VirusApiSars2ProteinSummaryByPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V2DownloadSummary
func (a *VirusApiService) Sars2ProteinSummaryByPostExecute(r VirusApiSars2ProteinSummaryByPostRequest) (*V2DownloadSummary, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V2DownloadSummary
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VirusApiService.Sars2ProteinSummaryByPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/virus/taxon/sars2/protein"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.v2Sars2ProteinDatasetRequest == nil {
		return localVarReturnValue, nil, reportError("v2Sars2ProteinDatasetRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.v2Sars2ProteinDatasetRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuthHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v RpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type VirusApiSars2ProteinTableRequest struct {
	ctx context.Context
	ApiService *VirusApiService
	proteins []string
	refseqOnly *bool
	annotatedOnly *bool
	releasedSince *time.Time
	updatedSince *time.Time
	host *string
	geoLocation *string
	completeOnly *bool
	tableFields *[]V2VirusTableField
	includeSequence *[]V2ViralSequenceType
	auxReport *[]V2VirusDatasetReportType
	format *V2TableFormat
}

// If true, limit results to RefSeq genomes.
func (r VirusApiSars2ProteinTableRequest) RefseqOnly(refseqOnly bool) VirusApiSars2ProteinTableRequest {
	r.refseqOnly = &refseqOnly
	return r
}

// If true, limit results to annotated genomes.
func (r VirusApiSars2ProteinTableRequest) AnnotatedOnly(annotatedOnly bool) VirusApiSars2ProteinTableRequest {
	r.annotatedOnly = &annotatedOnly
	return r
}

// If set, limit results to viral genomes that have been released after a specified date (and optionally, time). April 1, 2020 midnight UTC should be formatted as &#39;2020-04-01T00:00:00.000Z&#39;
func (r VirusApiSars2ProteinTableRequest) ReleasedSince(releasedSince time.Time) VirusApiSars2ProteinTableRequest {
	r.releasedSince = &releasedSince
	return r
}

func (r VirusApiSars2ProteinTableRequest) UpdatedSince(updatedSince time.Time) VirusApiSars2ProteinTableRequest {
	r.updatedSince = &updatedSince
	return r
}

// If set, limit results to genomes extracted from this host (Taxonomy ID or name) All hosts by default
func (r VirusApiSars2ProteinTableRequest) Host(host string) VirusApiSars2ProteinTableRequest {
	r.host = &host
	return r
}

// Assemblies from this location (country and state, or continent)
func (r VirusApiSars2ProteinTableRequest) GeoLocation(geoLocation string) VirusApiSars2ProteinTableRequest {
	r.geoLocation = &geoLocation
	return r
}

// only include complete genomes.
func (r VirusApiSars2ProteinTableRequest) CompleteOnly(completeOnly bool) VirusApiSars2ProteinTableRequest {
	r.completeOnly = &completeOnly
	return r
}

// Specify which fields to include in the tabular report
func (r VirusApiSars2ProteinTableRequest) TableFields(tableFields []V2VirusTableField) VirusApiSars2ProteinTableRequest {
	r.tableFields = &tableFields
	return r
}

// Specify which sequence files to include in the download
func (r VirusApiSars2ProteinTableRequest) IncludeSequence(includeSequence []V2ViralSequenceType) VirusApiSars2ProteinTableRequest {
	r.includeSequence = &includeSequence
	return r
}

// List additional reports to include with download. Data report is included by default.
func (r VirusApiSars2ProteinTableRequest) AuxReport(auxReport []V2VirusDatasetReportType) VirusApiSars2ProteinTableRequest {
	r.auxReport = &auxReport
	return r
}

// Choose download format (tsv, csv or jsonl)
func (r VirusApiSars2ProteinTableRequest) Format(format V2TableFormat) VirusApiSars2ProteinTableRequest {
	r.format = &format
	return r
}

func (r VirusApiSars2ProteinTableRequest) Execute() (*V2TabularOutput, *http.Response, error) {
	return r.ApiService.Sars2ProteinTableExecute(r)
}

/*
Sars2ProteinTable Get SARS-CoV-2 protein metadata in a tabular format.

Get protein metadata in tabular format for SARS-CoV-2 genomes.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param proteins Which proteins to retrieve in the data package
 @return VirusApiSars2ProteinTableRequest
*/
func (a *VirusApiService) Sars2ProteinTable(ctx context.Context, proteins []string) VirusApiSars2ProteinTableRequest {
	return VirusApiSars2ProteinTableRequest{
		ApiService: a,
		ctx: ctx,
		proteins: proteins,
	}
}

// Execute executes the request
//  @return V2TabularOutput
func (a *VirusApiService) Sars2ProteinTableExecute(r VirusApiSars2ProteinTableRequest) (*V2TabularOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V2TabularOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VirusApiService.Sars2ProteinTable")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/virus/taxon/sars2/protein/{proteins}/table"
	localVarPath = strings.Replace(localVarPath, "{"+"proteins"+"}", url.PathEscape(parameterToString(r.proteins, "csv")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.refseqOnly != nil {
		localVarQueryParams.Add("refseq_only", parameterToString(*r.refseqOnly, ""))
	}
	if r.annotatedOnly != nil {
		localVarQueryParams.Add("annotated_only", parameterToString(*r.annotatedOnly, ""))
	}
	if r.releasedSince != nil {
		localVarQueryParams.Add("released_since", parameterToString(*r.releasedSince, ""))
	}
	if r.updatedSince != nil {
		localVarQueryParams.Add("updated_since", parameterToString(*r.updatedSince, ""))
	}
	if r.host != nil {
		localVarQueryParams.Add("host", parameterToString(*r.host, ""))
	}
	if r.geoLocation != nil {
		localVarQueryParams.Add("geo_location", parameterToString(*r.geoLocation, ""))
	}
	if r.completeOnly != nil {
		localVarQueryParams.Add("complete_only", parameterToString(*r.completeOnly, ""))
	}
	if r.tableFields != nil {
		t := *r.tableFields
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("table_fields", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("table_fields", parameterToString(t, "multi"))
		}
	}
	if r.includeSequence != nil {
		t := *r.includeSequence
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("include_sequence", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("include_sequence", parameterToString(t, "multi"))
		}
	}
	if r.auxReport != nil {
		t := *r.auxReport
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("aux_report", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("aux_report", parameterToString(t, "multi"))
		}
	}
	if r.format != nil {
		localVarQueryParams.Add("format", parameterToString(*r.format, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuthHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v RpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type VirusApiVirusAccessionAvailabilityRequest struct {
	ctx context.Context
	ApiService *VirusApiService
	accessions []string
}

func (r VirusApiVirusAccessionAvailabilityRequest) Execute() (*V2VirusAvailability, *http.Response, error) {
	return r.ApiService.VirusAccessionAvailabilityExecute(r)
}

/*
VirusAccessionAvailability Check available viruses by accession

Check available viruses

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accessions virus accessions
 @return VirusApiVirusAccessionAvailabilityRequest
*/
func (a *VirusApiService) VirusAccessionAvailability(ctx context.Context, accessions []string) VirusApiVirusAccessionAvailabilityRequest {
	return VirusApiVirusAccessionAvailabilityRequest{
		ApiService: a,
		ctx: ctx,
		accessions: accessions,
	}
}

// Execute executes the request
//  @return V2VirusAvailability
func (a *VirusApiService) VirusAccessionAvailabilityExecute(r VirusApiVirusAccessionAvailabilityRequest) (*V2VirusAvailability, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V2VirusAvailability
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VirusApiService.VirusAccessionAvailability")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/virus/accession/{accessions}/check"
	localVarPath = strings.Replace(localVarPath, "{"+"accessions"+"}", url.PathEscape(parameterToString(r.accessions, "csv")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuthHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v RpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type VirusApiVirusAccessionAvailabilityPostRequest struct {
	ctx context.Context
	ApiService *VirusApiService
	v2VirusAvailabilityRequest *V2VirusAvailabilityRequest
}

func (r VirusApiVirusAccessionAvailabilityPostRequest) V2VirusAvailabilityRequest(v2VirusAvailabilityRequest V2VirusAvailabilityRequest) VirusApiVirusAccessionAvailabilityPostRequest {
	r.v2VirusAvailabilityRequest = &v2VirusAvailabilityRequest
	return r
}

func (r VirusApiVirusAccessionAvailabilityPostRequest) Execute() (*V2VirusAvailability, *http.Response, error) {
	return r.ApiService.VirusAccessionAvailabilityPostExecute(r)
}

/*
VirusAccessionAvailabilityPost Check available viruses by accession

Check available viruses

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return VirusApiVirusAccessionAvailabilityPostRequest
*/
func (a *VirusApiService) VirusAccessionAvailabilityPost(ctx context.Context) VirusApiVirusAccessionAvailabilityPostRequest {
	return VirusApiVirusAccessionAvailabilityPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V2VirusAvailability
func (a *VirusApiService) VirusAccessionAvailabilityPostExecute(r VirusApiVirusAccessionAvailabilityPostRequest) (*V2VirusAvailability, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V2VirusAvailability
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VirusApiService.VirusAccessionAvailabilityPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/virus/check"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.v2VirusAvailabilityRequest == nil {
		return localVarReturnValue, nil, reportError("v2VirusAvailabilityRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.v2VirusAvailabilityRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuthHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v RpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type VirusApiVirusAnnotationReportsByAcessionsRequest struct {
	ctx context.Context
	ApiService *VirusApiService
	accessions []string
	filterRefseqOnly *bool
	filterReleasedSince *time.Time
	filterUpdatedSince *time.Time
	filterHost *string
	filterPangolinClassification *string
	filterGeoLocation *string
	filterCompleteOnly *bool
	tableFields *[]string
	pageSize *int32
	pageToken *string
}

// If true, limit results to RefSeq genomes.
func (r VirusApiVirusAnnotationReportsByAcessionsRequest) FilterRefseqOnly(filterRefseqOnly bool) VirusApiVirusAnnotationReportsByAcessionsRequest {
	r.filterRefseqOnly = &filterRefseqOnly
	return r
}

// If set, limit results to viral genomes that have been released after a specified date (and optionally, time). April 1, 2020 midnight UTC should be formatted as &#39;2020-04-01T00:00:00.000Z&#39;
func (r VirusApiVirusAnnotationReportsByAcessionsRequest) FilterReleasedSince(filterReleasedSince time.Time) VirusApiVirusAnnotationReportsByAcessionsRequest {
	r.filterReleasedSince = &filterReleasedSince
	return r
}

func (r VirusApiVirusAnnotationReportsByAcessionsRequest) FilterUpdatedSince(filterUpdatedSince time.Time) VirusApiVirusAnnotationReportsByAcessionsRequest {
	r.filterUpdatedSince = &filterUpdatedSince
	return r
}

// If set, limit results to genomes extracted from this host (Taxonomy ID or name) All hosts by default
func (r VirusApiVirusAnnotationReportsByAcessionsRequest) FilterHost(filterHost string) VirusApiVirusAnnotationReportsByAcessionsRequest {
	r.filterHost = &filterHost
	return r
}

// If set, limit results to genomes classified to this lineage by the PangoLearn tool.
func (r VirusApiVirusAnnotationReportsByAcessionsRequest) FilterPangolinClassification(filterPangolinClassification string) VirusApiVirusAnnotationReportsByAcessionsRequest {
	r.filterPangolinClassification = &filterPangolinClassification
	return r
}

// Assemblies from this location (country and state, or continent)
func (r VirusApiVirusAnnotationReportsByAcessionsRequest) FilterGeoLocation(filterGeoLocation string) VirusApiVirusAnnotationReportsByAcessionsRequest {
	r.filterGeoLocation = &filterGeoLocation
	return r
}

// only include complete genomes.
func (r VirusApiVirusAnnotationReportsByAcessionsRequest) FilterCompleteOnly(filterCompleteOnly bool) VirusApiVirusAnnotationReportsByAcessionsRequest {
	r.filterCompleteOnly = &filterCompleteOnly
	return r
}

// Specify which fields to include in the tabular report
func (r VirusApiVirusAnnotationReportsByAcessionsRequest) TableFields(tableFields []string) VirusApiVirusAnnotationReportsByAcessionsRequest {
	r.tableFields = &tableFields
	return r
}

// The maximum number of virus data reports to return. Default is 20 and maximum is 1000. If the number of results exceeds the page size, &#x60;page_token&#x60; can be used to retrieve the remaining results.
func (r VirusApiVirusAnnotationReportsByAcessionsRequest) PageSize(pageSize int32) VirusApiVirusAnnotationReportsByAcessionsRequest {
	r.pageSize = &pageSize
	return r
}

// A page token is returned from a &#x60;GetVirusDataReports&#x60; call with more than &#x60;page_size&#x60; results. Use this token, along with the previous &#x60;VirusDataReportRequest&#x60; parameters, to retrieve the next page of results. When &#x60;page_token&#x60; is empty, all results have been retrieved.
func (r VirusApiVirusAnnotationReportsByAcessionsRequest) PageToken(pageToken string) VirusApiVirusAnnotationReportsByAcessionsRequest {
	r.pageToken = &pageToken
	return r
}

func (r VirusApiVirusAnnotationReportsByAcessionsRequest) Execute() (*V2reportsVirusAnnotationReportPage, *http.Response, error) {
	return r.ApiService.VirusAnnotationReportsByAcessionsExecute(r)
}

/*
VirusAnnotationReportsByAcessions Get virus annotation report by accession

Get virus annotation report by accesion. By default, in paged JSON format, but also available as tabular (accept: text/tab-separated-values) or json-lines (accept: application/x-ndjson)

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accessions genome sequence accessions
 @return VirusApiVirusAnnotationReportsByAcessionsRequest
*/
func (a *VirusApiService) VirusAnnotationReportsByAcessions(ctx context.Context, accessions []string) VirusApiVirusAnnotationReportsByAcessionsRequest {
	return VirusApiVirusAnnotationReportsByAcessionsRequest{
		ApiService: a,
		ctx: ctx,
		accessions: accessions,
	}
}

// Execute executes the request
//  @return V2reportsVirusAnnotationReportPage
func (a *VirusApiService) VirusAnnotationReportsByAcessionsExecute(r VirusApiVirusAnnotationReportsByAcessionsRequest) (*V2reportsVirusAnnotationReportPage, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V2reportsVirusAnnotationReportPage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VirusApiService.VirusAnnotationReportsByAcessions")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/virus/accession/{accessions}/annotation_report"
	localVarPath = strings.Replace(localVarPath, "{"+"accessions"+"}", url.PathEscape(parameterToString(r.accessions, "csv")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.filterRefseqOnly != nil {
		localVarQueryParams.Add("filter.refseq_only", parameterToString(*r.filterRefseqOnly, ""))
	}
	if r.filterReleasedSince != nil {
		localVarQueryParams.Add("filter.released_since", parameterToString(*r.filterReleasedSince, ""))
	}
	if r.filterUpdatedSince != nil {
		localVarQueryParams.Add("filter.updated_since", parameterToString(*r.filterUpdatedSince, ""))
	}
	if r.filterHost != nil {
		localVarQueryParams.Add("filter.host", parameterToString(*r.filterHost, ""))
	}
	if r.filterPangolinClassification != nil {
		localVarQueryParams.Add("filter.pangolin_classification", parameterToString(*r.filterPangolinClassification, ""))
	}
	if r.filterGeoLocation != nil {
		localVarQueryParams.Add("filter.geo_location", parameterToString(*r.filterGeoLocation, ""))
	}
	if r.filterCompleteOnly != nil {
		localVarQueryParams.Add("filter.complete_only", parameterToString(*r.filterCompleteOnly, ""))
	}
	if r.tableFields != nil {
		t := *r.tableFields
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("table_fields", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("table_fields", parameterToString(t, "multi"))
		}
	}
	if r.pageSize != nil {
		localVarQueryParams.Add("page_size", parameterToString(*r.pageSize, ""))
	}
	if r.pageToken != nil {
		localVarQueryParams.Add("page_token", parameterToString(*r.pageToken, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "application/x-ndjson", "text/tab-separated-values"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuthHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v RpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type VirusApiVirusAnnotationReportsByPostRequest struct {
	ctx context.Context
	ApiService *VirusApiService
	v2VirusAnnotationReportRequest *V2VirusAnnotationReportRequest
}

func (r VirusApiVirusAnnotationReportsByPostRequest) V2VirusAnnotationReportRequest(v2VirusAnnotationReportRequest V2VirusAnnotationReportRequest) VirusApiVirusAnnotationReportsByPostRequest {
	r.v2VirusAnnotationReportRequest = &v2VirusAnnotationReportRequest
	return r
}

func (r VirusApiVirusAnnotationReportsByPostRequest) Execute() (*V2reportsVirusAnnotationReportPage, *http.Response, error) {
	return r.ApiService.VirusAnnotationReportsByPostExecute(r)
}

/*
VirusAnnotationReportsByPost Get virus annotation report by POST

Get virus annotation report. By default, in paged JSON format, but also available as tabular (accept: text/tab-separated-values) or json-lines (accept: application/x-ndjson)

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return VirusApiVirusAnnotationReportsByPostRequest
*/
func (a *VirusApiService) VirusAnnotationReportsByPost(ctx context.Context) VirusApiVirusAnnotationReportsByPostRequest {
	return VirusApiVirusAnnotationReportsByPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V2reportsVirusAnnotationReportPage
func (a *VirusApiService) VirusAnnotationReportsByPostExecute(r VirusApiVirusAnnotationReportsByPostRequest) (*V2reportsVirusAnnotationReportPage, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V2reportsVirusAnnotationReportPage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VirusApiService.VirusAnnotationReportsByPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/virus/annotation_report"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.v2VirusAnnotationReportRequest == nil {
		return localVarReturnValue, nil, reportError("v2VirusAnnotationReportRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "application/x-ndjson", "text/tab-separated-values"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.v2VirusAnnotationReportRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuthHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v RpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type VirusApiVirusAnnotationReportsByTaxonRequest struct {
	ctx context.Context
	ApiService *VirusApiService
	taxon string
	filterRefseqOnly *bool
	filterReleasedSince *time.Time
	filterUpdatedSince *time.Time
	filterHost *string
	filterPangolinClassification *string
	filterGeoLocation *string
	filterCompleteOnly *bool
	tableFields *[]string
	pageSize *int32
	pageToken *string
}

// If true, limit results to RefSeq genomes.
func (r VirusApiVirusAnnotationReportsByTaxonRequest) FilterRefseqOnly(filterRefseqOnly bool) VirusApiVirusAnnotationReportsByTaxonRequest {
	r.filterRefseqOnly = &filterRefseqOnly
	return r
}

// If set, limit results to viral genomes that have been released after a specified date (and optionally, time). April 1, 2020 midnight UTC should be formatted as &#39;2020-04-01T00:00:00.000Z&#39;
func (r VirusApiVirusAnnotationReportsByTaxonRequest) FilterReleasedSince(filterReleasedSince time.Time) VirusApiVirusAnnotationReportsByTaxonRequest {
	r.filterReleasedSince = &filterReleasedSince
	return r
}

func (r VirusApiVirusAnnotationReportsByTaxonRequest) FilterUpdatedSince(filterUpdatedSince time.Time) VirusApiVirusAnnotationReportsByTaxonRequest {
	r.filterUpdatedSince = &filterUpdatedSince
	return r
}

// If set, limit results to genomes extracted from this host (Taxonomy ID or name) All hosts by default
func (r VirusApiVirusAnnotationReportsByTaxonRequest) FilterHost(filterHost string) VirusApiVirusAnnotationReportsByTaxonRequest {
	r.filterHost = &filterHost
	return r
}

// If set, limit results to genomes classified to this lineage by the PangoLearn tool.
func (r VirusApiVirusAnnotationReportsByTaxonRequest) FilterPangolinClassification(filterPangolinClassification string) VirusApiVirusAnnotationReportsByTaxonRequest {
	r.filterPangolinClassification = &filterPangolinClassification
	return r
}

// Assemblies from this location (country and state, or continent)
func (r VirusApiVirusAnnotationReportsByTaxonRequest) FilterGeoLocation(filterGeoLocation string) VirusApiVirusAnnotationReportsByTaxonRequest {
	r.filterGeoLocation = &filterGeoLocation
	return r
}

// only include complete genomes.
func (r VirusApiVirusAnnotationReportsByTaxonRequest) FilterCompleteOnly(filterCompleteOnly bool) VirusApiVirusAnnotationReportsByTaxonRequest {
	r.filterCompleteOnly = &filterCompleteOnly
	return r
}

// Specify which fields to include in the tabular report
func (r VirusApiVirusAnnotationReportsByTaxonRequest) TableFields(tableFields []string) VirusApiVirusAnnotationReportsByTaxonRequest {
	r.tableFields = &tableFields
	return r
}

// The maximum number of virus data reports to return. Default is 20 and maximum is 1000. If the number of results exceeds the page size, &#x60;page_token&#x60; can be used to retrieve the remaining results.
func (r VirusApiVirusAnnotationReportsByTaxonRequest) PageSize(pageSize int32) VirusApiVirusAnnotationReportsByTaxonRequest {
	r.pageSize = &pageSize
	return r
}

// A page token is returned from a &#x60;GetVirusDataReports&#x60; call with more than &#x60;page_size&#x60; results. Use this token, along with the previous &#x60;VirusDataReportRequest&#x60; parameters, to retrieve the next page of results. When &#x60;page_token&#x60; is empty, all results have been retrieved.
func (r VirusApiVirusAnnotationReportsByTaxonRequest) PageToken(pageToken string) VirusApiVirusAnnotationReportsByTaxonRequest {
	r.pageToken = &pageToken
	return r
}

func (r VirusApiVirusAnnotationReportsByTaxonRequest) Execute() (*V2reportsVirusAnnotationReportPage, *http.Response, error) {
	return r.ApiService.VirusAnnotationReportsByTaxonExecute(r)
}

/*
VirusAnnotationReportsByTaxon Get virus annotation report by taxon

Get virus annotation report by taxon. By default, in paged JSON format, but also available as tabular (accept: text/tab-separated-values) or json-lines (accept: application/x-ndjson)

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param taxon NCBI Taxonomy ID or name (common or scientific) at any taxonomic rank
 @return VirusApiVirusAnnotationReportsByTaxonRequest
*/
func (a *VirusApiService) VirusAnnotationReportsByTaxon(ctx context.Context, taxon string) VirusApiVirusAnnotationReportsByTaxonRequest {
	return VirusApiVirusAnnotationReportsByTaxonRequest{
		ApiService: a,
		ctx: ctx,
		taxon: taxon,
	}
}

// Execute executes the request
//  @return V2reportsVirusAnnotationReportPage
func (a *VirusApiService) VirusAnnotationReportsByTaxonExecute(r VirusApiVirusAnnotationReportsByTaxonRequest) (*V2reportsVirusAnnotationReportPage, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V2reportsVirusAnnotationReportPage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VirusApiService.VirusAnnotationReportsByTaxon")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/virus/taxon/{taxon}/annotation_report"
	localVarPath = strings.Replace(localVarPath, "{"+"taxon"+"}", url.PathEscape(parameterToString(r.taxon, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.filterRefseqOnly != nil {
		localVarQueryParams.Add("filter.refseq_only", parameterToString(*r.filterRefseqOnly, ""))
	}
	if r.filterReleasedSince != nil {
		localVarQueryParams.Add("filter.released_since", parameterToString(*r.filterReleasedSince, ""))
	}
	if r.filterUpdatedSince != nil {
		localVarQueryParams.Add("filter.updated_since", parameterToString(*r.filterUpdatedSince, ""))
	}
	if r.filterHost != nil {
		localVarQueryParams.Add("filter.host", parameterToString(*r.filterHost, ""))
	}
	if r.filterPangolinClassification != nil {
		localVarQueryParams.Add("filter.pangolin_classification", parameterToString(*r.filterPangolinClassification, ""))
	}
	if r.filterGeoLocation != nil {
		localVarQueryParams.Add("filter.geo_location", parameterToString(*r.filterGeoLocation, ""))
	}
	if r.filterCompleteOnly != nil {
		localVarQueryParams.Add("filter.complete_only", parameterToString(*r.filterCompleteOnly, ""))
	}
	if r.tableFields != nil {
		t := *r.tableFields
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("table_fields", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("table_fields", parameterToString(t, "multi"))
		}
	}
	if r.pageSize != nil {
		localVarQueryParams.Add("page_size", parameterToString(*r.pageSize, ""))
	}
	if r.pageToken != nil {
		localVarQueryParams.Add("page_token", parameterToString(*r.pageToken, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "application/x-ndjson", "text/tab-separated-values"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuthHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v RpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type VirusApiVirusGenomeDownloadRequest struct {
	ctx context.Context
	ApiService *VirusApiService
	taxon string
	refseqOnly *bool
	annotatedOnly *bool
	releasedSince *time.Time
	updatedSince *time.Time
	host *string
	pangolinClassification *string
	geoLocation *string
	completeOnly *bool
	includeSequence *[]V2ViralSequenceType
	auxReport *[]V2VirusDatasetReportType
	usePsg *bool
	filename *string
}

// If true, limit results to RefSeq genomes.
func (r VirusApiVirusGenomeDownloadRequest) RefseqOnly(refseqOnly bool) VirusApiVirusGenomeDownloadRequest {
	r.refseqOnly = &refseqOnly
	return r
}

// If true, limit results to annotated genomes.
func (r VirusApiVirusGenomeDownloadRequest) AnnotatedOnly(annotatedOnly bool) VirusApiVirusGenomeDownloadRequest {
	r.annotatedOnly = &annotatedOnly
	return r
}

// If set, limit results to viral genomes that have been released after a specified date (and optionally, time). April 1, 2020 midnight UTC should be formatted as &#39;2020-04-01T00:00:00.000Z&#39;
func (r VirusApiVirusGenomeDownloadRequest) ReleasedSince(releasedSince time.Time) VirusApiVirusGenomeDownloadRequest {
	r.releasedSince = &releasedSince
	return r
}

func (r VirusApiVirusGenomeDownloadRequest) UpdatedSince(updatedSince time.Time) VirusApiVirusGenomeDownloadRequest {
	r.updatedSince = &updatedSince
	return r
}

// If set, limit results to genomes extracted from this host (Taxonomy ID or name) All hosts by default
func (r VirusApiVirusGenomeDownloadRequest) Host(host string) VirusApiVirusGenomeDownloadRequest {
	r.host = &host
	return r
}

// If set, limit results to genomes classified to this lineage by the PangoLearn tool.
func (r VirusApiVirusGenomeDownloadRequest) PangolinClassification(pangolinClassification string) VirusApiVirusGenomeDownloadRequest {
	r.pangolinClassification = &pangolinClassification
	return r
}

// Assemblies from this location (country and state, or continent)
func (r VirusApiVirusGenomeDownloadRequest) GeoLocation(geoLocation string) VirusApiVirusGenomeDownloadRequest {
	r.geoLocation = &geoLocation
	return r
}

// only include complete genomes.
func (r VirusApiVirusGenomeDownloadRequest) CompleteOnly(completeOnly bool) VirusApiVirusGenomeDownloadRequest {
	r.completeOnly = &completeOnly
	return r
}

// specify which sequence files to include in the download
func (r VirusApiVirusGenomeDownloadRequest) IncludeSequence(includeSequence []V2ViralSequenceType) VirusApiVirusGenomeDownloadRequest {
	r.includeSequence = &includeSequence
	return r
}

// list additional reports to include with download. Data report is included by default.
func (r VirusApiVirusGenomeDownloadRequest) AuxReport(auxReport []V2VirusDatasetReportType) VirusApiVirusGenomeDownloadRequest {
	r.auxReport = &auxReport
	return r
}

// Experimental approach to retrieving sequence data.
func (r VirusApiVirusGenomeDownloadRequest) UsePsg(usePsg bool) VirusApiVirusGenomeDownloadRequest {
	r.usePsg = &usePsg
	return r
}

// Output file name.
func (r VirusApiVirusGenomeDownloadRequest) Filename(filename string) VirusApiVirusGenomeDownloadRequest {
	r.filename = &filename
	return r
}

func (r VirusApiVirusGenomeDownloadRequest) Execute() (**os.File, *http.Response, error) {
	return r.ApiService.VirusGenomeDownloadExecute(r)
}

/*
VirusGenomeDownload Download a virus genome dataset by taxon

Download a virus genome dataset by taxon

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param taxon NCBI Taxonomy ID or name (common or scientific) at any taxonomic rank
 @return VirusApiVirusGenomeDownloadRequest
*/
func (a *VirusApiService) VirusGenomeDownload(ctx context.Context, taxon string) VirusApiVirusGenomeDownloadRequest {
	return VirusApiVirusGenomeDownloadRequest{
		ApiService: a,
		ctx: ctx,
		taxon: taxon,
	}
}

// Execute executes the request
//  @return *os.File
func (a *VirusApiService) VirusGenomeDownloadExecute(r VirusApiVirusGenomeDownloadRequest) (**os.File, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  **os.File
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VirusApiService.VirusGenomeDownload")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/virus/taxon/{taxon}/genome/download"
	localVarPath = strings.Replace(localVarPath, "{"+"taxon"+"}", url.PathEscape(parameterToString(r.taxon, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.refseqOnly != nil {
		localVarQueryParams.Add("refseq_only", parameterToString(*r.refseqOnly, ""))
	}
	if r.annotatedOnly != nil {
		localVarQueryParams.Add("annotated_only", parameterToString(*r.annotatedOnly, ""))
	}
	if r.releasedSince != nil {
		localVarQueryParams.Add("released_since", parameterToString(*r.releasedSince, ""))
	}
	if r.updatedSince != nil {
		localVarQueryParams.Add("updated_since", parameterToString(*r.updatedSince, ""))
	}
	if r.host != nil {
		localVarQueryParams.Add("host", parameterToString(*r.host, ""))
	}
	if r.pangolinClassification != nil {
		localVarQueryParams.Add("pangolin_classification", parameterToString(*r.pangolinClassification, ""))
	}
	if r.geoLocation != nil {
		localVarQueryParams.Add("geo_location", parameterToString(*r.geoLocation, ""))
	}
	if r.completeOnly != nil {
		localVarQueryParams.Add("complete_only", parameterToString(*r.completeOnly, ""))
	}
	if r.includeSequence != nil {
		t := *r.includeSequence
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("include_sequence", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("include_sequence", parameterToString(t, "multi"))
		}
	}
	if r.auxReport != nil {
		t := *r.auxReport
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("aux_report", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("aux_report", parameterToString(t, "multi"))
		}
	}
	if r.usePsg != nil {
		localVarQueryParams.Add("use_psg", parameterToString(*r.usePsg, ""))
	}
	if r.filename != nil {
		localVarQueryParams.Add("filename", parameterToString(*r.filename, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/zip"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuthHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v RpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type VirusApiVirusGenomeDownloadAccessionRequest struct {
	ctx context.Context
	ApiService *VirusApiService
	accessions []string
	refseqOnly *bool
	annotatedOnly *bool
	releasedSince *time.Time
	updatedSince *time.Time
	host *string
	pangolinClassification *string
	geoLocation *string
	completeOnly *bool
	includeSequence *[]V2ViralSequenceType
	auxReport *[]V2VirusDatasetReportType
	usePsg *bool
	filename *string
}

// If true, limit results to RefSeq genomes.
func (r VirusApiVirusGenomeDownloadAccessionRequest) RefseqOnly(refseqOnly bool) VirusApiVirusGenomeDownloadAccessionRequest {
	r.refseqOnly = &refseqOnly
	return r
}

// If true, limit results to annotated genomes.
func (r VirusApiVirusGenomeDownloadAccessionRequest) AnnotatedOnly(annotatedOnly bool) VirusApiVirusGenomeDownloadAccessionRequest {
	r.annotatedOnly = &annotatedOnly
	return r
}

// If set, limit results to viral genomes that have been released after a specified date (and optionally, time). April 1, 2020 midnight UTC should be formatted as &#39;2020-04-01T00:00:00.000Z&#39;
func (r VirusApiVirusGenomeDownloadAccessionRequest) ReleasedSince(releasedSince time.Time) VirusApiVirusGenomeDownloadAccessionRequest {
	r.releasedSince = &releasedSince
	return r
}

func (r VirusApiVirusGenomeDownloadAccessionRequest) UpdatedSince(updatedSince time.Time) VirusApiVirusGenomeDownloadAccessionRequest {
	r.updatedSince = &updatedSince
	return r
}

// If set, limit results to genomes extracted from this host (Taxonomy ID or name) All hosts by default
func (r VirusApiVirusGenomeDownloadAccessionRequest) Host(host string) VirusApiVirusGenomeDownloadAccessionRequest {
	r.host = &host
	return r
}

// If set, limit results to genomes classified to this lineage by the PangoLearn tool.
func (r VirusApiVirusGenomeDownloadAccessionRequest) PangolinClassification(pangolinClassification string) VirusApiVirusGenomeDownloadAccessionRequest {
	r.pangolinClassification = &pangolinClassification
	return r
}

// Assemblies from this location (country and state, or continent)
func (r VirusApiVirusGenomeDownloadAccessionRequest) GeoLocation(geoLocation string) VirusApiVirusGenomeDownloadAccessionRequest {
	r.geoLocation = &geoLocation
	return r
}

// only include complete genomes.
func (r VirusApiVirusGenomeDownloadAccessionRequest) CompleteOnly(completeOnly bool) VirusApiVirusGenomeDownloadAccessionRequest {
	r.completeOnly = &completeOnly
	return r
}

// specify which sequence files to include in the download
func (r VirusApiVirusGenomeDownloadAccessionRequest) IncludeSequence(includeSequence []V2ViralSequenceType) VirusApiVirusGenomeDownloadAccessionRequest {
	r.includeSequence = &includeSequence
	return r
}

// list additional reports to include with download. Data report is included by default.
func (r VirusApiVirusGenomeDownloadAccessionRequest) AuxReport(auxReport []V2VirusDatasetReportType) VirusApiVirusGenomeDownloadAccessionRequest {
	r.auxReport = &auxReport
	return r
}

// Experimental approach to retrieving sequence data.
func (r VirusApiVirusGenomeDownloadAccessionRequest) UsePsg(usePsg bool) VirusApiVirusGenomeDownloadAccessionRequest {
	r.usePsg = &usePsg
	return r
}

// Output file name.
func (r VirusApiVirusGenomeDownloadAccessionRequest) Filename(filename string) VirusApiVirusGenomeDownloadAccessionRequest {
	r.filename = &filename
	return r
}

func (r VirusApiVirusGenomeDownloadAccessionRequest) Execute() (**os.File, *http.Response, error) {
	return r.ApiService.VirusGenomeDownloadAccessionExecute(r)
}

/*
VirusGenomeDownloadAccession Download a virus genome dataset by accession

Download a virus genome dataset by accession

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accessions genome sequence accessions
 @return VirusApiVirusGenomeDownloadAccessionRequest
*/
func (a *VirusApiService) VirusGenomeDownloadAccession(ctx context.Context, accessions []string) VirusApiVirusGenomeDownloadAccessionRequest {
	return VirusApiVirusGenomeDownloadAccessionRequest{
		ApiService: a,
		ctx: ctx,
		accessions: accessions,
	}
}

// Execute executes the request
//  @return *os.File
func (a *VirusApiService) VirusGenomeDownloadAccessionExecute(r VirusApiVirusGenomeDownloadAccessionRequest) (**os.File, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  **os.File
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VirusApiService.VirusGenomeDownloadAccession")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/virus/accession/{accessions}/genome/download"
	localVarPath = strings.Replace(localVarPath, "{"+"accessions"+"}", url.PathEscape(parameterToString(r.accessions, "csv")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.refseqOnly != nil {
		localVarQueryParams.Add("refseq_only", parameterToString(*r.refseqOnly, ""))
	}
	if r.annotatedOnly != nil {
		localVarQueryParams.Add("annotated_only", parameterToString(*r.annotatedOnly, ""))
	}
	if r.releasedSince != nil {
		localVarQueryParams.Add("released_since", parameterToString(*r.releasedSince, ""))
	}
	if r.updatedSince != nil {
		localVarQueryParams.Add("updated_since", parameterToString(*r.updatedSince, ""))
	}
	if r.host != nil {
		localVarQueryParams.Add("host", parameterToString(*r.host, ""))
	}
	if r.pangolinClassification != nil {
		localVarQueryParams.Add("pangolin_classification", parameterToString(*r.pangolinClassification, ""))
	}
	if r.geoLocation != nil {
		localVarQueryParams.Add("geo_location", parameterToString(*r.geoLocation, ""))
	}
	if r.completeOnly != nil {
		localVarQueryParams.Add("complete_only", parameterToString(*r.completeOnly, ""))
	}
	if r.includeSequence != nil {
		t := *r.includeSequence
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("include_sequence", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("include_sequence", parameterToString(t, "multi"))
		}
	}
	if r.auxReport != nil {
		t := *r.auxReport
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("aux_report", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("aux_report", parameterToString(t, "multi"))
		}
	}
	if r.usePsg != nil {
		localVarQueryParams.Add("use_psg", parameterToString(*r.usePsg, ""))
	}
	if r.filename != nil {
		localVarQueryParams.Add("filename", parameterToString(*r.filename, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/zip"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuthHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v RpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type VirusApiVirusGenomeDownloadPostRequest struct {
	ctx context.Context
	ApiService *VirusApiService
	v2VirusDatasetRequest *V2VirusDatasetRequest
	filename *string
}

func (r VirusApiVirusGenomeDownloadPostRequest) V2VirusDatasetRequest(v2VirusDatasetRequest V2VirusDatasetRequest) VirusApiVirusGenomeDownloadPostRequest {
	r.v2VirusDatasetRequest = &v2VirusDatasetRequest
	return r
}

// Output file name.
func (r VirusApiVirusGenomeDownloadPostRequest) Filename(filename string) VirusApiVirusGenomeDownloadPostRequest {
	r.filename = &filename
	return r
}

func (r VirusApiVirusGenomeDownloadPostRequest) Execute() (**os.File, *http.Response, error) {
	return r.ApiService.VirusGenomeDownloadPostExecute(r)
}

/*
VirusGenomeDownloadPost Get a virus genome dataset by post

The 'GET' version of download is limited by the size of the GET URL (2KB, which works out to about 140 genomic accessions).  The POST operation is provided to allow users to supply a larger number of accessions in a single request.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return VirusApiVirusGenomeDownloadPostRequest
*/
func (a *VirusApiService) VirusGenomeDownloadPost(ctx context.Context) VirusApiVirusGenomeDownloadPostRequest {
	return VirusApiVirusGenomeDownloadPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return *os.File
func (a *VirusApiService) VirusGenomeDownloadPostExecute(r VirusApiVirusGenomeDownloadPostRequest) (**os.File, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  **os.File
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VirusApiService.VirusGenomeDownloadPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/virus/genome/download"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.v2VirusDatasetRequest == nil {
		return localVarReturnValue, nil, reportError("v2VirusDatasetRequest is required and must be specified")
	}

	if r.filename != nil {
		localVarQueryParams.Add("filename", parameterToString(*r.filename, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/zip"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.v2VirusDatasetRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuthHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v RpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type VirusApiVirusGenomeSummaryRequest struct {
	ctx context.Context
	ApiService *VirusApiService
	taxon string
	accessions *[]string
	refseqOnly *bool
	annotatedOnly *bool
	releasedSince *time.Time
	updatedSince *time.Time
	host *string
	pangolinClassification *string
	geoLocation *string
	completeOnly *bool
	includeSequence *[]V2ViralSequenceType
	auxReport *[]V2VirusDatasetReportType
}

// genome sequence accessions
func (r VirusApiVirusGenomeSummaryRequest) Accessions(accessions []string) VirusApiVirusGenomeSummaryRequest {
	r.accessions = &accessions
	return r
}

// If true, limit results to RefSeq genomes.
func (r VirusApiVirusGenomeSummaryRequest) RefseqOnly(refseqOnly bool) VirusApiVirusGenomeSummaryRequest {
	r.refseqOnly = &refseqOnly
	return r
}

// If true, limit results to annotated genomes.
func (r VirusApiVirusGenomeSummaryRequest) AnnotatedOnly(annotatedOnly bool) VirusApiVirusGenomeSummaryRequest {
	r.annotatedOnly = &annotatedOnly
	return r
}

// If set, limit results to viral genomes that have been released after a specified date (and optionally, time). April 1, 2020 midnight UTC should be formatted as &#39;2020-04-01T00:00:00.000Z&#39;
func (r VirusApiVirusGenomeSummaryRequest) ReleasedSince(releasedSince time.Time) VirusApiVirusGenomeSummaryRequest {
	r.releasedSince = &releasedSince
	return r
}

func (r VirusApiVirusGenomeSummaryRequest) UpdatedSince(updatedSince time.Time) VirusApiVirusGenomeSummaryRequest {
	r.updatedSince = &updatedSince
	return r
}

// If set, limit results to genomes extracted from this host (Taxonomy ID or name) All hosts by default
func (r VirusApiVirusGenomeSummaryRequest) Host(host string) VirusApiVirusGenomeSummaryRequest {
	r.host = &host
	return r
}

// If set, limit results to genomes classified to this lineage by the PangoLearn tool.
func (r VirusApiVirusGenomeSummaryRequest) PangolinClassification(pangolinClassification string) VirusApiVirusGenomeSummaryRequest {
	r.pangolinClassification = &pangolinClassification
	return r
}

// Assemblies from this location (country and state, or continent)
func (r VirusApiVirusGenomeSummaryRequest) GeoLocation(geoLocation string) VirusApiVirusGenomeSummaryRequest {
	r.geoLocation = &geoLocation
	return r
}

// only include complete genomes.
func (r VirusApiVirusGenomeSummaryRequest) CompleteOnly(completeOnly bool) VirusApiVirusGenomeSummaryRequest {
	r.completeOnly = &completeOnly
	return r
}

// specify which sequence files to include in the download
func (r VirusApiVirusGenomeSummaryRequest) IncludeSequence(includeSequence []V2ViralSequenceType) VirusApiVirusGenomeSummaryRequest {
	r.includeSequence = &includeSequence
	return r
}

// list additional reports to include with download. Data report is included by default.
func (r VirusApiVirusGenomeSummaryRequest) AuxReport(auxReport []V2VirusDatasetReportType) VirusApiVirusGenomeSummaryRequest {
	r.auxReport = &auxReport
	return r
}

func (r VirusApiVirusGenomeSummaryRequest) Execute() (*V2DownloadSummary, *http.Response, error) {
	return r.ApiService.VirusGenomeSummaryExecute(r)
}

/*
VirusGenomeSummary Get summary data for virus genomes by taxon

Get summary data and download by command line instructions for virus genomes by taxon.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param taxon NCBI Taxonomy ID or name (common or scientific) at any taxonomic rank
 @return VirusApiVirusGenomeSummaryRequest
*/
func (a *VirusApiService) VirusGenomeSummary(ctx context.Context, taxon string) VirusApiVirusGenomeSummaryRequest {
	return VirusApiVirusGenomeSummaryRequest{
		ApiService: a,
		ctx: ctx,
		taxon: taxon,
	}
}

// Execute executes the request
//  @return V2DownloadSummary
func (a *VirusApiService) VirusGenomeSummaryExecute(r VirusApiVirusGenomeSummaryRequest) (*V2DownloadSummary, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V2DownloadSummary
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VirusApiService.VirusGenomeSummary")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/virus/taxon/{taxon}/genome"
	localVarPath = strings.Replace(localVarPath, "{"+"taxon"+"}", url.PathEscape(parameterToString(r.taxon, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.accessions != nil {
		t := *r.accessions
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("accessions", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("accessions", parameterToString(t, "multi"))
		}
	}
	if r.refseqOnly != nil {
		localVarQueryParams.Add("refseq_only", parameterToString(*r.refseqOnly, ""))
	}
	if r.annotatedOnly != nil {
		localVarQueryParams.Add("annotated_only", parameterToString(*r.annotatedOnly, ""))
	}
	if r.releasedSince != nil {
		localVarQueryParams.Add("released_since", parameterToString(*r.releasedSince, ""))
	}
	if r.updatedSince != nil {
		localVarQueryParams.Add("updated_since", parameterToString(*r.updatedSince, ""))
	}
	if r.host != nil {
		localVarQueryParams.Add("host", parameterToString(*r.host, ""))
	}
	if r.pangolinClassification != nil {
		localVarQueryParams.Add("pangolin_classification", parameterToString(*r.pangolinClassification, ""))
	}
	if r.geoLocation != nil {
		localVarQueryParams.Add("geo_location", parameterToString(*r.geoLocation, ""))
	}
	if r.completeOnly != nil {
		localVarQueryParams.Add("complete_only", parameterToString(*r.completeOnly, ""))
	}
	if r.includeSequence != nil {
		t := *r.includeSequence
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("include_sequence", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("include_sequence", parameterToString(t, "multi"))
		}
	}
	if r.auxReport != nil {
		t := *r.auxReport
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("aux_report", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("aux_report", parameterToString(t, "multi"))
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuthHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v RpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type VirusApiVirusGenomeSummaryByPostRequest struct {
	ctx context.Context
	ApiService *VirusApiService
	v2VirusDatasetRequest *V2VirusDatasetRequest
}

func (r VirusApiVirusGenomeSummaryByPostRequest) V2VirusDatasetRequest(v2VirusDatasetRequest V2VirusDatasetRequest) VirusApiVirusGenomeSummaryByPostRequest {
	r.v2VirusDatasetRequest = &v2VirusDatasetRequest
	return r
}

func (r VirusApiVirusGenomeSummaryByPostRequest) Execute() (*V2DownloadSummary, *http.Response, error) {
	return r.ApiService.VirusGenomeSummaryByPostExecute(r)
}

/*
VirusGenomeSummaryByPost Get summary data for virus genomes by post

Get summary data and download by command line instructions for virus genomes by taxon.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return VirusApiVirusGenomeSummaryByPostRequest
*/
func (a *VirusApiService) VirusGenomeSummaryByPost(ctx context.Context) VirusApiVirusGenomeSummaryByPostRequest {
	return VirusApiVirusGenomeSummaryByPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V2DownloadSummary
func (a *VirusApiService) VirusGenomeSummaryByPostExecute(r VirusApiVirusGenomeSummaryByPostRequest) (*V2DownloadSummary, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V2DownloadSummary
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VirusApiService.VirusGenomeSummaryByPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/virus/genome"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.v2VirusDatasetRequest == nil {
		return localVarReturnValue, nil, reportError("v2VirusDatasetRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.v2VirusDatasetRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuthHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v RpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type VirusApiVirusGenomeTableRequest struct {
	ctx context.Context
	ApiService *VirusApiService
	taxon string
	accessions *[]string
	refseqOnly *bool
	annotatedOnly *bool
	releasedSince *time.Time
	updatedSince *time.Time
	host *string
	pangolinClassification *string
	geoLocation *string
	completeOnly *bool
	tableFields *[]V2VirusTableField
	includeSequence *[]V2ViralSequenceType
	auxReport *[]V2VirusDatasetReportType
	format *V2TableFormat
}

// genome sequence accessions
func (r VirusApiVirusGenomeTableRequest) Accessions(accessions []string) VirusApiVirusGenomeTableRequest {
	r.accessions = &accessions
	return r
}

// If true, limit results to RefSeq genomes.
func (r VirusApiVirusGenomeTableRequest) RefseqOnly(refseqOnly bool) VirusApiVirusGenomeTableRequest {
	r.refseqOnly = &refseqOnly
	return r
}

// If true, limit results to annotated genomes.
func (r VirusApiVirusGenomeTableRequest) AnnotatedOnly(annotatedOnly bool) VirusApiVirusGenomeTableRequest {
	r.annotatedOnly = &annotatedOnly
	return r
}

// If set, limit results to viral genomes that have been released after a specified date (and optionally, time). April 1, 2020 midnight UTC should be formatted as &#39;2020-04-01T00:00:00.000Z&#39;
func (r VirusApiVirusGenomeTableRequest) ReleasedSince(releasedSince time.Time) VirusApiVirusGenomeTableRequest {
	r.releasedSince = &releasedSince
	return r
}

func (r VirusApiVirusGenomeTableRequest) UpdatedSince(updatedSince time.Time) VirusApiVirusGenomeTableRequest {
	r.updatedSince = &updatedSince
	return r
}

// If set, limit results to genomes extracted from this host (Taxonomy ID or name) All hosts by default
func (r VirusApiVirusGenomeTableRequest) Host(host string) VirusApiVirusGenomeTableRequest {
	r.host = &host
	return r
}

// If set, limit results to genomes classified to this lineage by the PangoLearn tool.
func (r VirusApiVirusGenomeTableRequest) PangolinClassification(pangolinClassification string) VirusApiVirusGenomeTableRequest {
	r.pangolinClassification = &pangolinClassification
	return r
}

// Assemblies from this location (country and state, or continent)
func (r VirusApiVirusGenomeTableRequest) GeoLocation(geoLocation string) VirusApiVirusGenomeTableRequest {
	r.geoLocation = &geoLocation
	return r
}

// only include complete genomes.
func (r VirusApiVirusGenomeTableRequest) CompleteOnly(completeOnly bool) VirusApiVirusGenomeTableRequest {
	r.completeOnly = &completeOnly
	return r
}

// Specify which fields to include in the tabular report
func (r VirusApiVirusGenomeTableRequest) TableFields(tableFields []V2VirusTableField) VirusApiVirusGenomeTableRequest {
	r.tableFields = &tableFields
	return r
}

// specify which sequence files to include in the download
func (r VirusApiVirusGenomeTableRequest) IncludeSequence(includeSequence []V2ViralSequenceType) VirusApiVirusGenomeTableRequest {
	r.includeSequence = &includeSequence
	return r
}

// list additional reports to include with download. Data report is included by default.
func (r VirusApiVirusGenomeTableRequest) AuxReport(auxReport []V2VirusDatasetReportType) VirusApiVirusGenomeTableRequest {
	r.auxReport = &auxReport
	return r
}

// Choose download format (tsv, csv or jsonl)
func (r VirusApiVirusGenomeTableRequest) Format(format V2TableFormat) VirusApiVirusGenomeTableRequest {
	r.format = &format
	return r
}

func (r VirusApiVirusGenomeTableRequest) Execute() (*V2TabularOutput, *http.Response, error) {
	return r.ApiService.VirusGenomeTableExecute(r)
}

/*
VirusGenomeTable Get virus genome metadata in a tabular format.

Get virus genome metadata in tabular format for virus genomes by taxon.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param taxon NCBI Taxonomy ID or name (common or scientific) at any taxonomic rank
 @return VirusApiVirusGenomeTableRequest
*/
func (a *VirusApiService) VirusGenomeTable(ctx context.Context, taxon string) VirusApiVirusGenomeTableRequest {
	return VirusApiVirusGenomeTableRequest{
		ApiService: a,
		ctx: ctx,
		taxon: taxon,
	}
}

// Execute executes the request
//  @return V2TabularOutput
func (a *VirusApiService) VirusGenomeTableExecute(r VirusApiVirusGenomeTableRequest) (*V2TabularOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V2TabularOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VirusApiService.VirusGenomeTable")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/virus/taxon/{taxon}/genome/table"
	localVarPath = strings.Replace(localVarPath, "{"+"taxon"+"}", url.PathEscape(parameterToString(r.taxon, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.accessions != nil {
		t := *r.accessions
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("accessions", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("accessions", parameterToString(t, "multi"))
		}
	}
	if r.refseqOnly != nil {
		localVarQueryParams.Add("refseq_only", parameterToString(*r.refseqOnly, ""))
	}
	if r.annotatedOnly != nil {
		localVarQueryParams.Add("annotated_only", parameterToString(*r.annotatedOnly, ""))
	}
	if r.releasedSince != nil {
		localVarQueryParams.Add("released_since", parameterToString(*r.releasedSince, ""))
	}
	if r.updatedSince != nil {
		localVarQueryParams.Add("updated_since", parameterToString(*r.updatedSince, ""))
	}
	if r.host != nil {
		localVarQueryParams.Add("host", parameterToString(*r.host, ""))
	}
	if r.pangolinClassification != nil {
		localVarQueryParams.Add("pangolin_classification", parameterToString(*r.pangolinClassification, ""))
	}
	if r.geoLocation != nil {
		localVarQueryParams.Add("geo_location", parameterToString(*r.geoLocation, ""))
	}
	if r.completeOnly != nil {
		localVarQueryParams.Add("complete_only", parameterToString(*r.completeOnly, ""))
	}
	if r.tableFields != nil {
		t := *r.tableFields
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("table_fields", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("table_fields", parameterToString(t, "multi"))
		}
	}
	if r.includeSequence != nil {
		t := *r.includeSequence
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("include_sequence", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("include_sequence", parameterToString(t, "multi"))
		}
	}
	if r.auxReport != nil {
		t := *r.auxReport
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("aux_report", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("aux_report", parameterToString(t, "multi"))
		}
	}
	if r.format != nil {
		localVarQueryParams.Add("format", parameterToString(*r.format, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuthHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v RpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type VirusApiVirusReportsByAcessionsRequest struct {
	ctx context.Context
	ApiService *VirusApiService
	accessions []string
	filterRefseqOnly *bool
	filterAnnotatedOnly *bool
	filterReleasedSince *time.Time
	filterUpdatedSince *time.Time
	filterHost *string
	filterPangolinClassification *string
	filterGeoLocation *string
	filterCompleteOnly *bool
	returnedContent *V2VirusDataReportRequestContentType
	tableFields *[]string
	pageSize *int32
	pageToken *string
}

// If true, limit results to RefSeq genomes.
func (r VirusApiVirusReportsByAcessionsRequest) FilterRefseqOnly(filterRefseqOnly bool) VirusApiVirusReportsByAcessionsRequest {
	r.filterRefseqOnly = &filterRefseqOnly
	return r
}

// If true, limit results to annotated genomes.
func (r VirusApiVirusReportsByAcessionsRequest) FilterAnnotatedOnly(filterAnnotatedOnly bool) VirusApiVirusReportsByAcessionsRequest {
	r.filterAnnotatedOnly = &filterAnnotatedOnly
	return r
}

// If set, limit results to viral genomes that have been released after a specified date (and optionally, time). April 1, 2020 midnight UTC should be formatted as &#39;2020-04-01T00:00:00.000Z&#39;
func (r VirusApiVirusReportsByAcessionsRequest) FilterReleasedSince(filterReleasedSince time.Time) VirusApiVirusReportsByAcessionsRequest {
	r.filterReleasedSince = &filterReleasedSince
	return r
}

func (r VirusApiVirusReportsByAcessionsRequest) FilterUpdatedSince(filterUpdatedSince time.Time) VirusApiVirusReportsByAcessionsRequest {
	r.filterUpdatedSince = &filterUpdatedSince
	return r
}

// If set, limit results to genomes extracted from this host (Taxonomy ID or name) All hosts by default
func (r VirusApiVirusReportsByAcessionsRequest) FilterHost(filterHost string) VirusApiVirusReportsByAcessionsRequest {
	r.filterHost = &filterHost
	return r
}

// If set, limit results to genomes classified to this lineage by the PangoLearn tool.
func (r VirusApiVirusReportsByAcessionsRequest) FilterPangolinClassification(filterPangolinClassification string) VirusApiVirusReportsByAcessionsRequest {
	r.filterPangolinClassification = &filterPangolinClassification
	return r
}

// Assemblies from this location (country and state, or continent)
func (r VirusApiVirusReportsByAcessionsRequest) FilterGeoLocation(filterGeoLocation string) VirusApiVirusReportsByAcessionsRequest {
	r.filterGeoLocation = &filterGeoLocation
	return r
}

// only include complete genomes.
func (r VirusApiVirusReportsByAcessionsRequest) FilterCompleteOnly(filterCompleteOnly bool) VirusApiVirusReportsByAcessionsRequest {
	r.filterCompleteOnly = &filterCompleteOnly
	return r
}

// Return either virus genome accessions, or complete virus metadata
func (r VirusApiVirusReportsByAcessionsRequest) ReturnedContent(returnedContent V2VirusDataReportRequestContentType) VirusApiVirusReportsByAcessionsRequest {
	r.returnedContent = &returnedContent
	return r
}

// Specify which fields to include in the tabular report
func (r VirusApiVirusReportsByAcessionsRequest) TableFields(tableFields []string) VirusApiVirusReportsByAcessionsRequest {
	r.tableFields = &tableFields
	return r
}

// The maximum number of virus data reports to return. Default is 20 and maximum is 1000. If the number of results exceeds the page size, &#x60;page_token&#x60; can be used to retrieve the remaining results.
func (r VirusApiVirusReportsByAcessionsRequest) PageSize(pageSize int32) VirusApiVirusReportsByAcessionsRequest {
	r.pageSize = &pageSize
	return r
}

// A page token is returned from a &#x60;GetVirusDataReports&#x60; call with more than &#x60;page_size&#x60; results. Use this token, along with the previous &#x60;VirusDataReportRequest&#x60; parameters, to retrieve the next page of results. When &#x60;page_token&#x60; is empty, all results have been retrieved.
func (r VirusApiVirusReportsByAcessionsRequest) PageToken(pageToken string) VirusApiVirusReportsByAcessionsRequest {
	r.pageToken = &pageToken
	return r
}

func (r VirusApiVirusReportsByAcessionsRequest) Execute() (*V2reportsVirusDataReportPage, *http.Response, error) {
	return r.ApiService.VirusReportsByAcessionsExecute(r)
}

/*
VirusReportsByAcessions Get virus metadata by accession

Get virus metadata by accesion. By default, in paged JSON format, but also available as tabular (accept: text/tab-separated-values) or json-lines (accept: application/x-ndjson)

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accessions genome sequence accessions
 @return VirusApiVirusReportsByAcessionsRequest
*/
func (a *VirusApiService) VirusReportsByAcessions(ctx context.Context, accessions []string) VirusApiVirusReportsByAcessionsRequest {
	return VirusApiVirusReportsByAcessionsRequest{
		ApiService: a,
		ctx: ctx,
		accessions: accessions,
	}
}

// Execute executes the request
//  @return V2reportsVirusDataReportPage
func (a *VirusApiService) VirusReportsByAcessionsExecute(r VirusApiVirusReportsByAcessionsRequest) (*V2reportsVirusDataReportPage, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V2reportsVirusDataReportPage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VirusApiService.VirusReportsByAcessions")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/virus/accession/{accessions}/dataset_report"
	localVarPath = strings.Replace(localVarPath, "{"+"accessions"+"}", url.PathEscape(parameterToString(r.accessions, "csv")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.filterRefseqOnly != nil {
		localVarQueryParams.Add("filter.refseq_only", parameterToString(*r.filterRefseqOnly, ""))
	}
	if r.filterAnnotatedOnly != nil {
		localVarQueryParams.Add("filter.annotated_only", parameterToString(*r.filterAnnotatedOnly, ""))
	}
	if r.filterReleasedSince != nil {
		localVarQueryParams.Add("filter.released_since", parameterToString(*r.filterReleasedSince, ""))
	}
	if r.filterUpdatedSince != nil {
		localVarQueryParams.Add("filter.updated_since", parameterToString(*r.filterUpdatedSince, ""))
	}
	if r.filterHost != nil {
		localVarQueryParams.Add("filter.host", parameterToString(*r.filterHost, ""))
	}
	if r.filterPangolinClassification != nil {
		localVarQueryParams.Add("filter.pangolin_classification", parameterToString(*r.filterPangolinClassification, ""))
	}
	if r.filterGeoLocation != nil {
		localVarQueryParams.Add("filter.geo_location", parameterToString(*r.filterGeoLocation, ""))
	}
	if r.filterCompleteOnly != nil {
		localVarQueryParams.Add("filter.complete_only", parameterToString(*r.filterCompleteOnly, ""))
	}
	if r.returnedContent != nil {
		localVarQueryParams.Add("returned_content", parameterToString(*r.returnedContent, ""))
	}
	if r.tableFields != nil {
		t := *r.tableFields
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("table_fields", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("table_fields", parameterToString(t, "multi"))
		}
	}
	if r.pageSize != nil {
		localVarQueryParams.Add("page_size", parameterToString(*r.pageSize, ""))
	}
	if r.pageToken != nil {
		localVarQueryParams.Add("page_token", parameterToString(*r.pageToken, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "application/x-ndjson", "text/tab-separated-values"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuthHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v RpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type VirusApiVirusReportsByPostRequest struct {
	ctx context.Context
	ApiService *VirusApiService
	v2VirusDataReportRequest *V2VirusDataReportRequest
}

func (r VirusApiVirusReportsByPostRequest) V2VirusDataReportRequest(v2VirusDataReportRequest V2VirusDataReportRequest) VirusApiVirusReportsByPostRequest {
	r.v2VirusDataReportRequest = &v2VirusDataReportRequest
	return r
}

func (r VirusApiVirusReportsByPostRequest) Execute() (*V2reportsVirusDataReportPage, *http.Response, error) {
	return r.ApiService.VirusReportsByPostExecute(r)
}

/*
VirusReportsByPost Get virus metadata by POST

Get virus metadata. By default, in paged JSON format, but also available as tabular (accept: text/tab-separated-values) or json-lines (accept: application/x-ndjson)

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return VirusApiVirusReportsByPostRequest
*/
func (a *VirusApiService) VirusReportsByPost(ctx context.Context) VirusApiVirusReportsByPostRequest {
	return VirusApiVirusReportsByPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V2reportsVirusDataReportPage
func (a *VirusApiService) VirusReportsByPostExecute(r VirusApiVirusReportsByPostRequest) (*V2reportsVirusDataReportPage, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V2reportsVirusDataReportPage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VirusApiService.VirusReportsByPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/virus"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.v2VirusDataReportRequest == nil {
		return localVarReturnValue, nil, reportError("v2VirusDataReportRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "application/x-ndjson", "text/tab-separated-values"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.v2VirusDataReportRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuthHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v RpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type VirusApiVirusReportsByTaxonRequest struct {
	ctx context.Context
	ApiService *VirusApiService
	taxon string
	filterRefseqOnly *bool
	filterAnnotatedOnly *bool
	filterReleasedSince *time.Time
	filterUpdatedSince *time.Time
	filterHost *string
	filterPangolinClassification *string
	filterGeoLocation *string
	filterCompleteOnly *bool
	returnedContent *V2VirusDataReportRequestContentType
	tableFields *[]string
	pageSize *int32
	pageToken *string
}

// If true, limit results to RefSeq genomes.
func (r VirusApiVirusReportsByTaxonRequest) FilterRefseqOnly(filterRefseqOnly bool) VirusApiVirusReportsByTaxonRequest {
	r.filterRefseqOnly = &filterRefseqOnly
	return r
}

// If true, limit results to annotated genomes.
func (r VirusApiVirusReportsByTaxonRequest) FilterAnnotatedOnly(filterAnnotatedOnly bool) VirusApiVirusReportsByTaxonRequest {
	r.filterAnnotatedOnly = &filterAnnotatedOnly
	return r
}

// If set, limit results to viral genomes that have been released after a specified date (and optionally, time). April 1, 2020 midnight UTC should be formatted as &#39;2020-04-01T00:00:00.000Z&#39;
func (r VirusApiVirusReportsByTaxonRequest) FilterReleasedSince(filterReleasedSince time.Time) VirusApiVirusReportsByTaxonRequest {
	r.filterReleasedSince = &filterReleasedSince
	return r
}

func (r VirusApiVirusReportsByTaxonRequest) FilterUpdatedSince(filterUpdatedSince time.Time) VirusApiVirusReportsByTaxonRequest {
	r.filterUpdatedSince = &filterUpdatedSince
	return r
}

// If set, limit results to genomes extracted from this host (Taxonomy ID or name) All hosts by default
func (r VirusApiVirusReportsByTaxonRequest) FilterHost(filterHost string) VirusApiVirusReportsByTaxonRequest {
	r.filterHost = &filterHost
	return r
}

// If set, limit results to genomes classified to this lineage by the PangoLearn tool.
func (r VirusApiVirusReportsByTaxonRequest) FilterPangolinClassification(filterPangolinClassification string) VirusApiVirusReportsByTaxonRequest {
	r.filterPangolinClassification = &filterPangolinClassification
	return r
}

// Assemblies from this location (country and state, or continent)
func (r VirusApiVirusReportsByTaxonRequest) FilterGeoLocation(filterGeoLocation string) VirusApiVirusReportsByTaxonRequest {
	r.filterGeoLocation = &filterGeoLocation
	return r
}

// only include complete genomes.
func (r VirusApiVirusReportsByTaxonRequest) FilterCompleteOnly(filterCompleteOnly bool) VirusApiVirusReportsByTaxonRequest {
	r.filterCompleteOnly = &filterCompleteOnly
	return r
}

// Return either virus genome accessions, or complete virus metadata
func (r VirusApiVirusReportsByTaxonRequest) ReturnedContent(returnedContent V2VirusDataReportRequestContentType) VirusApiVirusReportsByTaxonRequest {
	r.returnedContent = &returnedContent
	return r
}

// Specify which fields to include in the tabular report
func (r VirusApiVirusReportsByTaxonRequest) TableFields(tableFields []string) VirusApiVirusReportsByTaxonRequest {
	r.tableFields = &tableFields
	return r
}

// The maximum number of virus data reports to return. Default is 20 and maximum is 1000. If the number of results exceeds the page size, &#x60;page_token&#x60; can be used to retrieve the remaining results.
func (r VirusApiVirusReportsByTaxonRequest) PageSize(pageSize int32) VirusApiVirusReportsByTaxonRequest {
	r.pageSize = &pageSize
	return r
}

// A page token is returned from a &#x60;GetVirusDataReports&#x60; call with more than &#x60;page_size&#x60; results. Use this token, along with the previous &#x60;VirusDataReportRequest&#x60; parameters, to retrieve the next page of results. When &#x60;page_token&#x60; is empty, all results have been retrieved.
func (r VirusApiVirusReportsByTaxonRequest) PageToken(pageToken string) VirusApiVirusReportsByTaxonRequest {
	r.pageToken = &pageToken
	return r
}

func (r VirusApiVirusReportsByTaxonRequest) Execute() (*V2reportsVirusDataReportPage, *http.Response, error) {
	return r.ApiService.VirusReportsByTaxonExecute(r)
}

/*
VirusReportsByTaxon Get virus metadata by taxon

Get virus metadata by taxon. By default, in paged JSON format, but also available as tabular (accept: text/tab-separated-values) or json-lines (accept: application/x-ndjson)

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param taxon NCBI Taxonomy ID or name (common or scientific) at any taxonomic rank
 @return VirusApiVirusReportsByTaxonRequest
*/
func (a *VirusApiService) VirusReportsByTaxon(ctx context.Context, taxon string) VirusApiVirusReportsByTaxonRequest {
	return VirusApiVirusReportsByTaxonRequest{
		ApiService: a,
		ctx: ctx,
		taxon: taxon,
	}
}

// Execute executes the request
//  @return V2reportsVirusDataReportPage
func (a *VirusApiService) VirusReportsByTaxonExecute(r VirusApiVirusReportsByTaxonRequest) (*V2reportsVirusDataReportPage, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V2reportsVirusDataReportPage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VirusApiService.VirusReportsByTaxon")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/virus/taxon/{taxon}/dataset_report"
	localVarPath = strings.Replace(localVarPath, "{"+"taxon"+"}", url.PathEscape(parameterToString(r.taxon, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.filterRefseqOnly != nil {
		localVarQueryParams.Add("filter.refseq_only", parameterToString(*r.filterRefseqOnly, ""))
	}
	if r.filterAnnotatedOnly != nil {
		localVarQueryParams.Add("filter.annotated_only", parameterToString(*r.filterAnnotatedOnly, ""))
	}
	if r.filterReleasedSince != nil {
		localVarQueryParams.Add("filter.released_since", parameterToString(*r.filterReleasedSince, ""))
	}
	if r.filterUpdatedSince != nil {
		localVarQueryParams.Add("filter.updated_since", parameterToString(*r.filterUpdatedSince, ""))
	}
	if r.filterHost != nil {
		localVarQueryParams.Add("filter.host", parameterToString(*r.filterHost, ""))
	}
	if r.filterPangolinClassification != nil {
		localVarQueryParams.Add("filter.pangolin_classification", parameterToString(*r.filterPangolinClassification, ""))
	}
	if r.filterGeoLocation != nil {
		localVarQueryParams.Add("filter.geo_location", parameterToString(*r.filterGeoLocation, ""))
	}
	if r.filterCompleteOnly != nil {
		localVarQueryParams.Add("filter.complete_only", parameterToString(*r.filterCompleteOnly, ""))
	}
	if r.returnedContent != nil {
		localVarQueryParams.Add("returned_content", parameterToString(*r.returnedContent, ""))
	}
	if r.tableFields != nil {
		t := *r.tableFields
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("table_fields", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("table_fields", parameterToString(t, "multi"))
		}
	}
	if r.pageSize != nil {
		localVarQueryParams.Add("page_size", parameterToString(*r.pageSize, ""))
	}
	if r.pageToken != nil {
		localVarQueryParams.Add("page_token", parameterToString(*r.pageToken, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "application/x-ndjson", "text/tab-separated-values"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuthHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v RpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
